<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julia | Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/tags/julia/</link>
      <atom:link href="https://teshenglin.github.io/tags/julia/index.xml" rel="self" type="application/rss+xml" />
    <description>Julia</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 01 Jan 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Julia</title>
      <link>https://teshenglin.github.io/tags/julia/</link>
    </image>
    
    <item>
      <title>Julia 學習筆記 - 畫圖</title>
      <link>https://teshenglin.github.io/post/2020_julia_plots/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_plots/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;底下的幾個例子我們將學習怎麼使用繪圖指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;畫圖的時候我們會用到 &lt;code&gt;Plots&lt;/code&gt; 這個 package，因此在第一行我們需要加上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下我們舉幾個簡單的範例來看看如何操作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; &lt;code&gt;Plots&lt;/code&gt; 這個 package 完整的說明請見 
&lt;a href=&#34;http://docs.juliaplots.org/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plots&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-11-基本函數&#34;&gt;Example 1.1 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin(x)$ 的例子。在 plot 指令中我們指定三件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;告訴他我們要畫 $y = \sin(x)$ 這個函數。&lt;/li&gt;
&lt;li&gt;再來要指定函數的範圍 $-\pi &amp;lt; x &amp;lt; \pi$。&lt;/li&gt;
&lt;li&gt;最後用 label 標註函數圖形。注意要把標註的文字放在 &amp;quot; &amp;quot; 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，也可以畫 $e^x$、$arcsin(x)$ 這些基本函數。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(sin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi, pi, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;example-12-基本函數&#34;&gt;Example 1.2 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin^{-1}(x)$ 的例子，有幾件事需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\sin(x)$ 的反函數 $arcsin(x)$ 的指令為 asin。&lt;/li&gt;
&lt;li&gt;函數的範圍為 $-1 &amp;lt; x &amp;lt; 1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(asin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arcsine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-2&#34;&gt;Example 2&lt;/h2&gt;
&lt;p&gt;接著我們看三維圖形的例子。這個例子中我們要畫出三維中的一條曲線&lt;/p&gt;
&lt;p&gt;$$\left(x(t), y(t), z(t)\right) = (t\cos t, t\sin t, t), \quad t\in[0, 8\pi].$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先將 $8\pi$ 切成 N 等分, 間距為 $\Delta t = 8\pi/N$.
&lt;ol&gt;
&lt;li&gt;在 julia 中可使用 unicode 變數名稱, 比如 $\Delta$ 打法是 &lt;code&gt;\Delta&lt;/code&gt; 接著按 tab 鍵, $\pi$ 則是 &lt;code&gt;\Pi&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定義 $n$ 是一個 $(N+1)\times 1$ 的向量，n = [0, 1, 2, &amp;hellip;,N]。&lt;/li&gt;
&lt;li&gt;定義 $t_i$ 是 $\Delta t\times n$&lt;/li&gt;
&lt;li&gt;$x = t_i .*\cos .(ti)$，注意向量相乘以及函數在向量的取值都需要加個&lt;code&gt;.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y 與 z 的值與 x 的值定義方法類似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由 (x,y,z) 的定義方式我們知道它是一個螺旋線，螺旋的半徑從 0 一直增加到 $8 \pi$。角度也是從 0 到 $8 \pi$，所以總共繞了4圈。
在 plot 指令中我們用 marker 選擇圖形的樣式為圓圈(circle)，legend=false 代表不標記圖形。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;;
Δt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;π&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N;
ti &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Δt&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti;
plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=:&lt;/span&gt;circle, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_9_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外, 可以用 &lt;code&gt;camera&lt;/code&gt; 這個指令來調整 3D 視角, 裡面數字是角度 (方位角azimuth, 高度角altitude).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=:&lt;/span&gt;circle, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, camera &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_11_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們也可以使用指令 &lt;code&gt;plotd3d&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們設定 linewidth (lw) 等於 2 以及 legend (leg) 等於 false 表示不標記圖形.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot3d(x, y, z, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_13_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3&#34;&gt;Example 3&lt;/h2&gt;
&lt;p&gt;這個例子中，我們將學到怎麼在一個畫好的圖形上再加上另一個圖形。
我們嘗試一個簡單的例子，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一個圖形，x 座標是取整數 1 到 10。y 軸取 0 到 1 之間的亂數，共十個小數。再來，用 plot 指令將第一個圖形畫出。&lt;/li&gt;
&lt;li&gt;第二個圖形，使用相同的 x 座標，函數值 z 取亂數。將第二個函數圖形與第一個圖形重疊，我們需要指令 plot!&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
plot(x,y)
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
plot!(x,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-4&#34;&gt;Example 4&lt;/h2&gt;
&lt;p&gt;在一個圖形中同時畫出兩個函數，除了上述的方法之外我們還可以這麼做： 直接把兩個函數值定義成一個矩陣&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義 x 是整數 1 到 10。&lt;/li&gt;
&lt;li&gt;定義函數值 y 是一個 10*2 的矩陣，矩陣的第一行代表第一個函數的值，而矩陣的第二行代表第二個函數的值。y值的取法為 0 到 1 之間的亂數，為小數。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 plot 將兩個函數值同時畫出，用 title 設定圖形標題，lw=3 設定線段寬度。&lt;/p&gt;
&lt;p&gt;用 label=[&amp;ldquo;Line 1&amp;rdquo; &amp;ldquo;Line 2&amp;rdquo;] 標記函數名稱，須注意順序：
Line 1 會標記 y 的第一個函數值，Line 2 會標記 y 的第二個函數值。&lt;/p&gt;
&lt;p&gt;x 軸的名稱有兩種設定方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 plot 指令中加入：xlabel = &amp;ldquo;My x label&amp;rdquo;。 (xlabel 後面不用&amp;rdquo;!&amp;quot;)&lt;/li&gt;
&lt;li&gt;或是在 plot 指令的下一行用 xlabel!(&amp;ldquo;My x label&amp;rdquo;) 加入。(xlabel! 後面要用&amp;rdquo;!&amp;quot;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-5&#34;&gt;Example 5&lt;/h2&gt;
&lt;p&gt;如果函數取點的方法不同，能不能畫在同一張圖形中呢？
我們看下面的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;y 這個矩陣裡包含兩筆資料，x 的取點都是整數 1 到 10。所以可以用 &amp;ldquo;一個&amp;rdquo; 指令把兩筆資料畫出來。令這張圖叫做 p&lt;/li&gt;
&lt;li&gt;z 這筆資料為 0 到 1 中的 19 個亂數，xx 的取點也是19個在 [1, 10] 的均勻取點。所以我們用 plot! 指令，先畫出 p, 再把 z 這筆資料畫上去。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(x,y)

xx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)
plot!(p,xx,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 利用 &lt;code&gt;plot(x,y,xx,z)&lt;/code&gt; 這樣的指令是行不通的!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 另外，畫圖也可以用 &lt;code&gt;PyPlot&lt;/code&gt; 這個 package，有很多有趣的效果可以用。&lt;/p&gt;
&lt;p&gt;更多範例請見 
&lt;a href=&#34;http://blog.maxkit.com.tw/2019/06/julia-data-visulization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Data Visualization&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-6---曲面&#34;&gt;Example 6 - 曲面&lt;/h2&gt;
&lt;p&gt;這個例子我們示範如何畫曲面 $(x, y, h(x,y))$, where $h(x,y) = exp(-(x^2+y^2))$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我們設定 x 與 y 的範圍 $[-1, 1]$.&lt;/li&gt;
&lt;li&gt;接著我們設定函數 &amp;ldquo;h&amp;rdquo;&lt;/li&gt;
&lt;li&gt;最後, 我們利用指令 &lt;code&gt;surface&lt;/code&gt; 來畫曲面.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
y&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
h(x,y)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
surface(x,y,h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-7-動畫&#34;&gt;Example 7: 動畫&lt;/h2&gt;
&lt;p&gt;如果要將很多圖片合在一起做成動畫也是可以, 以下這個簡單例子將動畫存成一個 gif 檔.&lt;/p&gt;
&lt;p&gt;更多細節請見 
&lt;a href=&#34;https://docs.juliaplots.org/latest/animations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia_plots_animations&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot([sin, cos], zeros(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
anim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Animation()
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;π, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
    push!(p, x, &lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;[sin(x), cos(x)])
    frame(anim)
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
gif(anim, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine_cosine.gif&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 計時</title>
      <link>https://teshenglin.github.io/post/2020_julia_timing/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_timing/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 計算程式執行時間的指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，julia 計算程式運行效能有幾個指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@time&lt;/code&gt; 顯示出程式運行的秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timed&lt;/code&gt; 顯示程式執行回傳值，秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timev&lt;/code&gt; 顯示&lt;code&gt;@time&lt;/code&gt;一樣的資訊，最後顯示程式執行回傳值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@elapsed&lt;/code&gt; 顯示出某程式運行的秒數&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 真正要計算程式效能, 還是推薦用 &lt;code&gt;BenchmarkTools.jl&lt;/code&gt; 這個 package.&lt;/p&gt;
&lt;p&gt;以下範例中我們需要使用兩個 package: &lt;code&gt;LinearAlgebra&lt;/code&gt; 以及 &lt;code&gt;BenchmarkTools&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; BenchmarkTools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;example-1-matrix-matrix-multiplication&#34;&gt;Example 1: Matrix-matrix multiplication&lt;/h2&gt;
&lt;p&gt;我們以矩陣乘法 $C=A\times B$ 為例：$A:n\times p$, $B:p\times m$, $C:n\times m$&lt;/p&gt;
&lt;p&gt;f1 這個函數會產生兩個隨機矩陣 $A$, $B$ 並且將他們相乘:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f1(n, p, m)
   A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
   B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
   C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;m
         &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;p
            C[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; C[i,j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;A[i,k]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;B[k,j]
         &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們先試試看以 julia 既有的計算時間指令來看結果如何&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@time&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.076423 seconds (161.79 k allocations: 8.380 MiB)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;(nothing, 0.000448109, 184496, 0.0, Base.GC_Diff(184496, 1, 0, 5, 2, 0, 0, 0, 0))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timev&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.005932 seconds (8 allocations: 180.172 KiB, 92.28% gc time)
elapsed time (ns): 5931535
gc time (ns):      5473727
bytes allocated:   184496
pool allocs:       5
non-pool GC allocs:2
malloc() calls:    1
GC pauses:         1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@elapsed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;0.000561533
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這些指令的表現如同一開始我們所介紹的, 顯示出程式執行時間以及其他資訊.&lt;/p&gt;
&lt;p&gt;不過一般而言一個程式在第一次跑及之後幾次跑的運行效能會不同, 這是由於初始化的關係. 所以我們通常要跑好幾次來算平均, 已得知一個程式的真正效能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;benchmark&lt;/code&gt; 就提供了這樣的功用, 他會跑好幾次程式, 並且計算最大最小時間.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     437.243 μs (0.00% GC)
  median time:      485.922 μs (0.00% GC)
  mean time:        513.114 μs (3.90% GC)
  maximum time:     44.383 ms (98.89% GC)
  --------------
  samples:          9711
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著我們看一下如果用 &lt;code&gt;LinearAlgebra&lt;/code&gt; 裡的矩陣乘法指令效能如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f2(n, p, m)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
    B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
    C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
    mul!(C,A,B);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f2(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     41.088 μs (0.00% GC)
  median time:      91.270 μs (0.00% GC)
  mean time:        106.954 μs (19.04% GC)
  maximum time:     45.286 ms (99.75% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起來似乎比我們自己寫的 for-loop 效能好一些.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;type-stability&#34;&gt;type-stability&lt;/h2&gt;
&lt;p&gt;julia 語言號稱效能非常好, 不過常常我們自己寫一個 julia 程式發現跑得沒有很快, 這通常是由於所謂的 “型別穩定性 type-stability”. 這樣的問題可以藉由以下幾個 julia 內建的巨集程式來診斷.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_warntype&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_typed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_native&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這方面更深入的說明可見 
&lt;a href=&#34;https://docs.julialang.org/en/v1/manual/performance-tips/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia: performance tips&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-2-vector-2-norm&#34;&gt;Example 2: Vector 2-norm&lt;/h2&gt;
&lt;p&gt;接著我們看一下算向量 2-norm 的效能, 一樣我們比較一下自己寫的以及 call 函數的方式.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t1(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    vec&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.42 KiB
  allocs estimate:  3
  --------------
  minimum time:     423.973 μs (0.00% GC)
  median time:      504.538 μs (0.00% GC)
  mean time:        606.699 μs (9.87% GC)
  maximum time:     47.376 ms (98.43% GC)
  --------------
  samples:          8213
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t2(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    sum(abs2, vec);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t2(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.33 KiB
  allocs estimate:  2
  --------------
  minimum time:     141.160 μs (0.00% GC)
  median time:      195.940 μs (0.00% GC)
  mean time:        335.496 μs (19.51% GC)
  maximum time:     64.500 ms (99.17% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3-solving-linear-system&#34;&gt;Example 3: Solving linear system&lt;/h2&gt;
&lt;p&gt;這裡我們看一下解線性系統, 也就是 matlab 常見的&amp;quot;左除&amp;rdquo;, 的效率如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; s1(n)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,n);
    b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n);
    A&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;s1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; s1(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  15.28 MiB
  allocs estimate:  8
  --------------
  minimum time:     13.463 ms (0.00% GC)
  median time:      16.817 ms (10.20% GC)
  mean time:        18.148 ms (9.36% GC)
  maximum time:     64.226 ms (77.63% GC)
  --------------
  samples:          276
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_julia/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_julia/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 這個程式語言. 這是一個非常新的語言, 在 2009 年才問世, 遠比 1990 年出生的 python 來的年輕許多. 不過由於它又&lt;em&gt;&lt;strong&gt;快&lt;/strong&gt;&lt;/em&gt;又&lt;em&gt;&lt;strong&gt;簡單&lt;/strong&gt;&lt;/em&gt;, 又&lt;em&gt;&lt;strong&gt;不用錢&lt;/strong&gt;&lt;/em&gt;, 使得目前有越來越多人開始使用這個新語言. 相信未來會更加普及.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-安裝&#34;&gt;Julia 安裝&lt;/h2&gt;
&lt;p&gt;在 
&lt;a href=&#34;https://julialang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 官方網站&lt;/a&gt; 上可以下載各系統平台的安裝包裹. 下載安裝後即可運行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Julia 安裝教學影片可參考 
&lt;a href=&#34;https://youtu.be/v7XeveI19CM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia課程環境簡介 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只想試用一下的話可以試試 
&lt;a href=&#34;https://repl.it/languages/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repl.it&lt;/a&gt; 這個線上編輯器. 它可以讓你在線上編輯並執行一些簡單的 julia 程式.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 julia 主程式外, 我也建議加裝 &lt;code&gt;Jupyter notebook&lt;/code&gt;(或 &lt;code&gt;Jupyter lab&lt;/code&gt;) 以及 &lt;code&gt;Atom&lt;/code&gt;. 讓你 coding 更方便.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;julia-基本簡介&#34;&gt;Julia 基本簡介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查詢版本資訊&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; versioninfo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;套件(package)管理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會進入套件管理系統
```julia
pkg&amp;gt;
```

查詢已安裝套件
```julia
pkg&amp;gt; status
```

更新套件
```julia
pkg&amp;gt; update
```

跳出系統請按鍵盤上的 `刪除鍵`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢指令(如matlab中的help)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會變成查詢的視窗
```julia
help?&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jupyter-notebook-安裝&#34;&gt;Jupyter notebook 安裝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Jupyter notebook 是個互動式筆記本, 很容易可以逐行執行並且做到資料視覺化, 並且支援多種主流的直譯語言像是 &lt;code&gt;Julia&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;. 有一說是 jupyter 這個字事實上就是由 julia, python 以及 R 這三個字組合而成.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 有兩種方式. 第一種是直接由 julia 安裝. 步驟如下&lt;/p&gt;
&lt;p&gt;在 julia 輸入 &lt;code&gt;]&lt;/code&gt; 進入套件管理命令提示. 然後會長得像這樣&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著輸入 &lt;code&gt;status&lt;/code&gt; 可以看到現在已經安裝的套件.&lt;/p&gt;
&lt;p&gt;我們要安裝 IJulia, 所以輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; add IJulia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安裝完後要退出套件管理則是 BackSpace 鍵或是 Ctrl+C 都可以.&lt;/p&gt;
&lt;p&gt;要打開 notebook 需要退出套件管理, 並在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; notebook()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter notebook 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/@jamescchuang/%e5%af%a6%e6%88%b0%e5%ae%89%e8%a3%9d%e5%8f%8a%e5%bb%ba%e7%bd%ae-julia-%e9%96%8b%e7%99%bc%e7%92%b0%e5%a2%83-6dc8c0d14c2a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安裝及建置 Julia 開發環境實戰教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前已經有 jupyter notebook 的升級版, 稱為 jupyter lab. 在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; jupyterlab()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter lab 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 的第二種方式則是透過 anaconda. 先裝完 julia 後下載 anaconda 安裝, 即可快樂使用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/datainpoint/jupyter-kernels-3151a6408bab&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打造 Jupyter Notebook 資料科學環境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;在-atom-中操作-julia&#34;&gt;在 Atom 中操作 Julia&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果平常會寫各式程式語言, 可以考慮加安裝 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要在 Atom 裡操作 Julia 簡單說就是要裝以下幾個 package:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;julia-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;language-julia&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uber juno&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就可以用了!!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1550260279.html?fbclid=IwAR3bBrHTvjF3Y5TJrZsElriJfO2fbyoM751XMfjLYOE0TLl31JA3LSpe8KQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Atom 中操作 Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-基本簡介與語法教學&#34;&gt;Julia 基本簡介與語法教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/Introducing_Julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia: wikibook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://learnxinyminutes.com/docs/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Learn X in Y minutes, where X=Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Julia Taiwan發起人杜岳華的 slideshare: 
&lt;a href=&#34;https://www.slideshare.net/ssuserd6984b/coscup-introduction-to-julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://hackmd.io/@7WeiUEuJSBKp7WCRouAWVg/r106dSpkb/%2FIwZgbAHApgnARgMwLQAYAmKxICxQMZpICGGATEjHtgOwwwrRwCsEQA%3D%3D?type=book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 中文官方文件草稿&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;youtube-上的-julia-超新手教學&#34;&gt;Youtube 上的 Julia 超新手教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/JuliaLangTW/julia_tutorials_for_dummy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之一 on github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/zzrctueO6JY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之二 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/W7R5dxGrxlk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之三 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算微分</title>
      <link>https://teshenglin.github.io/post/2019_derivate_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_derivate_evaluate/</guid>
      <description>&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_limit_evaluate&#34;&gt;用電腦算極限&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要講的是用數值計算來算函數的微分值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;已知一個函數 $f(x)$ 在某個點 $a$ 的微分值定義是
$$
f&amp;rsquo;(a) = \lim_{h\to 0} \frac{f(a+h)-f(a)}{h}.
$$&lt;/p&gt;
&lt;p&gt;我們用一個簡單的例子試試看. 假設我們想求 $f(x)=x^2$ 在 $x=\pi$ 的微分. 根據定義我們有&lt;/p&gt;
&lt;p&gt;$$
f&amp;rsquo;(\pi) = \lim_{h\to 0} \frac{(\pi+h)^2-\pi^2}{h}.
$$&lt;/p&gt;
&lt;p&gt;接著我們將 $h$ 取靠近 $0$ 的 $11$ 的點並帶入上列這個式子試著來算其極限值. &lt;code&gt;Julia&lt;/code&gt; 程式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;); h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; h[&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((pi&lt;span style=&#34;color:#f92672&#34;&gt;.+&lt;/span&gt;h)&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt; pi&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;h;
hcat(h, fp, fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;結果如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$h$&lt;/th&gt;
&lt;th&gt;$f&#39;$&lt;/th&gt;
&lt;th&gt;$f&amp;rsquo;-2\pi$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;6.29319&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.009&lt;/td&gt;
&lt;td&gt;6.29219&lt;/td&gt;
&lt;td&gt;0.009&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.008&lt;/td&gt;
&lt;td&gt;6.29119&lt;/td&gt;
&lt;td&gt;0.008&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.007&lt;/td&gt;
&lt;td&gt;6.29019&lt;/td&gt;
&lt;td&gt;0.007&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.006&lt;/td&gt;
&lt;td&gt;6.28919&lt;/td&gt;
&lt;td&gt;0.006&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.005&lt;/td&gt;
&lt;td&gt;6.28819&lt;/td&gt;
&lt;td&gt;0.005&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.004&lt;/td&gt;
&lt;td&gt;6.28719&lt;/td&gt;
&lt;td&gt;0.004&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;6.28619&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;td&gt;6.28519&lt;/td&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;6.28419&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上列數字最左邊是 $h$ 值, 中間為估計的微分值. 我們發現的確這個數字會越來越接近真實的解, 也就是 $2\pi$, 約等於 $6.283185307179586$. 最右邊為這個估算值與真實值 $2\pi$ 之間的差. 的確, 當 $h$ 越接近零, 這個估計出來的微分值離 $2\pi$ 的距離越來越小.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 用數值計算微分能有多精確? 這個誤差能不能一直遞減下去?&lt;/p&gt;
&lt;p&gt;接著我們取更多靠近 $0$ 的點來計算微分的極限值, 我們列出其與真實值 $2\pi$ 之間的差, 並且把它畫出來.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;); h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;h[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]);
fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((pi&lt;span style=&#34;color:#f92672&#34;&gt;.+&lt;/span&gt;h)&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt; pi&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;h;
hcat(h, fp, abs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;結果如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$h$&lt;/th&gt;
&lt;th&gt;$f&#39;$&lt;/th&gt;
&lt;th&gt;$abs(f&amp;rsquo;-2\pi)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;6.38319&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;6.29319&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;6.28419&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0001&lt;/td&gt;
&lt;td&gt;6.28329&lt;/td&gt;
&lt;td&gt;0.0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-5&lt;/td&gt;
&lt;td&gt;6.2832&lt;/td&gt;
&lt;td&gt;9.99998e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-6&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;1.00006e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-7&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;9.5898e-8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-8&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;4.26073e-8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-9&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;2.20243e-7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-10&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;1.9966e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-11&lt;/td&gt;
&lt;td&gt;6.28315&lt;/td&gt;
&lt;td&gt;3.35305e-5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-12&lt;/td&gt;
&lt;td&gt;6.28297&lt;/td&gt;
&lt;td&gt;0.000211166&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-13&lt;/td&gt;
&lt;td&gt;6.27054&lt;/td&gt;
&lt;td&gt;0.0126457&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-14&lt;/td&gt;
&lt;td&gt;6.39488&lt;/td&gt;
&lt;td&gt;0.111699&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-15&lt;/td&gt;
&lt;td&gt;5.32907&lt;/td&gt;
&lt;td&gt;0.954115&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-16&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;觀察最後一下發現, 當 $h$ 很小時微分竟然與真實質差更多, 更不準了!! 比如說當 $h=10^{-14}$ 時, 誤差竟然大到約是 $10^{-1}$.&lt;/p&gt;
&lt;p&gt;我們把它畫出來看看, &lt;code&gt;Julia&lt;/code&gt; code 如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
plot(log10&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(h), log10&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(abs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi)),label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error&amp;#34;&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log10(h)&amp;#34;&lt;/span&gt;)
ylabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log10(Error)&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;發現雖然誤差在 $h$ 大的時候遞減, 不過當 $h$ 接近零的時候卻又遞增上去了.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2019_derivative_evaulate_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2019_derivative_evaulate_01.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;那誤差最小值出現在什麼時候呢?&lt;/p&gt;
&lt;p&gt;我們發現當 當 $h=1.0*10^{-8}$ 時, 其估計出來的微分值離真實值誤差最小, 其誤差為 $4.26 *10^{-8}$.&lt;/p&gt;
&lt;p&gt;不過, WHY?? 為什麼誤差不會一直往下遞減? 其實這也是因為 &lt;strong&gt;捨入誤差(rounding-error)&lt;/strong&gt; 的關係.&lt;/p&gt;
&lt;p&gt;觀察一下我們的式子
$$
\frac{f(a+h)-f(a)}{h}
$$
當我們在用數值計算這個式子的時候其實並不完全是這樣子, 在分子應該會有捨入誤差在, 也就是說, 其實我們看到的數字應該是以下這個式子算出來的
$$
\frac{f(a+h)-f(a) + \epsilon}{h}
$$
其中的 $\epsilon$ 就是捨入誤差. 所以, 我們計算的時候會多出了 $\frac{\epsilon}{h}$ 這麼多.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;泰勒展開式&#34;&gt;泰勒展開式&lt;/h4&gt;
&lt;p&gt;再深一點來說, 我們可以利用泰勒展開式知道
$$
\frac{f(a+h)-f(a)}{h} = f&amp;rsquo;(a) + \frac{h}{2}f&amp;rsquo;&#39;(\xi), \quad a\leq \xi \leq a+h.
$$
這個式子告訴我們, 用這方式算微分誤差應該是 $\frac{h}{2}f&amp;rsquo;&#39;(\xi) = O(h)$, 誤差會隨著 $h$ 減少而線性變小.&lt;/p&gt;
&lt;p&gt;數學上我們有以上這個等式, 而數值計算上則是有以下這個等式
$$
\frac{f(a+h)-f(a) + \epsilon}{h} = f&amp;rsquo;(a) + \frac{h}{2}f&amp;rsquo;&#39;(\xi) + \frac{\epsilon}{h}, \quad a\leq \xi \leq a+h.
$$
也就是說, 真正的誤差公式應該是
$$
\frac{h}{2}f&amp;rsquo;&#39;(\xi) + \frac{\epsilon}{h},
$$
當 $h$ 非常小的時候 $\frac{\epsilon}{h}$ 這項就會變很大.&lt;/p&gt;
&lt;p&gt;比如說, 依我們之前所算的 $\epsilon\approx 10^{-16}$, 那當 $h=10^{-8}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-8}} = 10^{-8}$.&lt;/p&gt;
&lt;p&gt;而當 $h=10^{-14}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-14}} = 10^{-2}$. 跟我們之前所發現的完全吻合!! 而這也就是為什麼當 $h$ 很靠近零的時候誤差會上升的原因.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;optimal-h&#34;&gt;Optimal $h$&lt;/h4&gt;
&lt;p&gt;那給定一個微分公式, 要怎麼知道 $h$ 能小到什麼程度呢? 一個簡單的感覺是這樣的, 由於誤差的第一項  $\frac{h}{2}f&amp;rsquo;&#39;(\xi)$ 會隨著 $h$ 變小而變小, 第二項 $\frac{\epsilon}{h}$ 則會變大, 因此整體最小值約會發生在兩項交叉時, 也就是當
$$
h \sim \frac{\epsilon}{h},
$$
(由於我們不知道 $f&amp;rsquo;&#39;(\xi)/2$ 是多少, 簡單起見設成 1). 上式稍微計算一下發現誤差最小值約發生在 $h=10^{-8}$, 誤差最小值則約為 $10^{-8}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;最後總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我們可以用數值計算來估計一個函數在某點的微分值
$$
f&amp;rsquo;(a) \approx \frac{f(a+h)-f(a)}{h}.
$$
這樣的做法稱為&lt;strong&gt;有限差分法 (finite difference method)&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不過計算時 $h$ 值不能無限取小, 需考慮到捨入誤差的影響.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算極限</title>
      <link>https://teshenglin.github.io/post/2019_limit_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_limit_evaluate/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹如何用電腦算極限, 以及我們來看一下當我們真的這樣做的時候有可能會發生什麼問題. 我們以 $sinc$ 函數為例來做說明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;sinc-function&#34;&gt;sinc function&lt;/h3&gt;
&lt;p&gt;首先我們要介紹一個特別的函數, $sinc(x)$, 定義如下:
$$
sinc(x) = \frac{\sin(x)}{x}, \quad x\ne 0.
$$
很明顯可以看出來當 $x=0$ 的時候分母會等於零, 是一件壞事, 所以把 $x=0$ 這個點先拿掉.&lt;/p&gt;
&lt;p&gt;比較有趣的是我們可以把這個函數畫出來. 首先我們在 $[-20, 20]$ 這個區間取 $1000$ 個點, 然後帶入上面 $sinc$ 函數的定義, 再把所有點連起來看看.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 有件事需要先說明一下, 由於我們是在 $[-20, 20]$ 這個區間均勻的取偶數個點, 所以會有 $500$ 個正數以及 $500$ 個負數, 重點是保證不會取到 $x=0$ 這個點, 所以沒有問題. 相反的, 如果取奇數個點就一定會取到 $x=0$, 那就會有函數無定義的問題了.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_3_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_3_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;我們很輕易可以看出來, 連起來的線還蠻&amp;quot;光滑&amp;quot;的. 函數值在 $x=0$ 附近似乎不會趨近正無窮大或負無窮大, 也沒有跳躍的現象. 接著我們試著在 $x=0$ 附近放大一點看看, 我們在 $[-0.1, 0.1]$ 這個區間取 $1000$ 個點, 然後帶入 $sinc$ 函數的定義再把它畫出來:&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;看起來真的很光滑!! 而且似乎當 $x$ 很靠近 $0$ 時, $sinc(x)$ 的值很靠近 $1$.&lt;/p&gt;
&lt;p&gt;接著我們取一個會越來越靠近 $0$ 的數列, 然後看一下當把 $sinc$ 函數在這個數列的點上取值時, 其值會不會越來越靠近 $1$.  我們取以下數列:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1.670170079024566e-5
 6.14421235332821e-6
 2.2603294069810542e-6
 8.315287191035679e-7
 3.059023205018258e-7
 1.1253517471925912e-7
 4.139937718785167e-8
 1.522997974471263e-8
 5.602796437537268e-9
 2.061153622438558e-9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算一下 $sinc$ 函數在這些點上面的值, 並觀察他的趨勢:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0.9999999999535089
 0.9999999999937081
 0.9999999999991485
 0.9999999999998848
 0.9999999999999845
 0.9999999999999979
 0.9999999999999997
 1.0
 1.0
 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赫然發現算到後來就等於 $1$ 了!! 所以我們發現&lt;/p&gt;
&lt;p&gt;$$
\lim_{x\to 0} sinc(x) = \lim_{x\to 0} \frac{\sin(x)}{x} = 1.
$$&lt;/p&gt;
&lt;p&gt;不過有一點點詭異的是, 在剛剛的計算裡我們最多也只是取到離 $0$ 很近的點而已, 但是算出來的結果卻是 $1$. 難道不只是 $sinc(0)=1$, 我們也有 $sinc(2.061153622438558 *10^{-9})=1$ 嗎?&lt;/p&gt;
&lt;p&gt;事實上並不是這樣. 電腦有所謂的捨入誤差(rounding error). 這是因為電腦需要用有限位數來表達無窮小數, 所以一定要捨棄後面的位數. 我們把算出來的數字減去 $1$ 看看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -4.649114426769074e-11
 -6.291855925155687e-12
 -8.515410598874951e-13
 -1.1524114995609125e-13
 -1.554312234475219e-14
 -2.1094237467877974e-15
 -3.3306690738754696e-16
  0.0
  0.0
  0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們可以發現這個數字最小可以到大約 $10^{-16}$, 之後就變成 $0$ 了. 也就是說我們目前用個這個程式語言其捨入誤差大約就是 $10^{-16}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;machine-epsilon&#34;&gt;machine epsilon&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一般我們會用 machine epsilon 這個數字來量化在電腦裡浮點運算的捨入誤差.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;machine epsilon 的定義是, 考慮正數$\epsilon$, 使得 $ 1+ \epsilon \ge 1$ 中最小的那個稱之為 machine epsilon. 當然以數學來看這個 machine epsilon 必須等於零. 不過在電腦裡並不是這樣.&lt;/p&gt;
&lt;p&gt;為了方便我們稍微改一下定義, 我們考慮 $\epsilon = 2^{-k}$ 這種形式, 然後 machine epsilon 一樣是使得 $ 1+ \epsilon \ge 1$ 中最小的那個. &lt;code&gt;julia&lt;/code&gt; 程式如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;
        s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s
        println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;k=&amp;#34;&lt;/span&gt;, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,  eps=&amp;#34;&lt;/span&gt;, s)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我的電腦上我發現 $\epsilon = 2^{-52} = 2.220446049250313e-16$.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k=52,  eps=2.220446049250313e-16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以的確捨入誤差大約是 $10^{-16}$ 這個等級.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;稍微總結一下目前我們看到的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我們用程式跑數值發現 $sinc(x\to 0)=1$, 所以我們可以定義 sinc 函數為
$$
sinc(x) =
\begin{cases}
\frac{\sin(x)}{x}, \quad x\ne 0, \\\&lt;br&gt;
1, \quad x=0.
\end{cases}
$$
在這樣的定義之下 $sinc$ 函數是個&lt;code&gt;連續函數&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多關於 $sinc$ 函數的性質可以參考 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Sinc_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt; 上的介紹.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在數值計算上有所謂的捨入誤差, 這是用有限位元來表達無限位數一定會有的差異.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用 machines epsilon 來量化捨入誤差.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
