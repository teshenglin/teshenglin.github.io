<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>continuous | Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/tags/continuous/</link>
      <atom:link href="https://teshenglin.github.io/tags/continuous/index.xml" rel="self" type="application/rss+xml" />
    <description>continuous</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 04 Nov 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>continuous</title>
      <link>https://teshenglin.github.io/tags/continuous/</link>
    </image>
    
    <item>
      <title>Fixed point iteration</title>
      <link>https://teshenglin.github.io/post/2019_fixed_point/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_fixed_point/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們介紹固定點迭代法 (Fixed point iteration)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們介紹什麼是固定點 (Fixed point)&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;definition-fixed-point&#34;&gt;Definition: Fixed point&lt;/h2&gt;
&lt;p&gt;A fixed point of a function $f(x)$ is a number $c$ in its domain such that $f(c)=c$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以簡單來說, 把固定點這個數字丟進函數後會得到同樣的一個數字. 所以稱之為固定點.&lt;/p&gt;
&lt;p&gt;那固定點重要性其一是在數值計算上有一種迭代方式叫做固定點迭代(Fixed point iteration). 假設我們想要求某個函數的固定點, 也就是滿足 $c=f(c )$ 的這些 $c$, 那我們可以定義一個迭代式
$$
x_{n+1} = f(x_n).
$$&lt;/p&gt;
&lt;p&gt;如果夠幸運的, $\{x_{n}\}$ 這串數字收斂了, 那把它收斂到的數字稱為 $\bar{c}$ 我們就有 $\bar{c}=f(\bar{c})$, 也就是固定點.&lt;/p&gt;
&lt;p&gt;舉個例子來說, 假設我們想要解 $x=\cos(x)$ 這個方程式, 那我們可以定義一個固定點迭代為
$$
x_{n+1} = \cos(x_n).
$$&lt;/p&gt;
&lt;p&gt;這樣的話如果數列收斂, $\{x_{n}\}\to \bar{x}$, 那我們就有 $\bar{x}=\cos(\bar{x})$, 那就解出來了!!&lt;/p&gt;
&lt;p&gt;不過這裡有兩個問題.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;為什麼這個數列會收斂?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原方程式的固定點迭代其實有無窮多種改寫方式, 例如也可寫為 $x_{n+1} = \cos^{-1}(x_n)$. 如果收斂的話一樣會是原方程式的解. 那, 哪種改寫方式最好呢?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我們有以下這個定理&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem&#34;&gt;Theorem&lt;/h2&gt;
&lt;p&gt;If $f:[a, b]\to [a,b]$ is a differentiable function such that
$$ |f&amp;rsquo;(x)|\leq \alpha&amp;lt;1, \quad \forall x\in[a, b],$$
then $f$ has exactly one fixed point $c$ and the fixed point iteration converges to $c$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個證明很簡單.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;proof&#34;&gt;Proof&lt;/h3&gt;
&lt;h3 id=&#34;sketch-not-complete-please-full-in-the-details-by-yourself&#34;&gt;(Sketch, not complete, please full-in the details by yourself)&lt;/h3&gt;
&lt;h4 id=&#34;existence&#34;&gt;existence&lt;/h4&gt;
&lt;p&gt;Since the domain and the range of $f$ are both $[a, b]$, by Intermediate Value Theorem, there exists $c$ such that $c=f(c ).$&lt;/p&gt;
&lt;h4 id=&#34;uniqueness&#34;&gt;uniqueness&lt;/h4&gt;
&lt;p&gt;If there exits another fixed point $\bar{c}$, $\bar{c}\ne c$, such that $\bar{c}=f(\bar{c} )$, then according to Mean Value Theorem(MVT), there exits $z$ between $c$ and $\bar{c}$ such that $$f&amp;rsquo;(z) = \frac{f(c ) - f(\bar{c})}{c-\bar{c}}=\frac{c - \bar{c}}{c-\bar{c}} = 1,$$ which violate the assumption that $|f&#39;|\leq \alpha&amp;lt;1$. So the fixed point is unique.&lt;/p&gt;
&lt;h4 id=&#34;convergence-of-fixed-point-iteration&#34;&gt;convergence of fixed point iteration&lt;/h4&gt;
&lt;p&gt;Based on MVT we have
$$|x_{n+1} - c| = |f(x_n) - f(c )| = |f&amp;rsquo;(c_i)(x_n-c)|\leq\alpha |x_n-c|\leq\alpha^n|x_1-c|\to 0.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以如果在函數固定點 $c$ 的微分小於 $1$, 那就存在一個包含 $c$ 的小區間使得函數的微分都在這區間內小於 $1$, 那根據這定理固定點迭代就會收斂.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;固定點迭代是求根問題(root finding problems)中很重要的一種迭代方式. 舉個例子來說, 假設我們想要找 $g(x)$ 這個函數的根, 那我們可以定義
$$
f(x) = x + g(x).
$$
這樣的話 $f$ 的固定點就會是 $g$ 的根了. 不過這種最簡單的改寫方式完全不保證會收斂.&lt;/p&gt;
&lt;p&gt;那要如何改寫才會比較好呢? 其中一個最有名的就是牛頓法 (Newton&amp;rsquo;s method):&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;newtons-iteration&#34;&gt;Newton&amp;rsquo;s iteration&lt;/h2&gt;
&lt;p&gt;$$x_{n+1} = x_n - \frac{g(x_n)}{g&amp;rsquo;(x_n)}.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們可以定義 $f(x) = x - \frac{g(x)}{g&amp;rsquo;(x)}$, 這樣上面這個式子就是個固定點迭代. 接著我們可以發現, 如果 $c$ 是 $g$ 函數的根, 也就是 $g(c )=0$, 那 $f&amp;rsquo;(c ) = 0$. 所以根據上面的定理就存在某個包含 $c$ 的小區間使得迭代會收斂.&lt;/p&gt;
&lt;p&gt;更進一步我們可以利用泰勒展開式(Taylor&amp;rsquo;s series expansion) 來證明牛頓法事實上有二次收斂,
$$
|x_{n+1} - c| \approx \beta |x_n-c|^2.
$$
這個證明我們這邊就先略過不寫. 不過接著我們來看一下牛頓法究竟有多快. (&amp;ndash;To be finished)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;依之前的例子我們想要解 $x=\cos(x)$, $x\in[0, \pi]$. 最簡單的固定點迭代為
$$
x_{n+1} = \cos(x_n),
$$
也就是求 $g(x) = \cos(x)-x$ 的根. 我們以 $x_0=1$ 當初始值, 發現需要 $80$ 個迭代才能使誤差在 $10^{-14}$ 之下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    x_new= 0.5403023058681398		error= 0.31725090997825367
    x_new= 0.8575532158463934		error= 0.2032634253486143
    x_new= 0.6542897904977791		error= 0.13919056824478648
    x_new= 0.7934803587425656		error= 0.0921115851198091
    x_new= 0.7013687736227565		error= 0.06259090927789768
    ⋮
    x_new= 0.7390851332151851		error= 4.0967229608668276e-14
    x_new= 0.7390851332151441		error= 2.7644553313166398e-14
    x_new= 0.7390851332151718		error= 1.865174681370263e-14
    x_new= 0.7390851332151531		error= 1.2545520178264269e-14
    x_new= 0.7390851332151657		error= 8.43769498715119e-15
    Total number of iterations=80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若是使用牛頓法迭代則迭代式為
$$
x_{n+1} = x_n + \frac{cos(x_n)- x_n}{\sin(x_n)+1}.
$$
一樣以 $x_0=1$ 當初始值, 發現只需要 $4$ 個迭代就能使誤差在 $10^{-14}$ 之下. 比上個例子快上許多.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    x_new= 0.7503638678402439		error= 0.018923073822117442
    x_new= 0.7391128909113617		error= 4.6455898990771516e-5
    x_new= 0.739085133385284		error= 2.847205804457076e-10
    x_new= 0.7390851332151607		error= 0.0
    Total number of iterations=4
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;最後總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定點迭代要收斂, 至少在固定點的微分值必須比 $1$ 小.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要取迭代函數, 如果知道如何對函數微分, 以牛頓法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Newton%27s_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Newton&amp;rsquo;s method&lt;/a&gt; 來取通常會有不錯的效果.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若無法得知微分函數, 可以用數值微分來逼近真實微分, 這樣會得到割線法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Secant_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;secant method&lt;/a&gt;, 收斂速度比牛頓法慢一點點.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定點定理保證在區間裡任意取點當初使迭代都會收斂, 不過要滿足定理的條件很強, 實務上不容易做到.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如牛頓法, 我們能證明一定存在某個區間滿足固定點定理, 不過實際上這個區間有多大並不知道. 因此一般在討論牛頓法時都會要求初始值要離實際要求的固定點&amp;quot;夠近&amp;rdquo;. 至於&amp;quot;夠近&amp;quot;什麼意思就只能用嘗試的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由於牛頓法不保證收斂, 因此實務上要求根時會與一些保證收斂的方法, 如二分逼進法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Bisection_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bisection method&lt;/a&gt; 來合作. 如 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Brent%27s_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brent-Dekker method&lt;/a&gt;. 這樣既能保證收斂, 又兼有收斂快速的優點.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Maximum and minimum of a function</title>
      <link>https://teshenglin.github.io/post/2019_maxmin/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_maxmin/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要討論一個函數的最大值以及最小值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們有極值定理&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem-extreme-value-theorem&#34;&gt;Theorem: Extreme value theorem&lt;/h2&gt;
&lt;p&gt;If $f$ is a real-valued continuous function on the closed interval $[a,b]$, then $f$ must attain a maximum and a minimum.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以對於定義在封閉區間的連續函數, 必定會有極值. 接下來我們看一下實際上我們怎麼把極值找出來.&lt;/p&gt;
&lt;p&gt;在微積分課本裡有所謂的封閉區間法, 如下:&lt;/p&gt;
&lt;h2 id=&#34;the-closed-interval-method&#34;&gt;The closed interval method&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD;
  B[f is `continuous` on a `closed interval`]--&amp;gt;A;
  B--&amp;gt;C;
  A[Determine the critical points]--&amp;gt;|f&#39;=0| D(The largest value at these points is the abs. max. and the smallest value is the abs. min.);
  A--&amp;gt;|f&#39; not exists| D;
  C[Determine the end points]--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個方法的原理跟做法都很簡單, 我這邊就不多做說明.&lt;/p&gt;
&lt;p&gt;不過我要做一些補充. 事實上這個方法要能用還有一個很重要的假設是&lt;code&gt;假設這個函數只在有限個地方微分不存在&lt;/code&gt;. 如果一個函數在無窮多地方微分不存在, 雖然最大值還會是 &amp;ldquo;微分等於 0&amp;rdquo;, &amp;ldquo;微分不存在&amp;rdquo;, &amp;ldquo;端點&amp;rdquo; 這些地方的函數值中找最大的. 不過實作上會找不完. 所以等於是沒有用.&lt;/p&gt;
&lt;p&gt;當然這樣的假設看起來很正常, 難道有函數是連續的, 但是在無窮多地方微分不存在嗎? 很不幸的也很幸運的, 真的有! 其中有一個很特別的函數叫做 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Weierstrass_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Weierstrass function&lt;/a&gt;. 它是定義在實數軸上的函數, 在每個點都連續, 但是同時在任何一個點微分都不存在. 所以如果套用 the closed interval method 在這函數上會發現所有的點都是 critical point, 所以套用之後還是必須要找出所有點中函數值最大的. 完全沒有簡化到.&lt;/p&gt;
&lt;h3 id=&#34;question-1-是否存在連續-但是在每個點微分都等於-0-的函數&#34;&gt;Question 1: 是否存在連續, 但是在每個點微分都等於 0 的函數?&lt;/h3&gt;
&lt;p&gt;當然有! 常數函數就是. 不過這個很好 check 最大最小值所以沒什麼問題.&lt;/p&gt;
&lt;h3 id=&#34;question-2-是否存在連續-但是在每個點微分都等於-0-的非常數函數non-constant-function&#34;&gt;Question 2: 是否存在連續, 但是在每個點微分都等於 0 的非常數函數(non-constant function)?&lt;/h3&gt;
&lt;p&gt;I will leave it as an exercise.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最後再補充一點, 函數在某個點連續但是微分不存在有幾種情形:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尖點. 例如 $f(x) = |x|$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直切線. 例如 $f(x) = \sqrt[3]{x}$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分定義中的極限不存在. 例如 $f(x) = x\sin(x)$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
