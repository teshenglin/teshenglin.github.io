<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>notes | Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/categories/notes/</link>
      <atom:link href="https://teshenglin.github.io/categories/notes/index.xml" rel="self" type="application/rss+xml" />
    <description>notes</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 13 Aug 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>notes</title>
      <link>https://teshenglin.github.io/categories/notes/</link>
    </image>
    
    <item>
      <title>Diffusion maps</title>
      <link>https://teshenglin.github.io/post/2021_diffusion_maps/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2021_diffusion_maps/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;擴散映射, 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Diffusion_map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diffusion maps&lt;/a&gt; (以下簡稱 DM), 是個資料分析, 流型學習或是資料降維的工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps 降維.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;algorithm---diffusion-maps-embeding&#34;&gt;Algorithm - diffusion maps embeding&lt;/h2&gt;
&lt;p&gt;先簡單介紹一下作法.&lt;/p&gt;
&lt;p&gt;假設我們有 $n$ 筆 $d$ 維的資料,
$$
\{x_1, x_2, \cdots, x_n\} \in R^d.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;我們需要先定一個 $K$ 矩陣, $K_{ij}=k(x_{i},x_{j})$, 一般而言我們使用 Guassian kernel
$$
k(x,y) = e^{-\frac{\lVert x-y \rVert^2}{\sigma^2}},
$$
其中 $\sigma$ 是個常數. 這樣造出來的 $K$ 矩陣會是個 $n\times n$ 對稱半正定的矩陣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著我們要定 diffusion matrix $P$, 其定義為
$$
P=D^{-1}K,
$$
其中 $D$ 是個只有對角線有值的矩陣, 其元素為相對應 $K$ 矩陣的 rowsum, $D_{ii} = \sum^n_{j=1} K_{ij}$.
因此可以知道 $P$ 矩陣其實就是將 $K$ 矩陣的每個 row 做 normalize 的動作, 使其 rowsum 等於 $1$.&lt;/p&gt;
&lt;p&gt;$P$ 這矩陣可看成是個機率矩陣, 其第 $i$ 個 row 表示從 $x_{i}$ 這個點跳到其他點的機率分佈.&lt;/p&gt;
&lt;p&gt;接著我們考慮 $Q$ 矩陣, 定義為
$$
Q=D^{-\frac{1}{2}}KD^{-\frac{1}{2}}.
$$
我們可以很輕易發現 $P$ 以及 $Q$ 兩個矩陣有完全相同的 eigenvalues, 而 $P$ 的 eigenvectors 是
$$
v = D^{-1/2}v_Q,
$$
其中 $v_Q$ 是 $Q$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;另一個重要觀察是 $Q$ 矩陣跟 $K$ 一樣是對稱半正定的矩陣, 因此它的 eigenvalues 都非負, 而且他的 eigenvalues 跟 singular values 會完全一模一樣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;先將 $Q$ 的 eigenvalues 跟 eigenvectors 都找出來, 接著 $P$ 的 eigenvalues 跟 eigenvectors 就依照上面的公式可以輕易得到.&lt;/p&gt;
&lt;p&gt;我們令 $P$ 的 eigenvalues 跟 eigenvectors 分別為 $\lambda_i$ 跟 $\psi_i$, $1\le i\le n$.&lt;/p&gt;
&lt;p&gt;需要注意的是, $\lambda_1=1$ 並且 $\psi_1$ 是一個常數向量, 因為我們要拿的是從第二個開始.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;接著我們定義 $Y$ 矩陣為
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \cdots, \lambda_n\psi_n\right],
$$
這是個 $n\times (n-1)$ 的矩陣.&lt;/p&gt;
&lt;p&gt;如果我們想要將原始資料投射到 $k$ 維, $k \le (n-1)$, 那我們就只要到第 $k+1$ 個 eigenvector 就好. 比如說要投影到三維, 我們只需要取
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \lambda_4\psi_4\right].
$$
而 diffusion maps embedding 的每個點就是這個 $Y$ 矩陣的 row, 也就是 $y_i = Y(i,:)$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;implementation-in-julia&#34;&gt;Implementation in &lt;code&gt;julia&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;接著我們就可以來看要怎樣以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps.&lt;/p&gt;
&lt;p&gt;我們需要以下幾個 packages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Distances
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;以下例子為一個 spiral curve, 我們想要看經過 diffusion maps 的投射到二或三維後會長什麼樣子.&lt;/p&gt;
&lt;p&gt;我們先把 spiral curve 上面的點造出來 (取 $300$ 個點)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# generating the data - a spiral curve&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# n: number of sampling&lt;/span&gt;
n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;

theta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi,length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
&lt;span style=&#34;color:#75715e&#34;&gt;# x and y-coordinates&lt;/span&gt;
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
&lt;span style=&#34;color:#75715e&#34;&gt;# X is a n-by-2 data matrix&lt;/span&gt;
X &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x y];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;畫出來看看原始 data 長怎樣. 我們照順序將點標為藍色, 紅色以及綠色.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), aspect_ratio&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:equal&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k-1&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;先來造出 $K$ 矩陣:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pairwise(Euclidean(), X, dims&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
sigma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;;
K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(E&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;(sigma&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q-1&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著造出 $Q$ 矩陣, 並求出其 eigenvalues 跟 eigenvectors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Q = zeros(n,n);
d_sq = zeros(n);
for ii = 1:n
    d_sq[ii] = sqrt(sum(K[ii,:]));
end
for ii = 1:n
    for jj = 1:n
        Q[ii,jj] = K[ii,jj]/(d_sq[ii]*d_sq[jj]);
    end
end
U,S,V = svd(Q);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors-1&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;$P$ 矩陣的 eigenvalues 跟 $Q$ 一樣, eigenvectors 也可以依公式得到:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; n
    V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;d_sq[ii];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;將 eigenvalues 畫出來看看. 左圖是第 $2$ 到第 $11$ 個, 右圖則是以 semilogy 畫出全部的 eigenvalues. 可以看出 eigenvalues 遞減的非常快, 所以其實 embedding 不需要取到全部 $(n-1)$ 維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scatter(S[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;], title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues 2:11&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(S), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues in log&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y-1&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;最後我們定義 embedding $Y$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;Y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(n,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
    Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;S[ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們知道 $Y$ 的每個 row 就是這個 embedding 的座標.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們將 embedding 畫出來看看. 左圖是 embed 到二維, 右圖則是 embed 到三維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們一樣照順序將點標為藍色, 紅色以及綠色. 有趣的是, 我們發現這個 embedding 將整個 spiral curve &lt;strong&gt;打開了&lt;/strong&gt;. 因此, 經由 diffusion maps 投射之後我們比較榮以可以看出點資料真正在整個曲線上彼此間距離的遠近.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;extension&#34;&gt;Extension&lt;/h2&gt;
&lt;p&gt;Diffusion maps 也常被拿來搭配 
&lt;a href=&#34;https://en.wikipedia.org/wiki/K-means_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k-means&lt;/a&gt; 做成分群演算法, 算是 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Spectral_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spectral clustering&lt;/a&gt; 的其中一種.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Diffusion maps 的 &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;julia&lt;/code&gt; 以及 &lt;code&gt;matlab&lt;/code&gt; 程式都可以在這裡找到: 
&lt;a href=&#34;https://github.com/teshenglin/diffusion_maps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github - teshenglin/diffusion_maps&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 畫圖</title>
      <link>https://teshenglin.github.io/post/2020_julia_plots/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_plots/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;底下的幾個例子我們將學習怎麼使用繪圖指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;畫圖的時候我們會用到 &lt;code&gt;Plots&lt;/code&gt; 這個 package，因此在第一行我們需要加上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下我們舉幾個簡單的範例來看看如何操作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; &lt;code&gt;Plots&lt;/code&gt; 這個 package 完整的說明請見 
&lt;a href=&#34;http://docs.juliaplots.org/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plots&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-11-基本函數&#34;&gt;Example 1.1 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin(x)$ 的例子。在 plot 指令中我們指定三件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;告訴他我們要畫 $y = \sin(x)$ 這個函數。&lt;/li&gt;
&lt;li&gt;再來要指定函數的範圍 $-\pi &amp;lt; x &amp;lt; \pi$。&lt;/li&gt;
&lt;li&gt;最後用 label 標註函數圖形。注意要把標註的文字放在 &amp;quot; &amp;quot; 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，也可以畫 $e^x$、$arcsin(x)$ 這些基本函數。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(sin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi, pi, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;example-12-基本函數&#34;&gt;Example 1.2 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin^{-1}(x)$ 的例子，有幾件事需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\sin(x)$ 的反函數 $arcsin(x)$ 的指令為 asin。&lt;/li&gt;
&lt;li&gt;函數的範圍為 $-1 &amp;lt; x &amp;lt; 1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(asin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arcsine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-2&#34;&gt;Example 2&lt;/h2&gt;
&lt;p&gt;接著我們看三維圖形的例子。這個例子中我們要畫出三維中的一條曲線&lt;/p&gt;
&lt;p&gt;$$\left(x(t), y(t), z(t)\right) = (t\cos t, t\sin t, t), \quad t\in[0, 8\pi].$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先將 $8\pi$ 切成 N 等分, 間距為 $\Delta t = 8\pi/N$.
&lt;ol&gt;
&lt;li&gt;在 julia 中可使用 unicode 變數名稱, 比如 $\Delta$ 打法是 &lt;code&gt;\Delta&lt;/code&gt; 接著按 tab 鍵, $\pi$ 則是 &lt;code&gt;\Pi&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定義 $n$ 是一個 $(N+1)\times 1$ 的向量，n = [0, 1, 2, &amp;hellip;,N]。&lt;/li&gt;
&lt;li&gt;定義 $t_i$ 是 $\Delta t\times n$&lt;/li&gt;
&lt;li&gt;$x = t_i .*\cos .(ti)$，注意向量相乘以及函數在向量的取值都需要加個&lt;code&gt;.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y 與 z 的值與 x 的值定義方法類似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由 (x,y,z) 的定義方式我們知道它是一個螺旋線，螺旋的半徑從 0 一直增加到 $8 \pi$。角度也是從 0 到 $8 \pi$，所以總共繞了4圈。
在 plot 指令中我們用 marker 選擇圖形的樣式為圓圈(circle)，legend=false 代表不標記圖形。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;;
Δt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;π&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N;
ti &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Δt&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti;
plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_9_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外, 可以用 &lt;code&gt;camera&lt;/code&gt; 這個指令來調整 3D 視角, 裡面數字是角度 (方位角azimuth, 高度角altitude).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false, camera &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_11_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們也可以使用指令 &lt;code&gt;plotd3d&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們設定 linewidth (lw) 等於 2 以及 legend (leg) 等於 false 表示不標記圖形.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot3d(x, y, z, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_13_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3&#34;&gt;Example 3&lt;/h2&gt;
&lt;p&gt;這個例子中，我們將學到怎麼在一個畫好的圖形上再加上另一個圖形。
我們嘗試一個簡單的例子，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一個圖形，x 座標是取整數 1 到 10。y 軸取 0 到 1 之間的亂數，共十個小數。再來，用 plot 指令將第一個圖形畫出。&lt;/li&gt;
&lt;li&gt;第二個圖形，使用相同的 x 座標，函數值 z 取亂數。將第二個函數圖形與第一個圖形重疊，我們需要指令 plot!&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
plot(x,y)
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
plot!(x,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-4&#34;&gt;Example 4&lt;/h2&gt;
&lt;p&gt;在一個圖形中同時畫出兩個函數，除了上述的方法之外我們還可以這麼做： 直接把兩個函數值定義成一個矩陣&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義 x 是整數 1 到 10。&lt;/li&gt;
&lt;li&gt;定義函數值 y 是一個 10*2 的矩陣，矩陣的第一行代表第一個函數的值，而矩陣的第二行代表第二個函數的值。y值的取法為 0 到 1 之間的亂數，為小數。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 plot 將兩個函數值同時畫出，用 title 設定圖形標題，lw=3 設定線段寬度。&lt;/p&gt;
&lt;p&gt;用 label=[&amp;ldquo;Line 1&amp;rdquo; &amp;ldquo;Line 2&amp;rdquo;] 標記函數名稱，須注意順序：
Line 1 會標記 y 的第一個函數值，Line 2 會標記 y 的第二個函數值。&lt;/p&gt;
&lt;p&gt;x 軸的名稱有兩種設定方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 plot 指令中加入：xlabel = &amp;ldquo;My x label&amp;rdquo;。 (xlabel 後面不用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;li&gt;或是在 plot 指令的下一行用 xlabel!(&amp;ldquo;My x label&amp;rdquo;) 加入。(xlabel! 後面要用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-5&#34;&gt;Example 5&lt;/h2&gt;
&lt;p&gt;如果函數取點的方法不同，能不能畫在同一張圖形中呢？
我們看下面的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;y 這個矩陣裡包含兩筆資料，x 的取點都是整數 1 到 10。所以可以用 &amp;ldquo;一個&amp;rdquo; 指令把兩筆資料畫出來。令這張圖叫做 p&lt;/li&gt;
&lt;li&gt;z 這筆資料為 0 到 1 中的 19 個亂數，xx 的取點也是19個在 [1, 10] 的均勻取點。所以我們用 plot! 指令，先畫出 p, 再把 z 這筆資料畫上去。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(x,y)

xx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)
plot!(p,xx,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 利用 &lt;code&gt;plot(x,y,xx,z)&lt;/code&gt; 這樣的指令是行不通的!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 另外，畫圖也可以用 &lt;code&gt;PyPlot&lt;/code&gt; 這個 package，有很多有趣的效果可以用。&lt;/p&gt;
&lt;p&gt;更多範例請見 
&lt;a href=&#34;http://blog.maxkit.com.tw/2019/06/julia-data-visulization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Data Visualization&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-6---曲面&#34;&gt;Example 6 - 曲面&lt;/h2&gt;
&lt;p&gt;這個例子我們示範如何畫曲面 $(x, y, h(x,y))$, where $h(x,y) = exp(-(x^2+y^2))$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我們設定 x 與 y 的範圍 $[-1, 1]$.&lt;/li&gt;
&lt;li&gt;接著我們設定函數 &amp;ldquo;h&amp;rdquo;&lt;/li&gt;
&lt;li&gt;最後, 我們利用指令 &lt;code&gt;surface&lt;/code&gt; 來畫曲面.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
y&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
h(x,y)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
surface(x,y,h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-7-動畫&#34;&gt;Example 7: 動畫&lt;/h2&gt;
&lt;p&gt;如果要將很多圖片合在一起做成動畫也是可以, 以下這個簡單例子將動畫存成一個 gif 檔.&lt;/p&gt;
&lt;p&gt;更多細節請見 
&lt;a href=&#34;https://docs.juliaplots.org/latest/animations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia_plots_animations&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot([sin, cos], zeros(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
anim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Animation()
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;π, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
    push!(p, x, &lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;[sin(x), cos(x)])
    frame(anim)
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
gif(anim, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine_cosine.gif&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 計時</title>
      <link>https://teshenglin.github.io/post/2020_julia_timing/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_timing/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 計算程式執行時間的指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，julia 計算程式運行效能有幾個指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@time&lt;/code&gt; 顯示出程式運行的秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timed&lt;/code&gt; 顯示程式執行回傳值，秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timev&lt;/code&gt; 顯示&lt;code&gt;@time&lt;/code&gt;一樣的資訊，最後顯示程式執行回傳值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@elapsed&lt;/code&gt; 顯示出某程式運行的秒數&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 真正要計算程式效能, 還是推薦用 &lt;code&gt;BenchmarkTools.jl&lt;/code&gt; 這個 package.&lt;/p&gt;
&lt;p&gt;以下範例中我們需要使用兩個 package: &lt;code&gt;LinearAlgebra&lt;/code&gt; 以及 &lt;code&gt;BenchmarkTools&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; BenchmarkTools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;example-1-matrix-matrix-multiplication&#34;&gt;Example 1: Matrix-matrix multiplication&lt;/h2&gt;
&lt;p&gt;我們以矩陣乘法 $C=A\times B$ 為例：$A:n\times p$, $B:p\times m$, $C:n\times m$&lt;/p&gt;
&lt;p&gt;f1 這個函數會產生兩個隨機矩陣 $A$, $B$ 並且將他們相乘:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f1(n, p, m)
   A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
   B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
   C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;m
         &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;p
            C[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; C[i,j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;A[i,k]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;B[k,j]
         &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們先試試看以 julia 既有的計算時間指令來看結果如何&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@time&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.076423 seconds (161.79 k allocations: 8.380 MiB)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;(nothing, 0.000448109, 184496, 0.0, Base.GC_Diff(184496, 1, 0, 5, 2, 0, 0, 0, 0))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timev&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.005932 seconds (8 allocations: 180.172 KiB, 92.28% gc time)
elapsed time (ns): 5931535
gc time (ns):      5473727
bytes allocated:   184496
pool allocs:       5
non-pool GC allocs:2
malloc() calls:    1
GC pauses:         1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@elapsed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;0.000561533
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這些指令的表現如同一開始我們所介紹的, 顯示出程式執行時間以及其他資訊.&lt;/p&gt;
&lt;p&gt;不過一般而言一個程式在第一次跑及之後幾次跑的運行效能會不同, 這是由於初始化的關係. 所以我們通常要跑好幾次來算平均, 已得知一個程式的真正效能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;benchmark&lt;/code&gt; 就提供了這樣的功用, 他會跑好幾次程式, 並且計算最大最小時間.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     437.243 μs (0.00% GC)
  median time:      485.922 μs (0.00% GC)
  mean time:        513.114 μs (3.90% GC)
  maximum time:     44.383 ms (98.89% GC)
  --------------
  samples:          9711
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著我們看一下如果用 &lt;code&gt;LinearAlgebra&lt;/code&gt; 裡的矩陣乘法指令效能如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f2(n, p, m)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
    B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
    C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
    mul!(C,A,B);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f2(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     41.088 μs (0.00% GC)
  median time:      91.270 μs (0.00% GC)
  mean time:        106.954 μs (19.04% GC)
  maximum time:     45.286 ms (99.75% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起來似乎比我們自己寫的 for-loop 效能好一些.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;type-stability&#34;&gt;type-stability&lt;/h2&gt;
&lt;p&gt;julia 語言號稱效能非常好, 不過常常我們自己寫一個 julia 程式發現跑得沒有很快, 這通常是由於所謂的 “型別穩定性 type-stability”. 這樣的問題可以藉由以下幾個 julia 內建的巨集程式來診斷.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_warntype&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_typed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_native&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這方面更深入的說明可見 
&lt;a href=&#34;https://docs.julialang.org/en/v1/manual/performance-tips/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia: performance tips&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-2-vector-2-norm&#34;&gt;Example 2: Vector 2-norm&lt;/h2&gt;
&lt;p&gt;接著我們看一下算向量 2-norm 的效能, 一樣我們比較一下自己寫的以及 call 函數的方式.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t1(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    vec&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.42 KiB
  allocs estimate:  3
  --------------
  minimum time:     423.973 μs (0.00% GC)
  median time:      504.538 μs (0.00% GC)
  mean time:        606.699 μs (9.87% GC)
  maximum time:     47.376 ms (98.43% GC)
  --------------
  samples:          8213
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t2(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    sum(abs2, vec);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t2(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.33 KiB
  allocs estimate:  2
  --------------
  minimum time:     141.160 μs (0.00% GC)
  median time:      195.940 μs (0.00% GC)
  mean time:        335.496 μs (19.51% GC)
  maximum time:     64.500 ms (99.17% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3-solving-linear-system&#34;&gt;Example 3: Solving linear system&lt;/h2&gt;
&lt;p&gt;這裡我們看一下解線性系統, 也就是 matlab 常見的&amp;quot;左除&amp;quot;, 的效率如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; s1(n)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,n);
    b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n);
    A&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;s1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; s1(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  15.28 MiB
  allocs estimate:  8
  --------------
  minimum time:     13.463 ms (0.00% GC)
  median time:      16.817 ms (10.20% GC)
  mean time:        18.148 ms (9.36% GC)
  maximum time:     64.226 ms (77.63% GC)
  --------------
  samples:          276
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>git 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_git/</link>
      <pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_git/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 git 這個分散式版本控制軟體. 有人可能會聽過 &amp;lsquo;github&amp;rsquo;. 不過這邊要提醒一下 git 跟 github 是不一樣的兩件事. 簡單的說 git 是一個軟體, 而 github 則是提供線上 git 服務的公司.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-教學網頁&#34;&gt;git 教學網頁&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我非常推薦 
&lt;a href=&#34;https://gitbook.tw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;為你自己學 Git&lt;/a&gt;, 尤其務必熟讀以下三章, 才算是對 git 有最基本的認識.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;二、Git Windows/Mac/Linux 環境安裝&lt;/li&gt;
&lt;li&gt;四、設定 Git&lt;/li&gt;
&lt;li&gt;五、開始使用 Git&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.slideshare.net/appleboy/introduction-to-git-11436559&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;快速上手 git 版本控制, slideshare&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-基本指令-terminal-終端機&#34;&gt;git 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;做完某個段落後, 將檔案 XXX 移進暫存區&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git add XXX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是將剛剛所有編輯過的檔案一起移
進暫存區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著將暫存區的檔案移至儲存褲 (repo), 並且記註做了什麼事&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;我做了XXX&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;支援-git-的網站&#34;&gt;支援 git 的網站&lt;/h2&gt;
&lt;h3 id=&#34;github&#34;&gt;github&lt;/h3&gt;
&lt;p&gt;如同我最初說的, github 是一個支援 git 的網站, 可以讓你擺放你程式的原始碼, 基本服務是免費的, 有一些更進階的功能則需要付費.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://progressbar.tw/posts/3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;開始使用 GitHub， 註冊與建立repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bitcuket&#34;&gt;bitcuket&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;也可以使用 
&lt;a href=&#34;https://bitbucket.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bitcuket&lt;/a&gt;, 一樣是個讓你把原始碼放上雲端的免費服務.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git---github-基本指令-terminal-終端機&#34;&gt;git &amp;lt;-&amp;gt; github 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;丟上雲端 (github 或 bitbucket)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;從雲端下載最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;簡單工作示意圖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD;
  A[工作資料夾]--&amp;gt;|add| B;
  B(本機 local 暫存區)--&amp;gt;|commit| C;
  D--&amp;gt;|pull| C;
  C(本機 local repo)--&amp;gt;|push| D{雲端 repo};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;git-觀念釐清&#34;&gt;git 觀念釐清&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://goo.gl/gAvBBp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git fetch 與 git pull 的區別&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_julia/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_julia/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 這個程式語言. 這是一個非常新的語言, 在 2009 年才問世, 遠比 1990 年出生的 python 來的年輕許多. 不過由於它又&lt;em&gt;&lt;strong&gt;快&lt;/strong&gt;&lt;/em&gt;又&lt;em&gt;&lt;strong&gt;簡單&lt;/strong&gt;&lt;/em&gt;, 又&lt;em&gt;&lt;strong&gt;不用錢&lt;/strong&gt;&lt;/em&gt;, 使得目前有越來越多人開始使用這個新語言. 相信未來會更加普及.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-安裝&#34;&gt;Julia 安裝&lt;/h2&gt;
&lt;p&gt;在 
&lt;a href=&#34;https://julialang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 官方網站&lt;/a&gt; 上可以下載各系統平台的安裝包裹. 下載安裝後即可運行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Julia 安裝教學影片可參考 
&lt;a href=&#34;https://youtu.be/v7XeveI19CM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia課程環境簡介 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只想試用一下的話可以試試 
&lt;a href=&#34;https://repl.it/languages/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repl.it&lt;/a&gt; 這個線上編輯器. 它可以讓你在線上編輯並執行一些簡單的 julia 程式.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 julia 主程式外, 我也建議加裝 &lt;code&gt;Jupyter notebook&lt;/code&gt;(或 &lt;code&gt;Jupyter lab&lt;/code&gt;) 以及 &lt;code&gt;Atom&lt;/code&gt;. 讓你 coding 更方便.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;julia-基本簡介&#34;&gt;Julia 基本簡介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查詢版本資訊&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; versioninfo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;套件(package)管理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會進入套件管理系統
```julia
pkg&amp;gt;
```

查詢已安裝套件
```julia
pkg&amp;gt; status
```

更新套件
```julia
pkg&amp;gt; update
```

跳出系統請按鍵盤上的 `刪除鍵`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢指令(如matlab中的help)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會變成查詢的視窗
```julia
help?&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jupyter-notebook-安裝&#34;&gt;Jupyter notebook 安裝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Jupyter notebook 是個互動式筆記本, 很容易可以逐行執行並且做到資料視覺化, 並且支援多種主流的直譯語言像是 &lt;code&gt;Julia&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;. 有一說是 jupyter 這個字事實上就是由 julia, python 以及 R 這三個字組合而成.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 有兩種方式. 第一種是直接由 julia 安裝. 步驟如下&lt;/p&gt;
&lt;p&gt;在 julia 輸入 &lt;code&gt;]&lt;/code&gt; 進入套件管理命令提示. 然後會長得像這樣&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著輸入 &lt;code&gt;status&lt;/code&gt; 可以看到現在已經安裝的套件.&lt;/p&gt;
&lt;p&gt;我們要安裝 IJulia, 所以輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; add IJulia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安裝完後要退出套件管理則是 BackSpace 鍵或是 Ctrl+C 都可以.&lt;/p&gt;
&lt;p&gt;要打開 notebook 需要退出套件管理, 並在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; notebook()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter notebook 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/@jamescchuang/%e5%af%a6%e6%88%b0%e5%ae%89%e8%a3%9d%e5%8f%8a%e5%bb%ba%e7%bd%ae-julia-%e9%96%8b%e7%99%bc%e7%92%b0%e5%a2%83-6dc8c0d14c2a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安裝及建置 Julia 開發環境實戰教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前已經有 jupyter notebook 的升級版, 稱為 jupyter lab. 在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; jupyterlab()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter lab 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 的第二種方式則是透過 anaconda. 先裝完 julia 後下載 anaconda 安裝, 即可快樂使用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/datainpoint/jupyter-kernels-3151a6408bab&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打造 Jupyter Notebook 資料科學環境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;在-atom-中操作-julia&#34;&gt;在 Atom 中操作 Julia&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果平常會寫各式程式語言, 可以考慮加安裝 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要在 Atom 裡操作 Julia 簡單說就是要裝以下幾個 package:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;julia-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;language-julia&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uber juno&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就可以用了!!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1550260279.html?fbclid=IwAR3bBrHTvjF3Y5TJrZsElriJfO2fbyoM751XMfjLYOE0TLl31JA3LSpe8KQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Atom 中操作 Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-基本簡介與語法教學&#34;&gt;Julia 基本簡介與語法教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/Introducing_Julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia: wikibook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://learnxinyminutes.com/docs/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Learn X in Y minutes, where X=Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Julia Taiwan發起人杜岳華的 slideshare: 
&lt;a href=&#34;https://www.slideshare.net/ssuserd6984b/coscup-introduction-to-julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://hackmd.io/@7WeiUEuJSBKp7WCRouAWVg/r106dSpkb/%2FIwZgbAHApgnARgMwLQAYAmKxICxQMZpICGGATEjHtgOwwwrRwCsEQA%3D%3D?type=book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 中文官方文件草稿&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;youtube-上的-julia-超新手教學&#34;&gt;Youtube 上的 Julia 超新手教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/JuliaLangTW/julia_tutorials_for_dummy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之一 on github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/zzrctueO6JY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之二 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/W7R5dxGrxlk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之三 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Markdown 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_markdown/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_markdown/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 markdown 這個語言. 它非常簡單易學, 有時我們只是想打個小文件, 就幾頁而已不想要開 latex 或是 word 之類的文字編輯軟體, 這時候就非常適合以 markdown 來編寫. 另外其實越來越多的程式語言也支援 markdown 編寫. 比如這個網頁裡的 post 就都是以 markdown 做的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-安裝&#34;&gt;Markdown 安裝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我自己是使用 mac, 我用的是 
&lt;a href=&#34;https://macdown.uranusjr.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MacDown&lt;/a&gt; 這個軟體.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安裝完 &lt;em&gt;Macdown&lt;/em&gt; 之後需要到 &lt;code&gt;Preference/Rendering&lt;/code&gt; 中標選 &lt;em&gt;tex-like math&lt;/em&gt; 以及他下一行的 &lt;em&gt;use dollar sign as xxxx&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近我用的是 
&lt;a href=&#34;https://typora.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora&lt;/a&gt; 這個軟體, 它支援各作業系統, 不管 mac 或 windows 都可以用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typora 主要特色是他&lt;strong&gt;所見即所得&lt;/strong&gt;, 所以邊寫邊看自己打出來的版面怎樣. 比較乾淨, 不需要將畫面切分成左右兩半一半程式一半預覽. 學起來也很簡單.&lt;/li&gt;
&lt;li&gt;安裝完 &lt;em&gt;Typora&lt;/em&gt; 之後到 &lt;code&gt;Preference/Markdown&lt;/code&gt; 中標選 &lt;em&gt;inline math&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://free.com.tw/typora/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora 免費極簡 Markdown 編輯器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1546144745.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown神器 -Typora使用教程筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果平常會寫各式程式語言, 也可以考慮使用 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己也有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果連安裝都不想的話我推薦 
&lt;a href=&#34;http://hackmd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hackmd&lt;/a&gt; 這個線上編輯器. 這個還能多人共筆編輯, 適合寫作業交作業.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://notes.dosilovic.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown notes&lt;/a&gt; . 它支援線上即時編寫, 可以線上存檔, 也可以下載成 markdown 以及 PDF.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://upmath.me&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;upmath&lt;/a&gt;, 一樣支援線上即時編寫, 可以存成 html 直接幫你產生網頁.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過我要稍微說明一下, 不管使用哪種編輯器, markdown 主要語法都差不多, 只是在輸出上會有一些細微的差異. 這點就要自己使用後才會感受得到差別.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法教學&#34;&gt;Markdown 語法教學&lt;/h2&gt;
&lt;p&gt;以下列舉一些 markdown 教學的線上資源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://commonmark.org/help/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1分鐘學會 Markdown&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://wastemobile.gitbooks.io/gitbook-chinese/content/format/markdown.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Markdown gitbook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://tiida54.github.io/2018/01/03/3%e5%88%86%e9%90%98%e5%ad%b8%e6%9c%83Markdown%e5%b8%b8%e7%94%a8%e8%aa%9e%e6%b3%95/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3分鐘學會 Markdown 常用語法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何使用 Markdown 來撰寫 Docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;markdown 有一個很酷的語法是可以做 diagram, 在 typora 這個編輯器有支援: 
&lt;a href=&#34;https://support.typora.io/Draw-Diagrams-With-Markdown/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Draw Diagrams With Markdown&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不過要稍微注意一下, 不要直接複製貼上介紹網頁裡的 diagram 程式到 typora 裡, 會跑不出來. 正確做法是, 比如說要做以下這個 sequence diagram, 那在 typora 裡打 ```sequence, 然後就會跑出一個框框讓你把程式貼進去. 程式貼入後圖就跑出來了.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我自己所使用的 macdown 也號稱有支援, 不過其實只有某些特別的版本能用而已, 有點可惜.&lt;/p&gt;
&lt;p&gt;如果是用 atom 的話則是要安裝 
&lt;a href=&#34;https://shd101wyy.github.io/markdown-preview-enhanced/#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown-preview-enhanced&lt;/a&gt; 這個 package. 我自己試過, 支援各種 diagram, 非常棒.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法補充&#34;&gt;Markdown 語法補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 markdown 文字間插入空白無法單純使用空白鍵, 在 mac 裡是 option+space, 其他可見 
&lt;a href=&#34;https://stackoverflow.com/a/54174466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Use non-breaking spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 markdown 裡將文字置中只能用 html 語法 
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Centered Text&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;latex-語法教學&#34;&gt;Latex 語法教學&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 一個很重要功能(至少對我而言)就是它支援 $\LaTeX$ 語法. Latex 數學排版系統是科學界中非常重要的一種系統. 它使得研究員在撰寫學術文章時能輕易地做好排版. 尤其是科學文章中常有大量數學符號, 這些符號的編排以及顯示是 Latex 系統一大強項.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果只是要以 Markdown 來寫一些簡單包含數學符號的文章, 還不需要學整個 Latex 系統. 我們只要會一些語法就好. 以下整理一些線上資源供參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://walkccc.github.io/blog/2018/02/17/Techniques/latex-syntax/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LaTeX 語法整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;List of LaTeX mathematical symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.overleaf.com/learn/latex/Integrals,_sums_and_limits&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Integrals, sums and limits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/LaTeX/Mathematics#Matrices_and_arrays&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;matrices and arrays&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有介於兩個 &lt;code&gt;$&lt;/code&gt; 字元之間的內容將會被視為 TeX 數學公式處理。開頭的 &lt;code&gt;$&lt;/code&gt; 右側必須立刻接上任意文字，而結尾 &lt;code&gt;$&lt;/code&gt; 的左側同樣也必須緊挨著文字。如果使用兩個&lt;code&gt;$$&lt;/code&gt;則會將數學公式換行居中. 例如以下 markdown 程式碼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$$\frac{\sin(x)}{x}$$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;顯示為
$$\frac{\sin(x)}{x}$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
