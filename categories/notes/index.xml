<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>notes | Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/categories/notes/</link>
      <atom:link href="https://teshenglin.github.io/categories/notes/index.xml" rel="self" type="application/rss+xml" />
    <description>notes</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 03 Dec 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>notes</title>
      <link>https://teshenglin.github.io/categories/notes/</link>
    </image>
    
    <item>
      <title>Least square method 1</title>
      <link>https://teshenglin.github.io/post/2023_la_least_square_1/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_la_least_square_1/</guid>
      <description>&lt;h1 id=&#34;最小平方法-1&#34;&gt;最小平方法 1&lt;/h1&gt;
&lt;p&gt;給定一個矩陣 $A$ 以及一個向量 $b$, 我們想要找到一個向量 $x$ 使得 $\|Ax - b\|^2$ 最小.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$$
A\in M_{m\times n}, \quad b \in M_{m\times 1}, \quad x\in M_{n\times 1}.
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們定義 $\hat{x}$ 為找到的那個解, 也就是說, 我們要解以下這個問題&lt;/p&gt;
&lt;p&gt;$$
\newcommand{\argmin}{\arg\min}
\tag{1}
\hat{x} = \argmin_{x\in\mathbb{R}^n}\|Ax - b\|^2.
$$&lt;/p&gt;
&lt;h2 id=&#34;1-notations&#34;&gt;1. Notations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$C(A)$: column space of $A$.
$$
C(A) = \{Ax  |  x\in\mathbb{R}^n\}\subseteq\mathbb{R}^m.
$$&lt;/li&gt;
&lt;li&gt;$N(A)$: null space of $A$.
$$
N(A) = \{x\in\mathbb{R}^n | Ax = 0\}\subseteq\mathbb{R}^n.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-最小平方解與投影子空間&#34;&gt;2. 最小平方解與投影子空間&lt;/h2&gt;
&lt;p&gt;要找到最小平方解首先我們做個重要的觀察.&lt;/p&gt;
&lt;p&gt;事實上, 以下三件事是等價敘述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;給定 $A$ 與 $b$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\in\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;將 $b$ 投影到 $C(A)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因為 $A\hat{x}$ 可以視為 $A$ 的 columns 的線性組合. 而任何在 column space $C(A)$ 裡的向量也都可以被寫成 $Ax$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以若我們知道怎樣解其中一個, 另外兩個問題就同時解出來了. 我們先證明以下這個 lemma.&lt;/p&gt;
&lt;h3 id=&#34;lemma&#34;&gt;Lemma&lt;/h3&gt;
&lt;p&gt;任意給定一個向量 $b\in\mathbb{R}^m$, 如果我們能夠找到一個向量 $\hat{b}\in\mathbb{R}^m$ 滿足 $(\hat{b}-b)\perp C(A)$, 那這個向量就會是 $b$ 在 $C(A)$ 的投影向量,
$$
\tag{2}
\hat{b} = \arg\min_{\hat{b}\in\mathbb{R}^m}\|\hat{b}-b\|^2.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pf:&lt;/p&gt;
&lt;p&gt;Let $\hat{b}\in C(A)\subseteq\mathbb{R}^m$ such that $(\hat{b}-b)\perp C(A)$.&lt;/p&gt;
&lt;p&gt;Given $p\in C(A)$, we define $e = p - \hat{b}$ and we have $e\in C(A)$.&lt;/p&gt;
&lt;p&gt;$$
\tag{3}
\begin{align}
\|p - b\|^2 &amp;amp;= &amp;lt;p-b, p-b&amp;gt; \\&lt;br&gt;
&amp;amp;= &amp;lt;\hat{b} + e - b, \hat{b} + e - b&amp;gt;\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2 + 2&amp;lt;\hat{b} - b, e&amp;gt; + \|e\|^2\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2  + \|e\|^2,
\end{align}
$$&lt;/p&gt;
&lt;p&gt;where we have used the fact that $(\hat{b}-b)\perp C(A)$ and $e\in C(A)$, so that $&amp;lt;\hat{b} - b, e&amp;gt;=0$.&lt;/p&gt;
&lt;p&gt;Therefore, for any $p\in C(A)$, $\|p - b\|^2 \ge \|\hat{b} - b\|^2$, and the minimal of $\|p - b\|^2$ occurs when $\|e\|^2=0$, that is when $p=\hat{b}$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由這 lemma 我們知道 $\hat{b}$ 可以從 $(\hat{b}-b)\perp C(A)$ 這個條件下手, 也就是要找一個 $\hat{b}$ 滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{4}
A^T(\hat{b}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;那因為 $\hat{b}\in C(A)$, 一定存在某個 $\hat{x}\in\mathbb{R}^n$ 使得 $A\hat{x}=\hat{b}$. 因此 (4) 就變成&lt;/p&gt;
&lt;p&gt;$$
\tag{5}
A^T(A\hat{x}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;展開就知道 $\hat{x}$ 要滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{6}
A^TA\hat{x}=A^Tb.
$$&lt;/p&gt;
&lt;p&gt;因此, 我們剛剛說的事其解就是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\subseteq\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{x}$ 滿足 $A^TA\hat{x}=A^Tb$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{b}$ 滿足 $(\hat{b}-b)\perp C(A)$, 或是 $A^T(\hat{b}-b)=0$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以上推導都是充分條件, 就是如果我們解出 (4) 或 (6), 那他們就一定是 (1) 的解.&lt;/li&gt;
&lt;li&gt;以上推導跟 $A$ 的 column 有沒有 linearly independent 無關.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-independent-columns&#34;&gt;3. Independent columns&lt;/h2&gt;
&lt;p&gt;如果 $A$ 的 column 是 linearly independent, 那 $A^TA$ 就可逆, 然後我們就可以把 $\hat{x}$ 顯式的寫下來, 就得到
$$
\tag{7}
\hat{x} = (A^TA)^{-1}A^Tb.
$$
在這情況下, $b$ 在 $C(A)$ 的投影也可以寫下來, 就是
$$
\tag{8}
\hat{b} = A(A^TA)^{-1}A^Tb.
$$
或是我們可以更近一步定義投影到 $C(A)$ 的投影矩陣, 就是
$$
\tag{9}
P = A(A^TA)^{-1}A^T.
$$&lt;/p&gt;
&lt;h2 id=&#34;4-independent-columns&#34;&gt;4. Independent columns&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;$A^TA$ 不可逆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;case-1&#34;&gt;Case 1&lt;/h3&gt;
&lt;p&gt;假設 $m&amp;lt;n$ 並且 $\text{rank}(A)=n$.&lt;/p&gt;
&lt;p&gt;在這情況下, $A$ 的 columns 不是 linearly independent, $A^TA$ 不可逆, 並且 $N(A)\ne{0}$. 所以若有一個最小平方解, 那就還會有無窮多個. 不過我們至少先找到一個再說.&lt;/p&gt;
&lt;p&gt;因為 $A$ 的 rows 會線性獨立, 因此我們對 $A^T$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{10}
A^T = QR,
$$
where $Q^TQ= I$, $Q\in M_{n\times m}$ and $R\in M_{m\times m}$. 並且我們知道 $R$ 是可逆矩陣.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{11}
QRR^TQ^T \hat{x} = QRb.
$$&lt;/p&gt;
&lt;p&gt;兩邊同乘 $(R^T)^{-1}R^{-1}Q^T$ 我們得到&lt;/p&gt;
&lt;p&gt;$$
\tag{12}
Q^T \hat{x} = (R^T)^{-1}b.
$$&lt;/p&gt;
&lt;p&gt;最後, 如果我們選擇&lt;/p&gt;
&lt;p&gt;$$
\tag{13}
\hat{x} = Q(R^T)^{-1}b,
$$&lt;/p&gt;
&lt;p&gt;那可以很容易驗證 (12) 是滿足的. 也就是說 (13) 會是這個問題的一個解.&lt;/p&gt;
&lt;h3 id=&#34;case-2&#34;&gt;Case 2&lt;/h3&gt;
&lt;p&gt;假設 $\text{rank}(A)=r$, 並且 $r&amp;lt;m$, $r&amp;lt;n$.&lt;/p&gt;
&lt;p&gt;我們對 $A$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{14}
A = QR,
$$
where $Q^TQ= I$, $Q\in M_{m\times r}$ and $R\in M_{r\times n}$.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{15}
R^TR \hat{x} = R^TQ^Tb.
$$&lt;/p&gt;
&lt;p&gt;不過要注意的是這裡 $R^TR\in M_{n\times n}$ 不是一個可逆矩陣, 所以操作上無法兩邊同乘其反矩陣. 但是好消息是 $R^T$ 的 columns 是線性獨立的, 所以我們會有&lt;/p&gt;
&lt;p&gt;$$
\tag{16}
R \hat{x} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;接著我們試著在 row space 裡找解. 假設 $\hat{x} = R^T \hat{y}$, $\hat{y}\in\mathbb{R}^r$, 那 (16) 可以改寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{17}
RR^T \hat{y} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;這樣, 由於 $RR^T\in M_{r\times r}$ 並且可逆, 我們就有 $\hat{y} = (RR^T)^{-1}Q^Tb$. 最後&lt;/p&gt;
&lt;p&gt;$$
\tag{18}
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;一樣可以很容易驗證 (16) 是滿足的. 也就是說 (18) 會是這個問題的一個解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; QR 的這整套做法也適用於 $A$ 的 columns 線性獨立的情形. 而且在這情形之下的 $R$ 矩陣會是個可逆方陣, 因此有 $(RR^T)^{-1} = (R^T)^{-1}R^{-1}$. 代入之後得到&lt;/p&gt;
&lt;p&gt;$$
\tag{19}
\hat{x} = R^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;h2 id=&#34;5-conclusion&#34;&gt;5. Conclusion&lt;/h2&gt;
&lt;p&gt;我們考慮以下最小平方法問題&lt;/p&gt;
&lt;p&gt;$$
\min_{x\in\mathbb{R}^n}|Ax - b|^2.
$$&lt;/p&gt;
&lt;p&gt;並且我們令最佳解為 $\hat{x}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $A$ 的 columns 線性獨立
$$
\hat{x} = (A^TA)^{-1}A^Tb.
$$
&lt;ul&gt;
&lt;li&gt;如果對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{n\times n}$,
$$
\hat{x} = R^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 $A$ 的 columns 線性相依
&lt;blockquote&gt;
&lt;p&gt;則有無窮多解, 以下是一特解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{r\times r}$,
$$
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;li&gt;或是若 $\text{rank}(A)=n$, 則可對 $A^T$ 做 (reduced) QR, $A^T=QR$, 並且 $Q^TQ=I_{m\times m}$,
$$
\hat{x} = Q(R^T)^{-1}b.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Least square method 1</title>
      <link>https://teshenglin.github.io/post/2023_la_least_square_1/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_la_least_square_1/</guid>
      <description>&lt;h1 id=&#34;最小平方法-1&#34;&gt;最小平方法 1&lt;/h1&gt;
&lt;p&gt;給定一個矩陣 $A$ 以及一個向量 $b$, 我們想要找到一個向量 $x$ 使得 $\|Ax - b\|^2$ 最小.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$$
A\in M_{m\times n}, \quad b \in M_{m\times 1}, \quad x\in M_{m\times 1}.
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們定義 $\hat{x}$ 為找到的那個解, 也就是說, 我們要解以下這個問題&lt;/p&gt;
&lt;p&gt;$$
\newcommand{\argmin}{\arg\min}
\tag{1}
\hat{x} = \argmin_{x\in\mathbb{R}^n}\|Ax - b\|^2.
$$&lt;/p&gt;
&lt;h2 id=&#34;1-notations&#34;&gt;1. Notations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$C(A)$: column space of $A$.
$$
C(A) = \{Ax  |  x\in\mathbb{R}^n\}\subseteq\mathbb{R}^m.
$$&lt;/li&gt;
&lt;li&gt;$N(A)$: null space of $A$.
$$
N(A) = \{x\in\mathbb{R}^n | Ax = 0\}\subseteq\mathbb{R}^n.
$$&lt;/li&gt;
&lt;li&gt;Reduced QR for $A$.
$$
A = QR, \quad Q^TQ = I,
$$
但是 $Q$ 不是個方陣, $N(R^T)=\{0\}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-最小平方解與投影子空間&#34;&gt;2. 最小平方解與投影子空間&lt;/h2&gt;
&lt;p&gt;要找到最小平方解首先我們做個重要的觀察.&lt;/p&gt;
&lt;p&gt;事實上, 以下三件事是等價敘述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;給定 $A$ 與 $b$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\in\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;將 $b$ 投影到 $C(A)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因為 $A\hat{x}$ 可以視為 $A$ 的 columns 的線性組合. 而任何在 column space $C(A)$ 裡的向量也都可以被寫成 $Ax$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以若我們知道怎樣解其中一個, 另外兩個問題就同時解出來了. 我們先證明以下這個 lemma.&lt;/p&gt;
&lt;h3 id=&#34;lemma&#34;&gt;Lemma&lt;/h3&gt;
&lt;p&gt;任意給定一個向量 $b\in\mathbb{R}^m$, 如果我們能夠找到一個向量 $\hat{b}\in\mathbb{R}^m$ 滿足 $(\hat{b}-b)\perp C(A)$, 那這個向量就會是 $b$ 在 $C(A)$ 的投影向量,
$$
\tag{2}
\hat{b} = \arg\min_{\hat{b}\in\mathbb{R}^m}\|\hat{b}-b\|^2.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pf:&lt;/p&gt;
&lt;p&gt;Let $\hat{b}\in C(A)\subseteq\mathbb{R}^m$ such that $(\hat{b}-b)\perp C(A)$.&lt;/p&gt;
&lt;p&gt;Given $p\in C(A)$, we define $e = p - \hat{b}$ and we have $e\in C(A)$.&lt;/p&gt;
&lt;p&gt;$$
\tag{3}
\begin{align}
\|p - b\|^2 &amp;amp;= &amp;lt;p-b, p-b&amp;gt; \\&lt;br&gt;
&amp;amp;= &amp;lt;\hat{b} + e - b, \hat{b} + e - b&amp;gt;\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2 + 2&amp;lt;\hat{b} - b, e&amp;gt; + \|e\|^2\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2  + \|e\|^2,
\end{align}
$$&lt;/p&gt;
&lt;p&gt;where we have used the fact that $(\hat{b}-b)\perp C(A)$ and $e\in C(A)$, so that $&amp;lt;\hat{b} - b, e&amp;gt;=0$.&lt;/p&gt;
&lt;p&gt;Therefore, for any $p\in C(A)$, $\|p - b\|^2 \ge \|\hat{b} - b\|^2$, and the minimal of $\|p - b\|^2$ occurs when $\|e\|^2=0$, that is when $p=\hat{b}$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由這 lemma 我們知道 $\hat{b}$ 可以從 $(\hat{b}-b)\perp C(A)$ 這個條件下手, 也就是要找一個 $\hat{b}$ 滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{4}
A^T(\hat{b}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;那因為 $\hat{b}\in C(A)$, 一定存在某個 $\hat{x}\in\mathbb{R}^n$ 使得 $A\hat{x}=\hat{b}$. 因此 (4) 就變成&lt;/p&gt;
&lt;p&gt;$$
\tag{5}
A^T(A\hat{x}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;展開就知道 $\hat{x}$ 要滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{6}
A^TA\hat{x}=A^Tb.
$$&lt;/p&gt;
&lt;p&gt;因此, 我們剛剛說的事其解就是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\subseteq\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{x}$ 滿足 $A^TA\hat{x}=A^Tb$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{b}$ 滿足 $(\hat{b}-b)\perp C(A)$, 或是 $A^T(\hat{b}-b)=0$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以上推導都是充分條件, 就是如果我們解出 (4) 或 (6), 那他們就一定是 (1) 的解.&lt;/li&gt;
&lt;li&gt;以上推導跟 $A$ 的 column 有沒有 linearly independent 無關.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-independent-columns&#34;&gt;3. Independent columns&lt;/h2&gt;
&lt;p&gt;如果 $A$ 的 column 是 linearly independent, 那 $A^TA$ 就可逆, 然後我們就可以把 $\hat{x}$ 顯式的寫下來, 就得到
$$
\tag{7}
\hat{x} = (A^TA)^{-1}A^Tb.
$$
在這情況下, $b$ 在 $C(A)$ 的投影也可以寫下來, 就是
$$
\tag{8}
\hat{b} = A(A^TA)^{-1}A^Tb.
$$
或是我們可以更近一步定義投影到 $C(A)$ 的投影矩陣, 就是
$$
\tag{9}
P = A(A^TA)^{-1}A^T.
$$&lt;/p&gt;
&lt;h2 id=&#34;4-dependent-columns&#34;&gt;4. Dependent columns&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;$A^TA$ 不可逆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;case-1&#34;&gt;Case 1&lt;/h3&gt;
&lt;p&gt;假設 $m&amp;lt;n$ 並且 $\text{rank}(A)=n$.&lt;/p&gt;
&lt;p&gt;在這情況下, $A$ 的 columns 不是 linearly independent, $A^TA$ 不可逆, 並且 $N(A)\ne{0}$. 所以若有一個最小平方解, 那就還會有無窮多個. 不過我們至少先找到一個再說.&lt;/p&gt;
&lt;p&gt;因為 $A$ 的 rows 會線性獨立, 因此我們對 $A^T$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{10}
A^T = QR,
$$
where $Q^TQ= I$, $Q\in M_{n\times m}$ and $R\in M_{m\times m}$. 並且我們知道 $R$ 是可逆矩陣.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{11}
QRR^TQ^T \hat{x} = QRb.
$$&lt;/p&gt;
&lt;p&gt;兩邊同乘 $(R^T)^{-1}R^{-1}Q^T$ 我們得到&lt;/p&gt;
&lt;p&gt;$$
\tag{12}
Q^T \hat{x} = (R^T)^{-1}b.
$$&lt;/p&gt;
&lt;p&gt;最後, 如果我們選擇&lt;/p&gt;
&lt;p&gt;$$
\tag{13}
\hat{x} = Q(R^T)^{-1}b,
$$&lt;/p&gt;
&lt;p&gt;那可以很容易驗證 (12) 是滿足的. 也就是說 (13) 會是這個問題的一個解.&lt;/p&gt;
&lt;h3 id=&#34;case-2&#34;&gt;Case 2&lt;/h3&gt;
&lt;p&gt;假設 $\text{rank}(A)=r$, 並且 $r&amp;lt;m$, $r&amp;lt;n$.&lt;/p&gt;
&lt;p&gt;我們對 $A$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{14}
A = QR,
$$
where $Q^TQ= I$, $Q\in M_{m\times r}$ and $R\in M_{r\times n}$.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{15}
R^TR \hat{x} = R^TQ^Tb.
$$&lt;/p&gt;
&lt;p&gt;不過要注意的是這裡 $R^TR\in M_{n\times n}$ 不是一個可逆矩陣, 所以操作上無法兩邊同乘其反矩陣. 但是好消息是 $R^T$ 的 columns 是線性獨立的, 所以我們會有&lt;/p&gt;
&lt;p&gt;$$
\tag{16}
R \hat{x} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;接著我們試著在 row space 裡找解. 假設 $\hat{x} = R^T \hat{y}$, $\hat{y}\in\mathbb{R}^r$, 那 (16) 可以改寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{17}
RR^T \hat{y} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;這樣, 由於 $RR^T\in M_{r\times r}$ 並且可逆, 我們就有 $\hat{y} = (RR^T)^{-1}Q^Tb$. 最後&lt;/p&gt;
&lt;p&gt;$$
\tag{18}
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;一樣可以很容易驗證 (16) 是滿足的. 也就是說 (18) 會是這個問題的一個解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; QR 的這整套做法也適用於 $A$ 的 columns 線性獨立的情形. 而且在這情形之下的 $R$ 矩陣會是個可逆方陣, 因此有 $(RR^T)^{-1} = (R^T)^{-1}R^{-1}$. 代入之後得到&lt;/p&gt;
&lt;p&gt;$$
\tag{19}
\hat{x} = R^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;h2 id=&#34;5-conclusion&#34;&gt;5. Conclusion&lt;/h2&gt;
&lt;p&gt;我們考慮以下最小平方法問題&lt;/p&gt;
&lt;p&gt;$$
\min_{x\in\mathbb{R}^n}|Ax - b|^2.
$$&lt;/p&gt;
&lt;p&gt;並且我們令最佳解為 $\hat{x}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $A$ 的 columns 線性獨立
$$
\hat{x} = (A^TA)^{-1}A^Tb.
$$
&lt;ul&gt;
&lt;li&gt;如果對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{n\times n}$,
$$
\hat{x} = R^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 $A$ 的 columns 線性相依
&lt;blockquote&gt;
&lt;p&gt;則有無窮多解, 以下是一特解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{r\times r}$,
$$
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;li&gt;或是若 $\text{rank}(A)=n$, 則可對 $A^T$ 做 (reduced) QR, $A^T=QR$, 並且 $Q^TQ=I_{m\times m}$,
$$
\hat{x} = Q(R^T)^{-1}b.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Trace, determinant 與 eigenvalue 的關係</title>
      <link>https://teshenglin.github.io/post/2023_la_det_trace_zh/</link>
      <pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_la_det_trace_zh/</guid>
      <description>&lt;h2 id=&#34;方陣-a-的行列式等於其特徵值相乘&#34;&gt;方陣 A 的行列式等於其特徵值相乘&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Determinant of A equals to the product of its eigenvalues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定一個 $n\times n$ 的方陣 $A$, 我們定義一個變數為 $\lambda$ 的函數 $P(\lambda)$ 如下:
$$
\tag{1}
P(\lambda) = det(\lambda I-A).
$$
根據行列式的算法我們馬上知道 $P$ 其實就是個 $\lambda$ 的 $n$ 次多項式, 可以寫成
$$
\tag{2}
P(\lambda) = \lambda^n + c_{n-1}\lambda^{n-1}\cdots + c_1\lambda + c_0.
$$
因此這個多項式必有 $n$ 個根 $\lambda_1, \cdots, \lambda_n$ (有可能是實根, 虛根, 或重根, 不過必有 $n$ 個), 所以我們可以將 $P$ 改寫為
$$
\tag{3}
P(\lambda) = (\lambda - \lambda_1)\cdots (\lambda - \lambda_n).
$$&lt;/p&gt;
&lt;p&gt;最後, 我們算一下 $P(0)$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 (1)
$$
\tag{4}
P(0) = det(-A) = (-1)^n det(A).
$$&lt;/li&gt;
&lt;li&gt;由 (3)
$$
\tag{5}
P(0) = (- \lambda_1)\cdots (- \lambda_n) = (-1)^n\lambda_1\cdots\lambda_n.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此, 由 (4) 以及 (5),
$$
det(A) = \lambda_1\cdots\lambda_n.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;方陣-a-的跡httpszhwikipediaorgzh-tw跡等於其特徵值相加&#34;&gt;方陣 A 的
&lt;a href=&#34;https://zh.wikipedia.org/zh-tw/%e8%b7%a1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跡&lt;/a&gt;等於其特徵值相加&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Trace of A equals to the sum of its eigenvalues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定一個 $n\times n$ 的方陣 $A$:
$$
\tag{6}
A = \begin{bmatrix}
a_{11} &amp;amp; \cdots &amp;amp; a_{1n}\\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
a_{n1} &amp;amp; \cdots &amp;amp; a_{nn}
\end{bmatrix}.
$$&lt;/p&gt;
&lt;p&gt;因此我們有
$$
\tag{7}
\lambda I - A =
\begin{bmatrix}
\lambda - a_{11} &amp;amp; -a_{12} &amp;amp; \cdots &amp;amp; -a_{1n} \\&lt;br&gt;
-a_{21} &amp;amp; \lambda-a_{22} &amp;amp; \cdots &amp;amp; -a_{2n} \\&lt;br&gt;
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;
-a_{n1} &amp;amp; -a_{n2} &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}.
$$&lt;/p&gt;
&lt;p&gt;接著我們來算 $det(\lambda I - A)$. 我們直接沿著第一行使用降階法 (
&lt;a href=&#34;https://en.wikipedia.org/wiki/Laplace_expansion&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cofactor expansion&lt;/a&gt;):
$$
\tag{8}
det(\lambda I - A) =
(\lambda - a_{11})C_{11} +(- a_{21}) C_{21}+ \cdots,
$$
其中
$$
\tag{9}
C_{11} =
\begin{bmatrix}
\lambda-a_{22} &amp;amp; \cdots &amp;amp; -a_{2n}\\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
-a_{n2} &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}_{(n-1)\times(n-1)},
$$
以及
$$
\tag{10}
C_{21} =
\begin{bmatrix}
-a_{12} &amp;amp; -a_{13} &amp;amp; \cdots &amp;amp; -a_{1n}\\&lt;br&gt;
-a_{32} &amp;amp; \lambda-a_{33} &amp;amp; \cdots &amp;amp; -a_{3n}\\&lt;br&gt;
\vdots &amp;amp;  \vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
-a_{n2} &amp;amp; \cdots &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}_{(n-1)\times(n-1)}.
$$&lt;/p&gt;
&lt;p&gt;簡單觀察可以發現 $C_{21}$ 是個最多 $n-2$ 次的多項式. 並且對所有 $k&amp;gt;1$ 的 $C_{k1}$, 他們全都是最多 $n-2$ 次的多項式. 因此我們就有
$$
\tag{11}
det(\lambda I - A) = (\lambda - a_{11})C_{11} + \hat{Q}_{n-2}(\lambda),
$$
其中 $\hat{Q}_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;接著我們對 $C_{11}$ 做展開, 並且用以上的論述一直做下去. 最終我們就會得到
$$
\tag{12}
det(\lambda I - A) = (\lambda - a_{11})(\lambda - a_{22})\cdots (\lambda - a_{nn}) + \tilde{Q}_{n-2}(\lambda),
$$
其中 $\tilde{Q}_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;我們接著把 (12) 展開, 得到
$$
\tag{13}
det(\lambda I - A) = \lambda^n - (a_{11} + a_{22} + \cdots + a_{nn})\lambda^{n-1}  + Q_{n-2}(\lambda),
$$
其中 $Q_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;另一方面, 我們也可以同樣把 (3) 展開, 得到
$$
\tag{14}
P(\lambda) = \lambda^n - (\lambda_1 + \lambda_2 + \cdots + \lambda_n)\lambda^{n-1}  + \cdots.
$$
因此, 由 (13) 以及 (14),
$$
a_{11} + a_{22} + \cdots + a_{nn} = \lambda_1 + \lambda_2 + \cdots + \lambda_n.
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Power method with Rayleigh Quotient</title>
      <link>https://teshenglin.github.io/post/2023_power_method_3/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_3/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;假設&#34;&gt;假設&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;$A$ 是一個對稱矩陣&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;演算法-power-method-with-rayleigh-quotient&#34;&gt;演算法: Power method with Rayleigh Quotient&lt;/h2&gt;
&lt;p&gt;Iterate until convergence:
$$
\tag{1}
\begin{align}
\hat{x}^{(k+1)} &amp;amp;= Ax^{(k)}\\&lt;br&gt;
\lambda^{(k+1)} &amp;amp;= x^{(k)T}\hat{x}^{(k+1)}\\&lt;br&gt;
x^{(k+1)} &amp;amp;= \hat{x}^{(k+1)}/|\hat{x}^{(k+1)}|_2
\end{align}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;收斂性證明&#34;&gt;收斂性證明&lt;/h2&gt;
&lt;p&gt;由於 $A$ 是個對稱矩陣, 因此存在一組 orthonormal 的 eigenvectors $\{v_1, \cdots, v_n\}$, 使得 $v_i^Tv_j=0$ if $i\ne j$, and $v_i^Tv_i=0$.&lt;/p&gt;
&lt;p&gt;任意給定初始值 $x^{(0)}\ne 0$, 他可以被 eigenvectors 組出來, 因此我們有
$$
x^{(0)} = \alpha_1 v_1 + \sum^n_{i=2} \alpha_i v_i,
$$
並且
$$
\tag{2}A^kx^{(0)} = \lambda_1^k\left[\alpha_1 v_1 + \sum^n_{i=2} \alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right].
$$
另一方面, 從迭代式 (1) 可以看出我們一直不斷地把得到的向量 normalize, 使其為單位長, 因此我們必定有
$$
x^{(k)} = \frac{A^kx^{(0)}}{|A^kx^{(0)}|_2}.
$$
將 (2) 代入得到
$$
\tag{3}
\begin{align}
x^{(k)}
&amp;amp;= \frac{\lambda_1^k\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{\lambda_1^{2k}\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}} \\&lt;br&gt;
&amp;amp;= \frac{\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{\alpha^2_1 + \sum^n_{i=2}\alpha^2_i \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}}}\\&lt;br&gt;
&amp;amp;=\frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}}},
\end{align}
$$
其中我們用到了 $\{v_1, \cdots, v_n\}$ 是 orthonormal basis 這個事實.&lt;/p&gt;
&lt;p&gt;接著我們可以算 eigenvalue, 將 (3) 代入:
$$
\begin{align}
\lambda^{(k+1)} &amp;amp;= x^{(k)T}\hat{x}^{(k+1)} = x^{(k)T}(Ax^{(k)}) \\&lt;br&gt;
&amp;amp;= \frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[\lambda_1v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \lambda_i\left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^{k+1}v_i\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k+1}\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[1 + O \left(\epsilon^{2k+1}\right)\right]}{1 + O \left(\epsilon^{2k}\right)} \\&lt;br&gt;
&amp;amp;= \lambda_1 + O\left(\epsilon^{2k}\right),
\end{align}
$$
where $\epsilon=|\lambda_2/\lambda_1|$.&lt;/p&gt;
&lt;p&gt;因此這個迭代式, &lt;strong&gt;power method with Rayleigh quotient for symmetric matrix&lt;/strong&gt;, 會是線性收斂, 並且其 rate of convergence 是 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;final-remark&#34;&gt;Final remark&lt;/h2&gt;
&lt;p&gt;若使用基本的 power 迭代, 就是每次將得到得向量單位化, 如以下方式:&lt;/p&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while diff &amp;gt; Tol
    v = A*u
    lambda = norm(v)
    u = v/lambda
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 $A$ 是個對稱矩陣, 會發現這個迭代式其收斂性為 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;p&gt;這是因爲, 若 $Au=\lambda u$,
$$
\|v\|_2 = \|Au\|_2 = \sqrt{(Au)^T(Au)} = |\lambda|.
$$
利用跟上面類似的推導手法即可證明收斂性為 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Power method - deflation</title>
      <link>https://teshenglin.github.io/post/2023_power_method_2/</link>
      <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_2/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;deflation&#34;&gt;Deflation&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;對一方陣 $A$, 假設我們以 power iteration 找到了一組 eigenvalue/eigenvector, $\lambda$ and $v$, 使得 $Av = \lambda v$. 那要怎麼找下一組呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-matrix-tranformation&#34;&gt;1. Matrix tranformation&lt;/h2&gt;
&lt;p&gt;假設能找到一個向量 $x$ 使 $x^T v = 1$, 則我們定義
$$
\tag{1} B = A - \lambda v x^T,
$$
並且以 $B$ 來找 eigenvalue/eigenvector. 那 $A$ 與 $B$ 之間有什麼關係呢?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$B$ 的一組 eigenvalue/eigenvector 為 $0$ 與 $v$, 滿足 $Bv = 0v$.&lt;/li&gt;
&lt;li&gt;$B$ 其他所有的 eigenvalues 都跟 $A$ 一樣.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pf-of-1&#34;&gt;pf of 1:&lt;/h3&gt;
&lt;p&gt;$$
Bv = (A - \lambda v x^T)v = Av - \lambda v (x^Tv) = Av - \lambda v=0.
$$&lt;/p&gt;
&lt;h3 id=&#34;pf-of-2&#34;&gt;pf of 2:&lt;/h3&gt;
&lt;p&gt;假設 $w$ 是 $A$ 的 left-eigenvector, 其 eigenvalue 為 $\lambda_2\ne \lambda$, 滿足 $w^TA = \lambda_2w^T$, 則我們知道 $w^Tv=0$, 並且
$$
w^TB = w^T(A - \lambda v x^T) = w^TA - \lambda (w^Tv)x^T = w^TA = \lambda_2w^T.
$$
因此 $\lambda_2$ 亦為 $B$ 的 eigenvalue.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;所以我們會利用找 $B$ 的 eigenvalue 來找 $A$ 的 eigenvalue.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;那假設我們找到 $B$ 的 eigenvalue 跟 eigenvector 了, 稱之為 $\lambda_2$ 以及 $u_2$, 那我們知道 $\lambda_2$ 也是 $A$ 的 eigenvalue, 不過其相對應的 eigenvector 是誰呢?&lt;/p&gt;
&lt;p&gt;若 $B$ 有 eigenvalues $0,\lambda_2, \cdots, \lambda_n$ 以及 eigenvectors $v, u_2, u_3, \cdots, u_n$, 則
$$
\tag{2} v_i = (\lambda_i-\lambda) u_i + \lambda (x^T u_i) v, \quad i=2,\cdots, n,
$$
並且 $Av_i = \lambda_i v_i$.&lt;/p&gt;
&lt;h3 id=&#34;pf&#34;&gt;pf&lt;/h3&gt;
&lt;p&gt;因為 $u_i$ 是 $B$ 的 eigenvector, 所以
$$
\lambda_i u_i = Bu_i = (A - \lambda v x^T)u_i = Au_i - \lambda(x^Tu_i)v.
$$
因此
$$
Au_i = \lambda_i u_i +\lambda(x^Tu_i)v.
$$
那麼
$$
\begin{align}
Av_i &amp;amp;= (\lambda_i-\lambda) Au_i + \lambda (x^T u_i) Av \\&lt;br&gt;
&amp;amp;= (\lambda_i-\lambda)(\lambda_i u_i +\lambda(x^Tu_i)v) + \lambda^2 (x^T u_i) v\\&lt;br&gt;
&amp;amp;= \lambda_i((\lambda_i-\lambda) u_i + \lambda (x^T u_i) v) \\&lt;br&gt;
&amp;amp;=\lambda_i v_i.
\end{align}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 對 (1) 做 power iteration 可以找出下一個 eigenvalue, 並且利用 (2) 可以得到其 eigenvector.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;接下來我們介紹兩種 &lt;em&gt;&lt;strong&gt;看起來似乎可以使用&lt;/strong&gt;&lt;/em&gt; 的 deflation 作法.
不過實際使用起來有一些問題!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-eigen-decomposition&#34;&gt;2. Eigen-decomposition&lt;/h2&gt;
&lt;p&gt;對一個方陣, 如果我們可以找到所有的 eigenvalues 跟 eigenvectors, 並且有以下關係
$$
A V = V\Lambda  \quad \longleftrightarrow \quad A = V\Lambda V^{-1}
$$
並且我們將 $V$, $\Lambda$, $V^{-1}$ 記為
$$
V = [v_1, v_2, \cdots, v_n], \quad \Lambda = \text{diag}\{\lambda_1, \lambda_2, \cdots, \lambda_n\},\quad
V^{-1} = \begin{bmatrix}
w^T_1 \\ w^T_2 \\ \vdots \\ w^T_n\end{bmatrix}.
$$
則
$$
A = \lambda_1 v^1w^T_1 + \lambda_2 v^2w^T_2 + \cdots + \lambda_n v^nw^T_n.
$$&lt;/p&gt;
&lt;p&gt;有趣的是, 若我們定義
$$
\tag{3} B = A-\lambda_1 v^1w^T_1,
$$
則可以很輕易地看出 $B$ 的 eigenvectors 與 $A$ 的完全一樣, 而 eigenvalues 也幾乎完全一樣, 只有 $\lambda_1$ 被移到 $0$ 去了.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 若我們知道一個 eigenvalue, 以及其相對應的 left and right eigenvectors, 則可以用 (3) 來做 power iteration 找出下一個 eigenvalue, 並且它的 eigenvector 就會是 $A$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過實務上 left eigenvector 比較難找, 需要先找出 linear operator 的 adjoint operator (也就是 $A^T$) 才有辦法做矩陣-向量乘法, 因此這個方法除了對稱的情況外幾乎不會被使用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 當 $A$ 是 symmetric, 則可以選擇 $v_i$ 使得 $w_i = v_i$, 在這時候我們就可以輕易地使用 (3) 來找下一組了.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-annihilation&#34;&gt;3. Annihilation&lt;/h2&gt;
&lt;p&gt;給定 $A$ 為一個 $n\times n$ 方陣. 我們做以下兩個假設&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的 eigenvalues 滿足
$$
|\lambda_1| &amp;gt; |\lambda_2| &amp;gt; |\lambda_3| \cdots |\lambda_n|.
$$&lt;/li&gt;
&lt;li&gt;相對應的 eigenvectors, $\{v_1, v_2, \cdots, v_n\}$, 會構成 $R^n$ 的一組基底.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;observation&#34;&gt;Observation&lt;/h4&gt;
&lt;p&gt;如果初始向量我們選擇 $y$ 使得
$$
\tag{4} y = \sum_{i=2}^n c_iv_i,
$$
也就是沒有 $v_1$ 的分量, 則 power iteration 會找到 $\lambda_2$ 以及 $v_2$.&lt;/p&gt;
&lt;p&gt;當然, 任意給一個向量並無法滿足 (4) 這個條件, 不過若我們定義
$$
\tag{5} y = A x - \lambda_1 x,
$$
則對任意一個向量 $x$, 這個 $y$ 就會滿足 (4).&lt;/p&gt;
&lt;h3 id=&#34;pf-1&#34;&gt;pf&lt;/h3&gt;
&lt;p&gt;Let $x = \sum^{n}_{i=1} c_iv_i$, then&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
y &amp;amp;= A x - \lambda_1 x \\&lt;br&gt;
&amp;amp;= \sum^n_{i=1} (c_iAv_i - c_i\lambda_1v_i) \\&lt;br&gt;
&amp;amp;= \sum^n_{i=2} c_i(\lambda_i-\lambda_1)v_i.
\end{aligned}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 若我們知道一個 eigenvalue, 則可以任取一個向量 $x$ 再用 (5) 來做出 power iteration 的初始值, 這樣就可以找出下一個 eigenvalue, 並且它的 eigenvector 就會是 $A$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過實際在做的時候, 由於 $\lambda_1$ 有數值誤差, 因此 (5) 並不會完全滿足 (4), 在設計 power iteration 的時候要小心這件事.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Conjugate gradient method - iterative method</title>
      <link>https://teshenglin.github.io/post/2023_conjugate_gradient_method_2/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_conjugate_gradient_method_2/</guid>
      <description>&lt;p&gt;共軛梯度法 (CG method,  conjugate gradient method) 目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_1&#34;&gt;CG method - Direct mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;直接法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;CG method - iterate mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;For solving $Ax=b$, where $A$ is a square symmetric positive definite matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h2&gt;
&lt;p&gt;$A\in M_{n\times n}$ is a symmetric positive definite matrix.&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A-orthogonal (A-conjugate)
假設有兩個向量 $u_1$ 跟 $u_2$ 皆非 $0$ 且 $u_1 \neq u_2$，若這兩個向量滿足
$$
\langle{u_1},A{u_2}\rangle = {u_1}^TA{u_2} = 0,
$$
則稱之為 A-orthogonal (或 A-conjugate).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt; We can define
$$
\langle{u_1}, {u_2}\rangle_A = \langle{u_1},A{u_2}\rangle= \langle A{u_1},{u_2}\rangle,
$$
then $\langle \cdot\rangle_A$ is an inner product.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-an-iterative-method-first-attempt&#34;&gt;CG as an iterative method: First attempt&lt;/h2&gt;
&lt;h3 id=&#34;theorem-1&#34;&gt;Theorem 1:&lt;/h3&gt;
&lt;p&gt;假設對一個矩陣 A，我們可以找到一組 A-orthogonal set ${u_0, \ldots, u_{n-1}}$. 則給定一個初始值 $x_0$, 我們可定義一個迭代法: For $0\le i\le n-1$,
$$
\tag{1} x_{i+1}=x_i+t_{i}u_{i}, \quad
t_{i}=\frac{\langle b-Ax_i,u_{i}\rangle}{\langle u_i,Au_{i}\rangle}.
$$
並且我們可以證明以下兩件事&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義第 $k$ 步的 residual, $r_k = b-Ax_k$, 我們有 $\langle r_k, u_{j}\rangle=0$, for $0\le j&amp;lt; k\le n$.&lt;/li&gt;
&lt;li&gt;$Ax_n=b$, 也就是第 $n$ 次迭代保證得到解.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pf-of-1&#34;&gt;pf of 1:&lt;/h4&gt;
&lt;p&gt;首先我們可以推 residual 的迭代式
$$
\tag{2} \begin{align}
r_{k+1} &amp;amp;= b - Ax_{k+1} \\
&amp;amp;= b - A(x_k + t_ku_k) \\&lt;br&gt;
&amp;amp;= (b-Ax_k)  - t_kAu_k \\&lt;br&gt;
&amp;amp;= r_k  - t_kAu_k.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;接著, for $0\le j&amp;lt;k-1$, 由於 $u_{k-1}$ 與 $u_j$ 是 A-orthogonal, 因此
$$
\begin{align}
\langle r_{k}, u_{j}\rangle
&amp;amp;= \langle r_{k-1}, u_{j}\rangle-t_{k-1}\langle Au_{k-1}, u_{j}\rangle \\&lt;br&gt;
&amp;amp;= \langle r_{k-1}, u_{j}\rangle.
\end{align}
$$
同樣的理由可以一直使用得到
$$
\langle r_{k}, u_{j}\rangle
= \langle r_{k-1}, u_{j}\rangle
=\cdots
= \langle r_{j+1}, u_{j}\rangle.
$$&lt;/p&gt;
&lt;p&gt;此外, 若 $j=k-1$, 則我們直接有 $\langle r_{k}, u_{j}\rangle  = \langle r_{j+1}, u_j\rangle$.&lt;/p&gt;
&lt;p&gt;接著再用 (2) 一次, 並且用 (1) 裡 $t_j$ 的定義我們得到&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\langle r_{j+1}, u_j\rangle
&amp;amp;= \langle r_j, u_j\rangle-t_j\langle Au_j, u_j\rangle \\
&amp;amp;= \langle r_j, u_j\rangle-\frac{\langle r_j,u_j\rangle}{\langle u_j,Au_j\rangle}\langle Au_j, u_j\rangle\\&lt;br&gt;
&amp;amp;=0.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;因此, for $0\le j&amp;lt;k$, 我們有
$$
\langle r_{k}, u_{j}\rangle =0.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf-of-2&#34;&gt;pf of 2:&lt;/h4&gt;
&lt;p&gt;根據 1 我們有 $\langle r_n, u_{j}\rangle=0$ for $0\le j&amp;lt; n-1$, 也就是
$$
\langle b - Ax_n, u_{j}\rangle=0, \quad 0\le j&amp;lt; n-1.
$$
因為 $\{u_i\}^{n-1}_{i=0}$ span $\mathbb{R}^n$, 所以 $b - Ax_n$ 必為一個零向量, 也就是說 $Ax_n=b$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gram-schimidt-process-to-find-a-orthogonal-set&#34;&gt;Gram-Schimidt process to find A-orthogonal set&lt;/h2&gt;
&lt;p&gt;不過這方法建立在一個重要假設之下, 就是一開始我們可以找到一組 A-orthogonal set $\{u_0, \ldots, u_{n-1}\}$. 不過在實際解問題是這顯然是不容易做到的, 因此我們會需要一步一步地將 $u_i$ 求出來.&lt;/p&gt;
&lt;p&gt;這裡我們可以利用兩件事&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The residual vector $r_k = b - Ax_k$.
&lt;ul&gt;
&lt;li&gt;每次迭代都會產生出一組新的 residual vector, 並且我們知道 residual 是下降最快的方向, 因此我們可以將下個搜尋方向設為 $r_k$, 只不過這並不滿足 A-orthogonal 的條件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gram-Schimidt process
&lt;ul&gt;
&lt;li&gt;線性代數裡告訴我們, 可以用 Gram-Schimidt process 將一組向量正交化. 因此我們就利用這方法來造出一組 A-orthogonal 的 basis.&lt;/li&gt;
&lt;li&gt;若已經有 $\{u_0, \cdots, u_k\}$, 並且我們得到 $r_{k+1}$, 則 Gram-Schimidt process 告訴我們可以定義 $u_{k+1}$ 為
$$
u_{k+1} = r_{k+1} - \frac{\langle r_{k+1}, Au_0\rangle}{\langle u_0, Au_0\rangle}u_0 - \cdots - \frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle}u_k,
$$
並且 $u_{k+1}$ 會跟 $u_0, \cdots, u_k$ 是 A-orthogonal.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-iterative-method-second-attempt&#34;&gt;CG as iterative method: Second attempt&lt;/h2&gt;
&lt;p&gt;給一個初始猜測 $x_0$, 我們可以算 $r_0 = b-Ax_0$, 並且我們定義第一個方向為 $u_0 = r_0$.&lt;/p&gt;
&lt;p&gt;接著我們可以往下做, for $k\ge 0$,
$$
\begin{align}
t_{k} &amp;amp;=\frac{\langle b-Ax_k,u_{k}\rangle}{\langle u_k,Au_{k}\rangle}, \\&lt;br&gt;
x_{k+1} &amp;amp;= x_k + t_k u_k, \\&lt;br&gt;
r_{k+1} &amp;amp;= r_k - t_kAu_k, \\&lt;br&gt;
u_{k+1} &amp;amp;= r_{k+1} - \frac{\langle r_{k+1}, Au_0\rangle}{\langle u_0, Au_0\rangle}u_0 - \cdots - \frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle}u_k.
\end{align}
$$
這樣保證在第 $n$ 步得到解.&lt;/p&gt;
&lt;p&gt;不過一般而言這是個迭代法, 我們在過程中會看 residual 的大小, $\|r_{k+1}\|^2_2$, 如果 residual 夠小就會停止整個迭代, 不需要真的做到第 $n$ 步.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark :&lt;/strong&gt;
這樣子做有個很明顯的缺點, 就是為了求出 A-orthogonal set 我們需要把所有方向 $\{u_i\}$ 都一直記著. 這樣當問題維度非常大時會需要耗費大量記憶體在存這些方向.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過我們可以再觀察一下, 若使用 Gram-Schimidt process, 則這些 $\{u\}$ 都是從 $\{r\}$ 得來的, 因此這兩個所組出來的空間應該是一樣的, 也就是
$$
\text{span}\{u_0,\cdots, u_k\} = \text{span}\{r_0,\cdots, r_k\}.
$$
我們若定義 $V_k = \text{span}\{u_0,\cdots, u_k\}$, 則由 Theorem 1 我們知道,
$$
\langle r_{k+1}, u_{j}\rangle=0, \quad 0\le j\le k,
$$&lt;/p&gt;
&lt;p&gt;也就是 $r_{k+1}$ 這個向量會垂直於 $V_k$ 這個空間, 因此我們也有&lt;/p&gt;
&lt;p&gt;$$
\tag{3} \langle r_{k+1}, r_{j}\rangle=0, \quad 0\le j\le k.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事實上, 實作 second attempt 後會發現, 要算 $u_{k+1}$ 其實只需要他的前一項, $u_{k}$, 即可, 也就是
$$
\tag{4} u_{k+1} = r_{k+1}  + \beta_k u_k, \quad \beta_k =  -\frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle},
$$
因為其他項都自動為零了! 接著我們就來證明這件事.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lemma-&#34;&gt;&lt;em&gt;&lt;strong&gt;Lemma :&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;$$
\langle r_{k+1}, Au_j\rangle = 0, \quad 0\le j\le k-1.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;根據 (2), 我們可以得到 $Au_j = \frac{r_j - r_{j+1}}{t_j}$. 因此
$$
\tag{5} \langle r_{k+1}, Au_j\rangle = \frac{1}{t_j}\langle r_{k+1}, r_j - r_{j+1}\rangle= \frac{\langle r_{k+1}, r_j \rangle - \langle r_{k+1}, r_{j+1} \rangle}{t_j}.
$$&lt;/p&gt;
&lt;p&gt;接著我們利用 (3), 代入 (5) 我們就得到 $\langle r_{k+1}, Au_j\rangle=0$ for $0\le j\le k-1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;將 $j=k$ 代入 (5) 得到
$$
\tag{6}\langle r_{k+1}, Au_k\rangle =  \frac{\langle r_{k+1}, r_k \rangle - \langle r_{k+1}, r_{k+1} \rangle}{t_k} = \frac{ - \langle r_{k+1}, r_{k+1} \rangle}{t_k}.
$$&lt;/p&gt;
&lt;p&gt;利用 (1) 與 (4) $t_k$ 及 $u_k$ 的定義我們可以推得
$$
\tag{7}
\begin{align}
t_k &amp;amp;= \frac{\langle r_{k}, u_{k} \rangle}{\langle u_{k}, Au_{k} \rangle} = \frac{\langle r_{k}, r_{k} + \beta_{k-1}u_{k-1} \rangle}{\langle u_{k}, Au_{k} \rangle} \\&lt;br&gt;
&amp;amp;= \frac{\langle r_{k}, r_{k}  \rangle}{\langle u_{k}, Au_{k} \rangle} + \frac{\langle r_{k}, \beta_{k-1}u_{k-1} \rangle}{\langle u_{k}, Au_{k} \rangle} \\&lt;br&gt;
&amp;amp;= \frac{\langle r_{k}, r_{k}  \rangle}{\langle u_{k}, Au_{k} \rangle}.
\end{align}
$$
最後一個等號我們用到了 Theorem 1 的結果. 因此 $t_k$ 可改為以 (7) 來做.&lt;/p&gt;
&lt;p&gt;將 (7) 改寫一下我們得到
$$
\tag{8}\langle u_{k}, Au_{k} \rangle = \frac{\langle r_{k}, r_{k}  \rangle}{t_k}.
$$&lt;/p&gt;
&lt;p&gt;最後, 我們可以將 $\beta_k$ 重新計算一下, 利用 (6) 跟 (8) 得到
$$
\tag{9} \beta_k = -\frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle} = \frac{\langle r_{k+1}, r_{k+1}\rangle}{\langle r_{k}, r_{k}\rangle}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-iterative-method-the-algorithm&#34;&gt;CG as iterative method: The algorithm&lt;/h2&gt;
&lt;p&gt;給一個初始猜測 $x_0$, 我們可以算 $r_b = b-Ax_0$, 並且我們定義第一個方向為 $u_0 = r_0$.&lt;/p&gt;
&lt;p&gt;接著我們可以往下做, for $k\ge 0$,
$$
\begin{align}
t_{k} &amp;amp;=\frac{\langle r_k,r_{k}\rangle}{\langle u_k,Au_{k}\rangle},\\&lt;br&gt;
x_{k+1} &amp;amp;= x_k + t_k u_k, \\&lt;br&gt;
r_{k+1} &amp;amp;= r_k  - t_kAu_k, \\&lt;br&gt;
\beta_k &amp;amp;= \frac{\langle r_{k+1}, r_{k+1}\rangle}{\langle r_{k}, r_{k}\rangle},\\&lt;br&gt;
u_{k+1} &amp;amp;= r_{k+1} + \beta_k u_k.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;這樣保證在第 $n$ 步得到解, 而且每次迭代都只需要 &lt;em&gt;&lt;strong&gt;一個&lt;/strong&gt;&lt;/em&gt; 矩陣向量乘法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不過一般而言這是個迭代法, 我們在過程中會看 residual 的大小, $\|r_{k+1}\|^2_2=\langle r_{k+1}, r_{k+1}\rangle$, 如果 residual 夠小就會停止整個迭代, 不需要真的做到第 $n$ 步. 而且這個量是在過程中會被計算出來的, 所以不需花費額外力氣.&lt;/li&gt;
&lt;li&gt;Residual $r_{k+1}=r_k-t_kAu_k$ 這個式子可能會在迭代的過程由於誤差進來而越來越不準, 所以每隔一段時間要以原本公式重新更新一次, $r_{k+1} = b - Ax_{k+1}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Power method</title>
      <link>https://teshenglin.github.io/post/2023_power_method_1/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_1/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基本-power-method&#34;&gt;基本 Power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最大(in magnitude) 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定 $A$ 為一個 $n\times n$ 方陣. 我們做以下兩個假設&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的 eigenvalues 滿足
$$
|\lambda_1| &amp;gt; |\lambda_2| \ge |\lambda_3| \cdots |\lambda_n|.
$$&lt;/li&gt;
&lt;li&gt;相對應的 eigenvectors, $\{v_1, , v_2, , \cdots, v_n\}$, 會構成 $R^n$ 的一組基底.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;則若我們&lt;em&gt;&lt;strong&gt;任意取&lt;/strong&gt;&lt;/em&gt;一個 $n\times 1$ 向量 $u$, 它能被寫成 (根據假設 2)
$$
u =\sum^{n}_{i=1} c_iv_i.
$$&lt;/p&gt;
&lt;p&gt;我們將兩邊乘以 $A$ 得到&lt;/p&gt;
&lt;p&gt;$$
Au = \sum^{n}_{i=1} c_i\lambda_i v_i,
$$&lt;/p&gt;
&lt;p&gt;並且如果我們一直乘以 $A$, 共乘 $k$ 次, 則有
$$
\tag{1} A^ku =\sum^{n}_{i=1} c_i\lambda^k_i v_i.
$$&lt;/p&gt;
&lt;p&gt;因為 $|\lambda_1|$ 比其他的都大 (根據假設 1), 我們可以得到當 $k$ 夠大時
$$
\tag{2} \frac{1}{\lambda^k_1}A^ku = c_1 v_1 + \sum^{n}_{i=2} c_i\left(\frac{\lambda_i}{\lambda_1}\right)^k v_i \to c_1 v_1.
$$&lt;/p&gt;
&lt;p&gt;因此我們知道, 如果我們一開始隨機選取一個向量, 並且將之以 $A$ 矩陣一直乘它, 乘出來的這個向量應該會越來越接近第一個 eigenvector, 藉此我們也可以得到最大的 eigenvalue.&lt;/p&gt;
&lt;p&gt;另外我們也知道, 收斂速度 (rate of convergence) 會是 $\frac{\lambda_2}{\lambda_1}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以看到 (2) 式有個特別的地方是等號左邊我們把他除以 $\lambda^k_1$, 這樣等號右邊就會趨近於 $c_1v_1$.&lt;/li&gt;
&lt;li&gt;如果真的照 (1) 式的做法, 任意取一個 $u$ 然後矩陣一直乘會發生什麼事呢?
&lt;blockquote&gt;
&lt;p&gt;如果 $\lambda&amp;gt;1$ 那 $\lambda^k\to\infty$, 如果 $\lambda&amp;lt;1$ 那 $\lambda^k\to 0$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;因此, 實際執行 (1) 是不可行的. 而 (2) 也不可行, 因為 $\lambda_1$ 就是我們要找的東西, 所以無法除以 $\lambda_1^k$.&lt;/li&gt;
&lt;li&gt;實際執行 power iteration 時, 會將每次迭代所得到的向量 normalize, 這樣就可以避免爆掉或趨近於零的狀況. 而最簡單的 normalization 就是讓每次得到的向量為單位長.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;作法&#34;&gt;作法:&lt;/h4&gt;
&lt;p&gt;Input: A
Output: (取絕對值後)最大的 eigenvalue $\lambda_1$ 以及 $v_1$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隨機選取一個向量 $u$, 並使 $\|u\|=1$&lt;/li&gt;
&lt;li&gt;計算 $v = Au$, 並令 $\lambda=\|v\|$&lt;/li&gt;
&lt;li&gt;另 $u=v/\lambda$ 並重複步驟 2 直到 $\lambda$ 收斂為止&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: matrix A
Output: lambda1, u

u = random(size(A,1),1)
u = u/norm(u)

Tol=10**(-10)
max_iter = 1000

lambda0=1
diff=1

iter=0

while diff &amp;gt; Tol
    v = A*u
    lambda1 = norm(v)
    u = v/lambda1
    
    diff = abs(lambda1-lambda0)    
    lambda0 = lambda1
    
    iter =iter+1
    if iter &amp;gt; max_iter || diff &amp;lt; Tol
        break
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過這樣得到的 &lt;code&gt;lambda1&lt;/code&gt; 會是 $|\lambda_1|$, 要拿到 $\lambda_1$ 需要再乘一次矩陣.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事實上我們的目標只是不要讓向量爆掉或趨近於零, 所以可以簡單的把某個位置的值固定住, 比如說我們強迫 $v_1$ 的第一個位置等於 $1$, 這樣就沒問題了.&lt;/p&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while diff &amp;gt; Tol
    v = A*u
    lambda1 = v(1)
    u = v/lambda1
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當然, 如果 $v_1$ 這個 eigenvector 本來他第一個位置就是 $0$ 那這招就不行了. 不過我們可以固定其他位置啊!&lt;/li&gt;
&lt;li&gt;理論上, 由於 $v_1$ 不是零向量, 因此一定有個位置非零, 可以被固定住. 不過通常就隨機選個位置固定住就好.&lt;/li&gt;
&lt;li&gt;這樣做的好處有兩個:
a. 取向量某一個位置的值遠比算向量的 norm 要快很多.
b. 這樣拿到的 eigenvalue 就是 $\lambda_1$, 沒有絕對值.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;若要找第二大的 eigenvalue 可以利用 deflation: 
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;Power method with deflation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;inverse-power-method&#34;&gt;Inverse power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最小(in magnitude) 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;observation&#34;&gt;Observation:&lt;/h4&gt;
&lt;p&gt;如果 $\lambda$ 滿足 $Av = \lambda v$, 則 $A^{-1}v = \frac{1}{\lambda} v$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 如果我們想要找一個矩陣 $A$ 它(絕對值)最小的 eigenvalue, $\lambda_n$, 那我們就需要對 $A^{-1}$ 做 power method. 也就是計算 $(A^{-1})^k u$. 這樣我們可以找到 $\frac{1}{\lambda_n}$, 將之反過來就得到最小的 eigenvalue.&lt;/p&gt;
&lt;p&gt;這裡需注意兩件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必須先確定最小的 eigenvalue 不是 $0$, 也就是這矩陣 non-singular, 不然 inverse power method 也無法做.&lt;/li&gt;
&lt;li&gt;$A^{-1}u$ 是解線性系統, 不是乘以 $A^{-1}$ 矩陣.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Inverse power method 的 rate of convergence 是 $\frac{\lambda_{n}}{\lambda_{n-1}}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;shift-inverse-power-method&#34;&gt;Shift-inverse power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最靠近某個數字 $c$ 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;observation-1&#34;&gt;Observation:&lt;/h4&gt;
&lt;p&gt;如果 $\lambda$ 滿足 $Av = \lambda v$, 則 $(A-cI)v = (\lambda-c) v$. 因此
$$
(A-cI)^{-1}v = \frac{1}{\lambda-c} v.
$$
也就是說, $(A-cI)^{-1}$ 這矩陣最大的 eigenvalue, 會是使得 $\frac{1}{\lambda-c}$ 最大的那個, 我們可以據此反推 $A$ 矩陣其最靠近 $c$ 的那個 eigenvalue.&lt;/p&gt;
&lt;p&gt;因此, 若我們想要找矩陣 $A$ 它最靠近某個數字 $c$ 的 eigenvalue, 那我們就需要對 $(A-cI)^{-1}$ 做 power method. 也就是計算 $((A-cI)^{-1})^k u$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Conjugate gradient method - direct method</title>
      <link>https://teshenglin.github.io/post/2023_conjugate_gradient_method_1/</link>
      <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_conjugate_gradient_method_1/</guid>
      <description>&lt;p&gt;共軛梯度法 (CG method,  conjugate gradient method) 目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_1&#34;&gt;CG method - Direct mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;直接法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;CG method - iterate mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;For solving $Ax=b$, where $A$ is a square symmetric positive definite matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h2&gt;
&lt;p&gt;$A\in M_{n\times n}$ is a symmetric positive definite matrix.&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A-orthogonal (A-conjugate)
假設有兩個向量 $u_1$ 跟 $u_2$ 皆非 $0$ 且 $u_1 \neq u_2$，若這兩個向量滿足
$$
\langle{u_1},A{u_2}\rangle = {u_1}^TA{u_2} = 0,
$$
則稱之為 A-orthogonal (或 A-conjugate).&lt;/li&gt;
&lt;li&gt;A-orthonormal
假設有兩個向量 $u_1$ 跟 $u_2$ 為 A-orthogonal, 並且 $\langle{u_i}, {u_i}\rangle_A = 1$ for $1\le i\le 2$, 則稱之為 A-orthonormal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Recall :&lt;/strong&gt; ${u_1}$ and ${u_2}$ are orthogonal if ${u_1}^T{u_2} = 0$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt; We can define
$$
\langle{u_1}, {u_2}\rangle_A = \langle{u_1},A{u_2}\rangle= \langle A{u_1},{u_2}\rangle,
$$
then $\langle \cdot\rangle_A$ is an inner product.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lemma&#34;&gt;Lemma&lt;/h3&gt;
&lt;p&gt;如果 ${u_0, \cdots, u_k}$ 是個 A-orthogonal set, 則 ${u_0, \cdots, u_k}$ 也是一個 linearly independent set.&lt;/p&gt;
&lt;h4 id=&#34;pf&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;假設 $c_0 u_0 + \cdots c_ku_k =0$.&lt;/p&gt;
&lt;p&gt;將此方程兩邊同時乘以 $u^T_j A$, 由於 $u_j^TAu_i=0$ for $i\ne j$, 因此得到 $c_j u^T_j Au_j = 0$. 此外, 由於 $A$ 是正定矩陣, $u^T_j Au_j &amp;gt; 0$, 因此 $c_j=0$.&lt;/p&gt;
&lt;p&gt;由於以上論述對所有 $j$ 都對, 因此得到 $c_i=0$ $\forall i$, 因此 ${u_0, \cdots, u_k}$ 為線性獨立.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt;
如果 ${u_0, \cdots, u_{n-1}}\subset\mathbb{R}^n$ 是個 A-orthogonal set, 則他們也是 $\mathbb{R}^n$ 的一組 basis.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-a-direct-method&#34;&gt;CG as a direct method&lt;/h2&gt;
&lt;h3 id=&#34;theorem&#34;&gt;Theorem:&lt;/h3&gt;
&lt;p&gt;假設對一個矩陣 A，我們可以找到一組 A-orthogonal set ${u_0, \ldots, u_{n-1}}$, 則線性系統 $Ax=b$ 的解為
$$
x = \sum^{n-1}_{j=0}\frac{u^T_j b}{u^T_jAu_j} u_j.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf-1&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;假設 $x = \sum^{n-1}_{i=0} c_i u_i$, 則&lt;/p&gt;
&lt;p&gt;$$
Ax = \sum^{n-1}_{i=0} c_i Au_i.&lt;br&gt;
$$&lt;/p&gt;
&lt;p&gt;將之代入 $b = Ax$ 並將兩側同時乘以 $u^T_j$ 得到
$$
u^T_j b = \sum^{n-1}_{i=0} c_i u^T_jAu_i = c_ju^T_jAu_j.
$$
因此
$$
c_j = \frac{u^T_j b}{u^T_jAu_j}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;實作上我們需要以迭代來尋找 $A$-orthogonal set, 並以迭代法來解線性系統.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Conjugate_gradient_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Conjugate gradient method - wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;迭代法推導請見
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;Conjugate gradient method - iterative method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Diffusion maps</title>
      <link>https://teshenglin.github.io/post/2021_diffusion_maps/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2021_diffusion_maps/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;擴散映射, 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Diffusion_map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diffusion maps&lt;/a&gt; (以下簡稱 DM), 是個資料分析, 流型學習或是資料降維的工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps 降維.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;algorithm---diffusion-maps-embeding&#34;&gt;Algorithm - diffusion maps embeding&lt;/h2&gt;
&lt;p&gt;先簡單介紹一下作法.&lt;/p&gt;
&lt;p&gt;假設我們有 $n$ 筆 $d$ 維的資料,
$$
\{x_1, x_2, \cdots, x_n\} \in R^d.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;我們需要先定一個 $K$ 矩陣, $K_{ij}=k(x_{i},x_{j})$, 一般而言我們使用 Guassian kernel
$$
k(x,y) = e^{-\frac{\lVert x-y \rVert^2}{\sigma^2}},
$$
其中 $\sigma$ 是個常數. 這樣造出來的 $K$ 矩陣會是個 $n\times n$ 對稱半正定的矩陣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著我們要定 diffusion matrix $P$, 其定義為
$$
P=D^{-1}K,
$$
其中 $D$ 是個只有對角線有值的矩陣, 其元素為相對應 $K$ 矩陣的 rowsum, $D_{ii} = \sum^n_{j=1} K_{ij}$.
因此可以知道 $P$ 矩陣其實就是將 $K$ 矩陣的每個 row 做 normalize 的動作, 使其 rowsum 等於 $1$.&lt;/p&gt;
&lt;p&gt;$P$ 這矩陣可看成是個機率矩陣, 其第 $i$ 個 row 表示從 $x_{i}$ 這個點跳到其他點的機率分佈.&lt;/p&gt;
&lt;p&gt;接著我們考慮 $Q$ 矩陣, 定義為
$$
Q=D^{-\frac{1}{2}}KD^{-\frac{1}{2}}.
$$
我們可以很輕易發現 $P$ 以及 $Q$ 兩個矩陣有完全相同的 eigenvalues, 而 $P$ 的 eigenvectors 是
$$
v = D^{-1/2}v_Q,
$$
其中 $v_Q$ 是 $Q$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;另一個重要觀察是 $Q$ 矩陣跟 $K$ 一樣是對稱半正定的矩陣, 因此它的 eigenvalues 都非負, 而且他的 eigenvalues 跟 singular values 會完全一模一樣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;先將 $Q$ 的 eigenvalues 跟 eigenvectors 都找出來, 接著 $P$ 的 eigenvalues 跟 eigenvectors 就依照上面的公式可以輕易得到.&lt;/p&gt;
&lt;p&gt;我們令 $P$ 的 eigenvalues 跟 eigenvectors 分別為 $\lambda_i$ 跟 $\psi_i$, $1\le i\le n$.&lt;/p&gt;
&lt;p&gt;需要注意的是, $\lambda_1=1$ 並且 $\psi_1$ 是一個常數向量, 因為我們要拿的是從第二個開始.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;接著我們定義 $Y$ 矩陣為
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \cdots, \lambda_n\psi_n\right],
$$
這是個 $n\times (n-1)$ 的矩陣.&lt;/p&gt;
&lt;p&gt;如果我們想要將原始資料投射到 $k$ 維, $k \le (n-1)$, 那我們就只要到第 $k+1$ 個 eigenvector 就好. 比如說要投影到三維, 我們只需要取
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \lambda_4\psi_4\right].
$$
而 diffusion maps embedding 的每個點就是這個 $Y$ 矩陣的 row, 也就是 $y_i = Y(i,:)$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;implementation-in-julia&#34;&gt;Implementation in &lt;code&gt;julia&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;接著我們就可以來看要怎樣以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps.&lt;/p&gt;
&lt;p&gt;我們需要以下幾個 packages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Distances
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;以下例子為一個 spiral curve, 我們想要看經過 diffusion maps 的投射到二或三維後會長什麼樣子.&lt;/p&gt;
&lt;p&gt;我們先把 spiral curve 上面的點造出來 (取 $300$ 個點)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# generating the data - a spiral curve&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# n: number of sampling&lt;/span&gt;
n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;

theta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi,length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
&lt;span style=&#34;color:#75715e&#34;&gt;# x and y-coordinates&lt;/span&gt;
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
&lt;span style=&#34;color:#75715e&#34;&gt;# X is a n-by-2 data matrix&lt;/span&gt;
X &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x y];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;畫出來看看原始 data 長怎樣. 我們照順序將點標為藍色, 紅色以及綠色.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), aspect_ratio&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:equal&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k-1&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;先來造出 $K$ 矩陣:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pairwise(Euclidean(), X, dims&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
sigma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;;
K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(E&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;(sigma&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q-1&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著造出 $Q$ 矩陣, 並求出其 eigenvalues 跟 eigenvectors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Q = zeros(n,n);
d_sq = zeros(n);
for ii = 1:n
    d_sq[ii] = sqrt(sum(K[ii,:]));
end
for ii = 1:n
    for jj = 1:n
        Q[ii,jj] = K[ii,jj]/(d_sq[ii]*d_sq[jj]);
    end
end
U,S,V = svd(Q);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors-1&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;$P$ 矩陣的 eigenvalues 跟 $Q$ 一樣, eigenvectors 也可以依公式得到:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; n
    V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;d_sq[ii];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;將 eigenvalues 畫出來看看. 左圖是第 $2$ 到第 $11$ 個, 右圖則是以 semilogy 畫出全部的 eigenvalues. 可以看出 eigenvalues 遞減的非常快, 所以其實 embedding 不需要取到全部 $(n-1)$ 維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scatter(S[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;], title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues 2:11&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(S), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues in log&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y-1&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;最後我們定義 embedding $Y$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;Y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(n,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
    Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;S[ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們知道 $Y$ 的每個 row 就是這個 embedding 的座標.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們將 embedding 畫出來看看. 左圖是 embed 到二維, 右圖則是 embed 到三維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們一樣照順序將點標為藍色, 紅色以及綠色. 有趣的是, 我們發現這個 embedding 將整個 spiral curve &lt;strong&gt;打開了&lt;/strong&gt;. 因此, 經由 diffusion maps 投射之後我們比較榮以可以看出點資料真正在整個曲線上彼此間距離的遠近.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;extension&#34;&gt;Extension&lt;/h2&gt;
&lt;p&gt;Diffusion maps 也常被拿來搭配 
&lt;a href=&#34;https://en.wikipedia.org/wiki/K-means_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k-means&lt;/a&gt; 做成分群演算法, 算是 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Spectral_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spectral clustering&lt;/a&gt; 的其中一種.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Diffusion maps 的 &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;julia&lt;/code&gt; 以及 &lt;code&gt;matlab&lt;/code&gt; 程式都可以在這裡找到: 
&lt;a href=&#34;https://github.com/teshenglin/diffusion_maps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github - teshenglin/diffusion_maps&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 畫圖</title>
      <link>https://teshenglin.github.io/post/2020_julia_plots/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_plots/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;底下的幾個例子我們將學習怎麼使用繪圖指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;畫圖的時候我們會用到 &lt;code&gt;Plots&lt;/code&gt; 這個 package，因此在第一行我們需要加上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下我們舉幾個簡單的範例來看看如何操作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; &lt;code&gt;Plots&lt;/code&gt; 這個 package 完整的說明請見 
&lt;a href=&#34;http://docs.juliaplots.org/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plots&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-11-基本函數&#34;&gt;Example 1.1 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin(x)$ 的例子。在 plot 指令中我們指定三件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;告訴他我們要畫 $y = \sin(x)$ 這個函數。&lt;/li&gt;
&lt;li&gt;再來要指定函數的範圍 $-\pi &amp;lt; x &amp;lt; \pi$。&lt;/li&gt;
&lt;li&gt;最後用 label 標註函數圖形。注意要把標註的文字放在 &amp;quot; &amp;quot; 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，也可以畫 $e^x$、$arcsin(x)$ 這些基本函數。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(sin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi, pi, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;example-12-基本函數&#34;&gt;Example 1.2 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin^{-1}(x)$ 的例子，有幾件事需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\sin(x)$ 的反函數 $arcsin(x)$ 的指令為 asin。&lt;/li&gt;
&lt;li&gt;函數的範圍為 $-1 &amp;lt; x &amp;lt; 1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(asin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arcsine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-2&#34;&gt;Example 2&lt;/h2&gt;
&lt;p&gt;接著我們看三維圖形的例子。這個例子中我們要畫出三維中的一條曲線&lt;/p&gt;
&lt;p&gt;$$\left(x(t), y(t), z(t)\right) = (t\cos t, t\sin t, t), \quad t\in[0, 8\pi].$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先將 $8\pi$ 切成 N 等分, 間距為 $\Delta t = 8\pi/N$.
&lt;ol&gt;
&lt;li&gt;在 julia 中可使用 unicode 變數名稱, 比如 $\Delta$ 打法是 &lt;code&gt;\Delta&lt;/code&gt; 接著按 tab 鍵, $\pi$ 則是 &lt;code&gt;\Pi&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定義 $n$ 是一個 $(N+1)\times 1$ 的向量，n = [0, 1, 2, &amp;hellip;,N]。&lt;/li&gt;
&lt;li&gt;定義 $t_i$ 是 $\Delta t\times n$&lt;/li&gt;
&lt;li&gt;$x = t_i .*\cos .(ti)$，注意向量相乘以及函數在向量的取值都需要加個&lt;code&gt;.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y 與 z 的值與 x 的值定義方法類似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由 (x,y,z) 的定義方式我們知道它是一個螺旋線，螺旋的半徑從 0 一直增加到 $8 \pi$。角度也是從 0 到 $8 \pi$，所以總共繞了4圈。
在 plot 指令中我們用 marker 選擇圖形的樣式為圓圈(circle)，legend=false 代表不標記圖形。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;;
Δt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;π&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N;
ti &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Δt&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti;
plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_9_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外, 可以用 &lt;code&gt;camera&lt;/code&gt; 這個指令來調整 3D 視角, 裡面數字是角度 (方位角azimuth, 高度角altitude).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false, camera &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_11_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們也可以使用指令 &lt;code&gt;plotd3d&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們設定 linewidth (lw) 等於 2 以及 legend (leg) 等於 false 表示不標記圖形.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot3d(x, y, z, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_13_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3&#34;&gt;Example 3&lt;/h2&gt;
&lt;p&gt;這個例子中，我們將學到怎麼在一個畫好的圖形上再加上另一個圖形。
我們嘗試一個簡單的例子，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一個圖形，x 座標是取整數 1 到 10。y 軸取 0 到 1 之間的亂數，共十個小數。再來，用 plot 指令將第一個圖形畫出。&lt;/li&gt;
&lt;li&gt;第二個圖形，使用相同的 x 座標，函數值 z 取亂數。將第二個函數圖形與第一個圖形重疊，我們需要指令 plot!&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
plot(x,y)
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
plot!(x,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-4&#34;&gt;Example 4&lt;/h2&gt;
&lt;p&gt;在一個圖形中同時畫出兩個函數，除了上述的方法之外我們還可以這麼做： 直接把兩個函數值定義成一個矩陣&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義 x 是整數 1 到 10。&lt;/li&gt;
&lt;li&gt;定義函數值 y 是一個 10*2 的矩陣，矩陣的第一行代表第一個函數的值，而矩陣的第二行代表第二個函數的值。y值的取法為 0 到 1 之間的亂數，為小數。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 plot 將兩個函數值同時畫出，用 title 設定圖形標題，lw=3 設定線段寬度。&lt;/p&gt;
&lt;p&gt;用 label=[&amp;ldquo;Line 1&amp;rdquo; &amp;ldquo;Line 2&amp;rdquo;] 標記函數名稱，須注意順序：
Line 1 會標記 y 的第一個函數值，Line 2 會標記 y 的第二個函數值。&lt;/p&gt;
&lt;p&gt;x 軸的名稱有兩種設定方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 plot 指令中加入：xlabel = &amp;ldquo;My x label&amp;rdquo;。 (xlabel 後面不用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;li&gt;或是在 plot 指令的下一行用 xlabel!(&amp;ldquo;My x label&amp;rdquo;) 加入。(xlabel! 後面要用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-5&#34;&gt;Example 5&lt;/h2&gt;
&lt;p&gt;如果函數取點的方法不同，能不能畫在同一張圖形中呢？
我們看下面的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;y 這個矩陣裡包含兩筆資料，x 的取點都是整數 1 到 10。所以可以用 &amp;ldquo;一個&amp;rdquo; 指令把兩筆資料畫出來。令這張圖叫做 p&lt;/li&gt;
&lt;li&gt;z 這筆資料為 0 到 1 中的 19 個亂數，xx 的取點也是19個在 [1, 10] 的均勻取點。所以我們用 plot! 指令，先畫出 p, 再把 z 這筆資料畫上去。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(x,y)

xx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)
plot!(p,xx,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 利用 &lt;code&gt;plot(x,y,xx,z)&lt;/code&gt; 這樣的指令是行不通的!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 另外，畫圖也可以用 &lt;code&gt;PyPlot&lt;/code&gt; 這個 package，有很多有趣的效果可以用。&lt;/p&gt;
&lt;p&gt;更多範例請見 
&lt;a href=&#34;http://blog.maxkit.com.tw/2019/06/julia-data-visulization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Data Visualization&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-6---曲面&#34;&gt;Example 6 - 曲面&lt;/h2&gt;
&lt;p&gt;這個例子我們示範如何畫曲面 $(x, y, h(x,y))$, where $h(x,y) = exp(-(x^2+y^2))$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我們設定 x 與 y 的範圍 $[-1, 1]$.&lt;/li&gt;
&lt;li&gt;接著我們設定函數 &amp;ldquo;h&amp;rdquo;&lt;/li&gt;
&lt;li&gt;最後, 我們利用指令 &lt;code&gt;surface&lt;/code&gt; 來畫曲面.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
y&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
h(x,y)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
surface(x,y,h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-7-動畫&#34;&gt;Example 7: 動畫&lt;/h2&gt;
&lt;p&gt;如果要將很多圖片合在一起做成動畫也是可以, 以下這個簡單例子將動畫存成一個 gif 檔.&lt;/p&gt;
&lt;p&gt;更多細節請見 
&lt;a href=&#34;https://docs.juliaplots.org/latest/animations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia_plots_animations&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot([sin, cos], zeros(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
anim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Animation()
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;π, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
    push!(p, x, &lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;[sin(x), cos(x)])
    frame(anim)
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
gif(anim, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine_cosine.gif&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 計時</title>
      <link>https://teshenglin.github.io/post/2020_julia_timing/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_timing/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 計算程式執行時間的指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，julia 計算程式運行效能有幾個指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@time&lt;/code&gt; 顯示出程式運行的秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timed&lt;/code&gt; 顯示程式執行回傳值，秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timev&lt;/code&gt; 顯示&lt;code&gt;@time&lt;/code&gt;一樣的資訊，最後顯示程式執行回傳值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@elapsed&lt;/code&gt; 顯示出某程式運行的秒數&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 真正要計算程式效能, 還是推薦用 &lt;code&gt;BenchmarkTools.jl&lt;/code&gt; 這個 package.&lt;/p&gt;
&lt;p&gt;以下範例中我們需要使用兩個 package: &lt;code&gt;LinearAlgebra&lt;/code&gt; 以及 &lt;code&gt;BenchmarkTools&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; BenchmarkTools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;example-1-matrix-matrix-multiplication&#34;&gt;Example 1: Matrix-matrix multiplication&lt;/h2&gt;
&lt;p&gt;我們以矩陣乘法 $C=A\times B$ 為例：$A:n\times p$, $B:p\times m$, $C:n\times m$&lt;/p&gt;
&lt;p&gt;f1 這個函數會產生兩個隨機矩陣 $A$, $B$ 並且將他們相乘:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f1(n, p, m)
   A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
   B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
   C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;m
         &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;p
            C[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; C[i,j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;A[i,k]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;B[k,j]
         &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們先試試看以 julia 既有的計算時間指令來看結果如何&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@time&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.076423 seconds (161.79 k allocations: 8.380 MiB)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;(nothing, 0.000448109, 184496, 0.0, Base.GC_Diff(184496, 1, 0, 5, 2, 0, 0, 0, 0))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timev&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.005932 seconds (8 allocations: 180.172 KiB, 92.28% gc time)
elapsed time (ns): 5931535
gc time (ns):      5473727
bytes allocated:   184496
pool allocs:       5
non-pool GC allocs:2
malloc() calls:    1
GC pauses:         1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@elapsed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;0.000561533
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這些指令的表現如同一開始我們所介紹的, 顯示出程式執行時間以及其他資訊.&lt;/p&gt;
&lt;p&gt;不過一般而言一個程式在第一次跑及之後幾次跑的運行效能會不同, 這是由於初始化的關係. 所以我們通常要跑好幾次來算平均, 已得知一個程式的真正效能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;benchmark&lt;/code&gt; 就提供了這樣的功用, 他會跑好幾次程式, 並且計算最大最小時間.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     437.243 μs (0.00% GC)
  median time:      485.922 μs (0.00% GC)
  mean time:        513.114 μs (3.90% GC)
  maximum time:     44.383 ms (98.89% GC)
  --------------
  samples:          9711
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著我們看一下如果用 &lt;code&gt;LinearAlgebra&lt;/code&gt; 裡的矩陣乘法指令效能如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f2(n, p, m)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
    B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
    C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
    mul!(C,A,B);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f2(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     41.088 μs (0.00% GC)
  median time:      91.270 μs (0.00% GC)
  mean time:        106.954 μs (19.04% GC)
  maximum time:     45.286 ms (99.75% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起來似乎比我們自己寫的 for-loop 效能好一些.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;type-stability&#34;&gt;type-stability&lt;/h2&gt;
&lt;p&gt;julia 語言號稱效能非常好, 不過常常我們自己寫一個 julia 程式發現跑得沒有很快, 這通常是由於所謂的 “型別穩定性 type-stability”. 這樣的問題可以藉由以下幾個 julia 內建的巨集程式來診斷.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_warntype&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_typed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_native&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這方面更深入的說明可見 
&lt;a href=&#34;https://docs.julialang.org/en/v1/manual/performance-tips/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia: performance tips&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-2-vector-2-norm&#34;&gt;Example 2: Vector 2-norm&lt;/h2&gt;
&lt;p&gt;接著我們看一下算向量 2-norm 的效能, 一樣我們比較一下自己寫的以及 call 函數的方式.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t1(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    vec&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.42 KiB
  allocs estimate:  3
  --------------
  minimum time:     423.973 μs (0.00% GC)
  median time:      504.538 μs (0.00% GC)
  mean time:        606.699 μs (9.87% GC)
  maximum time:     47.376 ms (98.43% GC)
  --------------
  samples:          8213
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t2(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    sum(abs2, vec);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t2(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.33 KiB
  allocs estimate:  2
  --------------
  minimum time:     141.160 μs (0.00% GC)
  median time:      195.940 μs (0.00% GC)
  mean time:        335.496 μs (19.51% GC)
  maximum time:     64.500 ms (99.17% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3-solving-linear-system&#34;&gt;Example 3: Solving linear system&lt;/h2&gt;
&lt;p&gt;這裡我們看一下解線性系統, 也就是 matlab 常見的&amp;quot;左除&amp;quot;, 的效率如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; s1(n)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,n);
    b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n);
    A&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;s1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; s1(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  15.28 MiB
  allocs estimate:  8
  --------------
  minimum time:     13.463 ms (0.00% GC)
  median time:      16.817 ms (10.20% GC)
  mean time:        18.148 ms (9.36% GC)
  maximum time:     64.226 ms (77.63% GC)
  --------------
  samples:          276
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>git 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_git/</link>
      <pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_git/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 git 這個分散式版本控制軟體. 有人可能會聽過 &amp;lsquo;github&amp;rsquo;. 不過這邊要提醒一下 git 跟 github 是不一樣的兩件事. 簡單的說 git 是一個軟體, 而 github 則是提供線上 git 服務的公司.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-教學網頁&#34;&gt;git 教學網頁&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我非常推薦 
&lt;a href=&#34;https://gitbook.tw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;為你自己學 Git&lt;/a&gt;, 尤其務必熟讀以下三章, 才算是對 git 有最基本的認識.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;二、Git Windows/Mac/Linux 環境安裝&lt;/li&gt;
&lt;li&gt;四、設定 Git&lt;/li&gt;
&lt;li&gt;五、開始使用 Git&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.slideshare.net/appleboy/introduction-to-git-11436559&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;快速上手 git 版本控制, slideshare&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-基本指令-terminal-終端機&#34;&gt;git 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;做完某個段落後, 將檔案 XXX 移進暫存區&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git add XXX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是將剛剛所有編輯過的檔案一起移
進暫存區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著將暫存區的檔案移至儲存褲 (repo), 並且記註做了什麼事&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;我做了XXX&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;支援-git-的網站&#34;&gt;支援 git 的網站&lt;/h2&gt;
&lt;h3 id=&#34;github&#34;&gt;github&lt;/h3&gt;
&lt;p&gt;如同我最初說的, github 是一個支援 git 的網站, 可以讓你擺放你程式的原始碼, 基本服務是免費的, 有一些更進階的功能則需要付費.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://progressbar.tw/posts/3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;開始使用 GitHub， 註冊與建立repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bitcuket&#34;&gt;bitcuket&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;也可以使用 
&lt;a href=&#34;https://bitbucket.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bitcuket&lt;/a&gt;, 一樣是個讓你把原始碼放上雲端的免費服務.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git---github-基本指令-terminal-終端機&#34;&gt;git &amp;lt;-&amp;gt; github 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;丟上雲端 (github 或 bitbucket)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;從雲端下載最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;簡單工作示意圖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD;
  A[工作資料夾]--&amp;gt;|add| B;
  B(本機 local 暫存區)--&amp;gt;|commit| C;
  D--&amp;gt;|pull| C;
  C(本機 local repo)--&amp;gt;|push| D{雲端 repo};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;git-觀念釐清&#34;&gt;git 觀念釐清&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://goo.gl/gAvBBp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git fetch 與 git pull 的區別&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_julia/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_julia/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 這個程式語言. 這是一個非常新的語言, 在 2009 年才問世, 遠比 1990 年出生的 python 來的年輕許多. 不過由於它又&lt;em&gt;&lt;strong&gt;快&lt;/strong&gt;&lt;/em&gt;又&lt;em&gt;&lt;strong&gt;簡單&lt;/strong&gt;&lt;/em&gt;, 又&lt;em&gt;&lt;strong&gt;不用錢&lt;/strong&gt;&lt;/em&gt;, 使得目前有越來越多人開始使用這個新語言. 相信未來會更加普及.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-安裝&#34;&gt;Julia 安裝&lt;/h2&gt;
&lt;p&gt;在 
&lt;a href=&#34;https://julialang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 官方網站&lt;/a&gt; 上可以下載各系統平台的安裝包裹. 下載安裝後即可運行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Julia 安裝教學影片可參考 
&lt;a href=&#34;https://youtu.be/v7XeveI19CM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia課程環境簡介 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只想試用一下的話可以試試 
&lt;a href=&#34;https://repl.it/languages/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repl.it&lt;/a&gt; 這個線上編輯器. 它可以讓你在線上編輯並執行一些簡單的 julia 程式.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 julia 主程式外, 我也建議加裝 &lt;code&gt;Jupyter notebook&lt;/code&gt;(或 &lt;code&gt;Jupyter lab&lt;/code&gt;) 以及 &lt;code&gt;Atom&lt;/code&gt;. 讓你 coding 更方便.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;julia-基本簡介&#34;&gt;Julia 基本簡介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查詢版本資訊&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; versioninfo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;套件(package)管理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會進入套件管理系統
```julia
pkg&amp;gt;
```

查詢已安裝套件
```julia
pkg&amp;gt; status
```

更新套件
```julia
pkg&amp;gt; update
```

跳出系統請按鍵盤上的 `刪除鍵`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢指令(如matlab中的help)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會變成查詢的視窗
```julia
help?&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jupyter-notebook-安裝&#34;&gt;Jupyter notebook 安裝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Jupyter notebook 是個互動式筆記本, 很容易可以逐行執行並且做到資料視覺化, 並且支援多種主流的直譯語言像是 &lt;code&gt;Julia&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;. 有一說是 jupyter 這個字事實上就是由 julia, python 以及 R 這三個字組合而成.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 有兩種方式. 第一種是直接由 julia 安裝. 步驟如下&lt;/p&gt;
&lt;p&gt;在 julia 輸入 &lt;code&gt;]&lt;/code&gt; 進入套件管理命令提示. 然後會長得像這樣&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著輸入 &lt;code&gt;status&lt;/code&gt; 可以看到現在已經安裝的套件.&lt;/p&gt;
&lt;p&gt;我們要安裝 IJulia, 所以輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; add IJulia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安裝完後要退出套件管理則是 BackSpace 鍵或是 Ctrl+C 都可以.&lt;/p&gt;
&lt;p&gt;要打開 notebook 需要退出套件管理, 並在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; notebook()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter notebook 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/@jamescchuang/%e5%af%a6%e6%88%b0%e5%ae%89%e8%a3%9d%e5%8f%8a%e5%bb%ba%e7%bd%ae-julia-%e9%96%8b%e7%99%bc%e7%92%b0%e5%a2%83-6dc8c0d14c2a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安裝及建置 Julia 開發環境實戰教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前已經有 jupyter notebook 的升級版, 稱為 jupyter lab. 在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; jupyterlab()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter lab 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 的第二種方式則是透過 anaconda. 先裝完 julia 後下載 anaconda 安裝, 即可快樂使用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/datainpoint/jupyter-kernels-3151a6408bab&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打造 Jupyter Notebook 資料科學環境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;在-atom-中操作-julia&#34;&gt;在 Atom 中操作 Julia&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果平常會寫各式程式語言, 可以考慮加安裝 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要在 Atom 裡操作 Julia 簡單說就是要裝以下幾個 package:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;julia-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;language-julia&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uber juno&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就可以用了!!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1550260279.html?fbclid=IwAR3bBrHTvjF3Y5TJrZsElriJfO2fbyoM751XMfjLYOE0TLl31JA3LSpe8KQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Atom 中操作 Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-基本簡介與語法教學&#34;&gt;Julia 基本簡介與語法教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/Introducing_Julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia: wikibook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://learnxinyminutes.com/docs/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Learn X in Y minutes, where X=Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Julia Taiwan發起人杜岳華的 slideshare: 
&lt;a href=&#34;https://www.slideshare.net/ssuserd6984b/coscup-introduction-to-julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://hackmd.io/@7WeiUEuJSBKp7WCRouAWVg/r106dSpkb/%2FIwZgbAHApgnARgMwLQAYAmKxICxQMZpICGGATEjHtgOwwwrRwCsEQA%3D%3D?type=book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 中文官方文件草稿&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;youtube-上的-julia-超新手教學&#34;&gt;Youtube 上的 Julia 超新手教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/JuliaLangTW/julia_tutorials_for_dummy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之一 on github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/zzrctueO6JY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之二 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/W7R5dxGrxlk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之三 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Markdown 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_markdown/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_markdown/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 markdown 這個語言. 它非常簡單易學, 有時我們只是想打個小文件, 就幾頁而已不想要開 latex 或是 word 之類的文字編輯軟體, 這時候就非常適合以 markdown 來編寫. 另外其實越來越多的程式語言也支援 markdown 編寫. 比如這個網頁裡的 post 就都是以 markdown 做的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-安裝&#34;&gt;Markdown 安裝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我自己是使用 mac, 我用的是 
&lt;a href=&#34;https://macdown.uranusjr.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MacDown&lt;/a&gt; 這個軟體.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安裝完 &lt;em&gt;Macdown&lt;/em&gt; 之後需要到 &lt;code&gt;Preference/Rendering&lt;/code&gt; 中標選 &lt;em&gt;tex-like math&lt;/em&gt; 以及他下一行的 &lt;em&gt;use dollar sign as xxxx&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近我用的是 
&lt;a href=&#34;https://typora.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora&lt;/a&gt; 這個軟體, 它支援各作業系統, 不管 mac 或 windows 都可以用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typora 主要特色是他&lt;strong&gt;所見即所得&lt;/strong&gt;, 所以邊寫邊看自己打出來的版面怎樣. 比較乾淨, 不需要將畫面切分成左右兩半一半程式一半預覽. 學起來也很簡單.&lt;/li&gt;
&lt;li&gt;安裝完 &lt;em&gt;Typora&lt;/em&gt; 之後到 &lt;code&gt;Preference/Markdown&lt;/code&gt; 中標選 &lt;em&gt;inline math&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://free.com.tw/typora/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora 免費極簡 Markdown 編輯器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1546144745.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown神器 -Typora使用教程筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果平常會寫各式程式語言, 也可以考慮使用 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己也有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果連安裝都不想的話我推薦 
&lt;a href=&#34;http://hackmd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hackmd&lt;/a&gt; 這個線上編輯器. 這個還能多人共筆編輯, 適合寫作業交作業.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://notes.dosilovic.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown notes&lt;/a&gt; . 它支援線上即時編寫, 可以線上存檔, 也可以下載成 markdown 以及 PDF.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://upmath.me&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;upmath&lt;/a&gt;, 一樣支援線上即時編寫, 可以存成 html 直接幫你產生網頁.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過我要稍微說明一下, 不管使用哪種編輯器, markdown 主要語法都差不多, 只是在輸出上會有一些細微的差異. 這點就要自己使用後才會感受得到差別.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法教學&#34;&gt;Markdown 語法教學&lt;/h2&gt;
&lt;p&gt;以下列舉一些 markdown 教學的線上資源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://commonmark.org/help/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1分鐘學會 Markdown&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://wastemobile.gitbooks.io/gitbook-chinese/content/format/markdown.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Markdown gitbook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://tiida54.github.io/2018/01/03/3%e5%88%86%e9%90%98%e5%ad%b8%e6%9c%83Markdown%e5%b8%b8%e7%94%a8%e8%aa%9e%e6%b3%95/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3分鐘學會 Markdown 常用語法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何使用 Markdown 來撰寫 Docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;markdown 有一個很酷的語法是可以做 diagram, 在 typora 這個編輯器有支援: 
&lt;a href=&#34;https://support.typora.io/Draw-Diagrams-With-Markdown/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Draw Diagrams With Markdown&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不過要稍微注意一下, 不要直接複製貼上介紹網頁裡的 diagram 程式到 typora 裡, 會跑不出來. 正確做法是, 比如說要做以下這個 sequence diagram, 那在 typora 裡打 ```sequence, 然後就會跑出一個框框讓你把程式貼進去. 程式貼入後圖就跑出來了.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我自己所使用的 macdown 也號稱有支援, 不過其實只有某些特別的版本能用而已, 有點可惜.&lt;/p&gt;
&lt;p&gt;如果是用 atom 的話則是要安裝 
&lt;a href=&#34;https://shd101wyy.github.io/markdown-preview-enhanced/#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown-preview-enhanced&lt;/a&gt; 這個 package. 我自己試過, 支援各種 diagram, 非常棒.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法補充&#34;&gt;Markdown 語法補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 markdown 文字間插入空白無法單純使用空白鍵, 在 mac 裡是 option+space, 其他可見 
&lt;a href=&#34;https://stackoverflow.com/a/54174466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Use non-breaking spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 markdown 裡將文字置中只能用 html 語法 
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Centered Text&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;latex-語法教學&#34;&gt;Latex 語法教學&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 一個很重要功能(至少對我而言)就是它支援 $\LaTeX$ 語法. Latex 數學排版系統是科學界中非常重要的一種系統. 它使得研究員在撰寫學術文章時能輕易地做好排版. 尤其是科學文章中常有大量數學符號, 這些符號的編排以及顯示是 Latex 系統一大強項.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果只是要以 Markdown 來寫一些簡單包含數學符號的文章, 還不需要學整個 Latex 系統. 我們只要會一些語法就好. 以下整理一些線上資源供參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://walkccc.github.io/blog/2018/02/17/Techniques/latex-syntax/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LaTeX 語法整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;List of LaTeX mathematical symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.overleaf.com/learn/latex/Integrals,_sums_and_limits&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Integrals, sums and limits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/LaTeX/Mathematics#Matrices_and_arrays&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;matrices and arrays&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有介於兩個 &lt;code&gt;$&lt;/code&gt; 字元之間的內容將會被視為 TeX 數學公式處理。開頭的 &lt;code&gt;$&lt;/code&gt; 右側必須立刻接上任意文字，而結尾 &lt;code&gt;$&lt;/code&gt; 的左側同樣也必須緊挨著文字。如果使用兩個&lt;code&gt;$$&lt;/code&gt;則會將數學公式換行居中. 例如以下 markdown 程式碼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$$\frac{\sin(x)}{x}$$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;顯示為
$$\frac{\sin(x)}{x}$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
