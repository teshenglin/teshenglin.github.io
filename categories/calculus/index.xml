<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Calculus | Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/categories/calculus/</link>
      <atom:link href="https://teshenglin.github.io/categories/calculus/index.xml" rel="self" type="application/rss+xml" />
    <description>Calculus</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 11 Dec 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/img/icon-192.png</url>
      <title>Calculus</title>
      <link>https://teshenglin.github.io/categories/calculus/</link>
    </image>
    
    <item>
      <title>數值積分初探</title>
      <link>https://teshenglin.github.io/post/2019_numerical_integration/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_numerical_integration/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;在微積分課程裡我們有學到積分的&amp;rsquo;中點法&amp;rsquo;, &amp;lsquo;梯形法&amp;rsquo;以及&amp;rsquo;辛普森法&amp;rsquo;. 這裡我們簡介一些基本概念並且引進高斯積分法.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;goal-任意給定一可積分函數-f-x-x-in-1-1-我們想要算-int-1-1-f-x-dx&#34;&gt;Goal: 任意給定一可積分函數 $f(x)$, $x\in[-1, 1]$, 我們想要算 $\int^1_{-1} f(x)\,dx$.&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 對任一個積分式 $\int^b_{a} g(x)\,dx$ 我們皆可用變數變換來將此積分轉到 $[-1, 1]$ 這個區間. 所以我們只需考慮 $[-1, 1]$ 即可.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先我們討論一下哪種方法比較準. 一個最簡單的判斷方法是看積分法能不能將多項式算準.&lt;/p&gt;

&lt;p&gt;我們考慮三種積分法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Midpoint rule: $\int^1_{-1}f(x)\,dx\approx 2f(0)$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trapezoidal rule: $\int^1_{-1}f(x)\,dx\approx f(-1)+f(1)$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Simpson&amp;rsquo;s rule: $\int^1_{-1}f(x)\,dx\approx \frac{1}{3}(f(-1)+4f(0)+f(1))$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我們先檢驗常數函數: $\int^1_{-1} 1\,dx=2$. 很快我們就可以發現以上三種方法都可以得出完全正確的答案.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接著我們檢驗一次函數: $\int^1_{-1} x\,dx=0$. 一樣, 三種方法都得出正確答案.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二次函數: $\int^1_{-1} x^2\,dx=\frac{2}{3}$. 對於二次函數我們發現, 中點法以及梯形法都無法算出正確答案, 只有辛普森法能成功.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三次函數: $\int^1_{-1} x^3\,dx=0$. 對於三次函數我們只檢驗辛普森法, 發現三次函數辛普森法也能算準.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四次函數: $\int^1_{-1} x^4\,dx=\frac{2}{5}$. 對於四次函數, 辛普森法就算錯了.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;小結論&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;中點跟梯形法準確率相同, 能準確的算出任意一次多項式的積分值.&lt;/li&gt;
&lt;li&gt;辛普森法比中點及梯形法更準確, 並且它能準確的算出任意三次多項式的積分值.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;接著我們稍微推廣一下, 並且介紹所謂的&amp;rsquo;高斯積分&amp;rsquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在想要用函數在 $x=0$ 這個點的值來估算積分, 那係數要取多少會最好?&lt;/p&gt;

&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x)\,dx\approx A_0f(0),$$
其中 $A_0$ 是個常數. 那 $A_0$ 要選哪個數字, 這個積分公式才會算的最準?&lt;/p&gt;

&lt;p&gt;依照我們之前的想法, 要讓積分式準就是要讓他把多項式算準. 所以我們希望他至少能把常數函數算準. 這樣的話很容易就看出 $A_0=2$, 也就是&amp;rsquo;中點法&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在想要用函數在 $x=-1$ 以及 $x=1$ 這兩個點的值來估算積分, 那係數要取多少會最好?&lt;/p&gt;

&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x)\,dx\approx \alpha f(-1)+\beta f(1),$$
其中 $\alpha, \beta$ 是常數.&lt;/p&gt;

&lt;p&gt;我們有兩個未知數, 所以我們希望他至少能把常數及一次函數算準. 這樣的話我們可以列出方程式:
$$
\alpha + \beta = 2, \quad -\alpha + \beta = 0.
$$
解方程式我們得到 $\alpha=\beta=1$, 也就是梯形法.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在只想用兩個點的值來估算積分, 那怎樣做會最好?&lt;/p&gt;

&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x)\,dx\approx A_0 f(x_0)+A_1 f(x_1),$$
其中 $A_0, A_1, x_0, x_1$ 都待決定.&lt;/p&gt;

&lt;p&gt;我們有四個未知數, 所以理想狀況下應該能從常數到三次多項式都能算準, 依此可以列出四個方程式:
$$
\begin{aligned}
A_0 + A_1 &amp;amp;= 2 \\&lt;br /&gt;
A_0x_0 + A_1x_1 &amp;amp;= 0 \\&lt;br /&gt;
A_0x^2_0 + A_1x^2_1 &amp;amp;= \frac{2}{3} \\&lt;br /&gt;
A_0x^3_0 + A_1x^3_1 &amp;amp;= 0.
\end{aligned}
$$
解方程式我們得到 $A_0=A_1=1$, $x_0=-\frac{1}{\sqrt{3}}$, $x_1=\frac{1}{\sqrt{3}}$. 也就是說&lt;/p&gt;

&lt;p&gt;$$
\int^1_{-1} f(x)\,dx \approx f\left(-\frac{1}{\sqrt{3}}\right)+ f\left(\frac{1}{\sqrt{3}}\right).
$$
這就是所謂的兩點高斯積分公式 (two-point Gaussian quadrature formula).&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;最後我們看一下以數值積分來估算的例子.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我們想計算 $\int^1_{-1} e^x\,dx$, 當然我們知道答案是 $e^1-e^{-1}$, 不過我們想要知道若以上列幾種方法估算會有多準確.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 一般來說我們會先將所要積分的範圍分成 $n$ 等分, 接著在每一等分上使用上列積分法. 這就是微積分課本中所介紹的合成積分法 (composite integral rules). 實作上的細節我們就不在這裡討論.&lt;/p&gt;

&lt;p&gt;我們將 $[-1, 1]$ 區間均勻分成 $n$ 等分, 再用三種不同積分法來估算積分值. 下表列出不同積分法在不同區間數所得之值與實際值之間的絕對誤差.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n\Method&lt;/th&gt;
&lt;th&gt;Midpoint&lt;/th&gt;
&lt;th&gt;Trapezoidal&lt;/th&gt;
&lt;th&gt;Simpson&amp;rsquo;s&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;3.91e-3&lt;/td&gt;
&lt;td&gt;7.83e-3&lt;/td&gt;
&lt;td&gt;2.08e-5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;3.92e-5&lt;/td&gt;
&lt;td&gt;7.83e-5&lt;/td&gt;
&lt;td&gt;2.09e-9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;3.92e-7&lt;/td&gt;
&lt;td&gt;7.83e-7&lt;/td&gt;
&lt;td&gt;2.10e-13&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我們可以看到, 中點以及梯形法誤差皆是以 $O(n^{-2})$ 來下降, 也就是點數變十倍時誤差會降一百倍, 而辛普森法則是 $O(n^{-4})$.&lt;/p&gt;

&lt;p&gt;接著我們試試看用高斯積分來做, 這裡我們就不分小區間, 直接做整個 $[-1, 1]$ 區間. 多個點的高斯積分的公式可在 &lt;a href=&#34;https://en.wikipedia.org/wiki/Gaussian_quadrature&#34; target=&#34;_blank&#34;&gt;wiki&lt;/a&gt; 找到. 我們將 $m$-point 高斯積分所得之值與實際值之間的絕對誤差列於下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;m\Method&lt;/th&gt;
&lt;th&gt;Gaussian quadrature rule&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;7.71e-3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6.55e-5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.95e-7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;8.25e-10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1.56e-12&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2.66e-15&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4.44e-16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看到我們用 8 個點就可以將這個積分準確估計到誤差接近機器的捨入誤差 (rounding error).&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>不定積分的悖論？</title>
      <link>https://teshenglin.github.io/post/2019_indef_integ/</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_indef_integ/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這幾天有個朋友問我一個關於不定積分的問題, 看起來很詭異. 我們一起來看看.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我們以分部積分(integration by part)來求 $\tan$ 的不定積分 $\int \tan(x)\,dx$.&lt;/p&gt;

&lt;p&gt;首先我們知道 $\tan(x) = \frac{\sin(x)}{\cos(x)}$, 接著我們來做分部積分, 假設
$$
u = \frac{1}{\cos(x)}, \quad dv = \sin(x)dx.
$$
因此我們知道
$$
du = \frac{\sin(x)}{\cos^2(x)}dx, \quad v = -\cos(x).
$$
根據分部積分公式我們得到
$$
\int \tan(x)\,dx  = \frac{1}{\cos(x)}\left(-\cos(x)\right) - \int (-\cos(x))\frac{\sin(x)}{\cos^2(x)}dx
= -1 + \int\tan(x)\,dx.
$$
等號最左邊跟最右邊都有 $\int\tan(x)\,dx$, 同時減掉我們就得到 $0 = -1$. 太神奇了!!&lt;/p&gt;

&lt;p&gt;所以問題是, 這中間究竟哪裏有問題？&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;不定積分 (indefinite integral) 以及反導函數 (antiderivative function) 是在講同一個東西. 可見 &lt;a href=&#34;https://en.wikipedia.org/wiki/Antiderivative&#34; target=&#34;_blank&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;我們最熟悉的數學符號, &amp;lsquo;等號&amp;rsquo;, &amp;lsquo;$=$&amp;rsquo;, 其實在不同的情況下有不同的定義. 雖然都是要表達相等的意思, 不過究竟是怎樣的相等還是有一些小細節需要注意的.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;在不定積分中的等號究竟是什麼意思? 我們都知道 $\cos$ 的反導函數是 $\sin$, 寫成不定積分就是&lt;/p&gt;

&lt;p&gt;$$
\int\cos(x)\,dx = \sin(x)+c,
$$
其中 $c$ 是任意常數. 那上列這個式子的等號是什麼意思?&lt;/p&gt;

&lt;p&gt;我們都知道 $\sin(x)$ 加上任意常數, 其微分都會是 $\cos(x)$, 所以我們才有這個式子. 也就是說, 上面這個等號就是這個意思!!&lt;/p&gt;

&lt;p&gt;再說清楚一點, 當我們寫 $\int f(x)\,dx = F(x)$ 時意思就是 $F&amp;rsquo;(x) = f(x)$.&lt;/p&gt;

&lt;p&gt;所以回到原文最後一個式子, 我把它在這裡重列一次
$$
\int \tan(x)\,dx  = -1 + \int\tan(x)\,dx.
$$
如果我們把 $\tan$ 的反導函數稱為 $F$, 也就是 $\int\tan(x)\,dx = F(x)$. 那這個式子可以改寫成
$$
\int \tan(x)\,dx  = -1 + F(x).
$$
我們知道這個式子也是對的因為 $(F(x)-1)&amp;rsquo; = \tan(x)$. 所以從這個角度來說, 這整個式子就都沒有問題了.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;所以最後一個問題是, 我們可以把東西減掉嗎? 舉例來說,
$$
\begin{aligned}
\int\cos(x)\,dx &amp;amp;= \sin(x)+1, \\&lt;br /&gt;
\int\cos(x)\,dx &amp;amp;= \sin(x).
\end{aligned}
$$
兩式一減我們就得到 $0=1$ 了!!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 事實上這樣寫是錯的. 再小心一點做的話你會發現兩式相減我們應該是得到
$$
\int 0\,dx = 1.
$$
從這裡來看的話, $1$ 的微分是 $0$, 那就完全沒有問題了.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Where should a pilot start descent?</title>
      <link>https://teshenglin.github.io/post/2019_cal_s3p5/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_cal_s3p5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.5, Calculus by Stewart&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/ImsaT.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An approach path for an aircraft landing is shown in the figure and satisfies the following conditions:&lt;/p&gt;

&lt;p&gt;(i). The cruising altitude is $h$ when descent starts at a horizontal distance $\ell$ from touchdown at the origin.&lt;/p&gt;

&lt;p&gt;(ii). The pilot must maintain a constant horizontal speed $v$ throughout descent.&lt;/p&gt;

&lt;p&gt;(iii). The absolute value of the vertical acceleration should not exceed a
constant $k$ (which is much less than the acceleration due to gravity)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Question 1: Find a cubic polynomial $P(x) = ax^3 + bx^2 + cx + d$ that satisfies condition (i) by imposing suitable conditions on $P(x)$ and $P’(x)$ at the start of descent and at touchdown.&lt;/p&gt;

&lt;p&gt;Answer: &lt;br /&gt;
At the start of descent:
$$
P(\ell) = al^3 +b\ell^2 +c\ell+d = h, \qquad P’(\ell) = 3a\ell^2 +2b\ell+c = 0.
$$
At touchdown:
$$
P(0) = 0 \Longrightarrow d = 0, \qquad P’(0)=0 \Longrightarrow c=0.
$$
Solve for $a$, $b$ in terms of $h$, $\ell$ we find
$$
P(x) = −\frac{2h}{\ell^3}x^3 + \frac{3h}{\ell^2}x^2.
$$&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Question 2: Use conditions (ii) and (iii) to show that $\frac{6hv^2}{\ell^2}\le k$.&lt;/p&gt;

&lt;p&gt;Answer: &lt;br /&gt;
From (ii), a constant horizontal speed $v$ is assumed throughout descent, we can then express $x$ as
$$
x = \ell - vt, \qquad t\in[0, \frac{\ell}{v}],
$$
where the minus sign indicating flying to the left. The polynomial $P$ can then be re-written in terms of variable $t$ as
$$
P(t) = −\frac{2h}{\ell^3}(\ell - vt)^3 + \frac{3h}{\ell^2}(\ell - vt)^2, \qquad
\frac{d^2t}{dt^2}P(t) = −\frac{12hv^2}{\ell^3}(\ell - vt) + \frac{6hv^2}{\ell^2}.
$$
Therefore, the vertical acceleration $a$ is
$$
a(t) = \left|−\frac{12hv^3}{\ell^3}(\ell - vt) + \frac{6hv^2}{\ell^2}\right| = \left|\frac{12hv^3}{\ell^3}\,t - \frac{6hv^2}{\ell^2}\right|, \qquad t\in[0, \frac{\ell}{v}].
$$
It can be check, from the Extreme Value Theorem and closed interval method, that $a$ attains it&amp;rsquo;s maximum value and the value is $\frac{6hv^2}{\ell^2}$.
From condition (iii), we therefore have
$$
\frac{6hv^2}{\ell} \le k.
$$&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Question 3: Suppose that an airline decides not to allow vertical acceleration of a plane to exceed $k = 860(mi/h^2)$. If the cruising altitude of a plane is $35,000(ft)$ and the speed is $300(mi/h)$, how far away from the airport should the pilot start descent?&lt;/p&gt;

&lt;p&gt;Answer:&lt;br /&gt;
Given $P(x) = −\frac{2h}{\ell^3}x^3 + \frac{3h}{\ell^2}x^2$, suppose the pilot starts to descend when the plane is $\ell(mi)$ from the airport.
In Q2. we know that $\frac{6hv^2}{\ell^2}\le k$. So,
$$
v=300(mi/h), \qquad h=35000(ft) ≈ 6.628(mi), \qquad k=860(mi/h^2)
$$
$$
\frac{6\times 6.628\times (300)^2}{\ell^2} \le 860, \quad \Longrightarrow \quad
64.511 \le \ell.
$$
That is, the pilot should start to decend when the plane is $62.511(mi)$ away from the airport.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Question 4: Graph the approach path if the conditions stated in Problem 3 are satisfied.&lt;/p&gt;

&lt;p&gt;Answer:\&lt;/p&gt;

&lt;p&gt;To be finished.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fixed point iteration</title>
      <link>https://teshenglin.github.io/post/2019_fixed_point/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_fixed_point/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;這裡我們介紹固定點迭代法 (Fixed point iteration)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我們介紹什麼是固定點 (Fixed point)&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;definition-fixed-point&#34;&gt;Definition: Fixed point&lt;/h2&gt;

&lt;p&gt;A fixed point of a function $f(x)$ is a number $c$ in its domain such that $f(x)=c$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以簡單來說, 把固定點這個數字丟進函數後會得到同樣的一個數字. 所以稱之為固定點.&lt;/p&gt;

&lt;p&gt;那固定點重要性其一是在數值計算上有一種迭代方式叫做固定點迭代(Fixed point iteration). 假設我們想要求某個函數的固定點, 也就是滿足 $c=f(c )$ 的這些 $c$, 那我們可以定義一個迭代式
$$
x_{n+1} = f(x_n).
$$&lt;/p&gt;

&lt;p&gt;如果夠幸運的, $\{x_{n}\}$ 這串數字收斂了, 那把它收斂到的數字稱為 $\bar{c}$ 我們就有 $\bar{c}=f(\bar{c})$, 也就是固定點.&lt;/p&gt;

&lt;p&gt;舉個例子來說, 假設我們想要解 $x=\cos(x)$ 這個方程式, 那我們可以定義一個固定點迭代為
$$
x_{n+1} = \cos(x_n).
$$&lt;/p&gt;

&lt;p&gt;這樣的話如果數列收斂那我們就解出來了!! 不過這裡有兩個問題.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;為什麼這個數列會收斂?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原方程式的固定點迭代其實有無窮多種改寫方式, 例如也可寫為 $x_{n+1} = \cos^{-1}(x_n)$. 如果收斂的話一樣會是原方程式的解. 那, 哪種改寫方式最好呢?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我們有以下這個定理&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;theorem&#34;&gt;Theorem&lt;/h2&gt;

&lt;p&gt;If $f:[a, b]\to [a,b]$ is a differentiable function such that
$$ |f&amp;rsquo;(x)|\leq \alpha&amp;lt;1, \quad \forall x\in[a, b],$$
then $f$ has exactly one fixed point $c$ and the fixed point iteration converges to $c$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;這個證明很簡單.&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;proof&#34;&gt;Proof&lt;/h3&gt;

&lt;h3 id=&#34;sketch-not-complete-please-full-in-the-details-by-yourself&#34;&gt;(Sketch, not complete, please full-in the details by yourself)&lt;/h3&gt;

&lt;h4 id=&#34;existence&#34;&gt;existence&lt;/h4&gt;

&lt;p&gt;Since the domain and the range of $f$ are both $[a, b]$, by Intermediate Value Theorem, there exists $c$ such that $c=f(c )$.&lt;/p&gt;

&lt;h4 id=&#34;uniqueness&#34;&gt;uniqueness&lt;/h4&gt;

&lt;p&gt;If there exits another fixed point $\bar{c}$, $\bar{c}\ne c$, such that $\bar{c}=f(\bar{c} )$, then according to Mean Value Theorem(MVT), there exits $z$ such that $$f&amp;rsquo;(z) = \frac{f(c ) - f(\bar{c})}{c-\bar{c}} = 1,$$ which violate the assumption that $|f&amp;rsquo;|\leq \alpha&amp;lt;1$. So the fixed point is unique.&lt;/p&gt;

&lt;h4 id=&#34;convergence-of-fixed-point-iteration&#34;&gt;convergence of fixed point iteration&lt;/h4&gt;

&lt;p&gt;Finally, again, based on MVT we have
$$|x_{n+1} - c| = |f(x_n) - f(c )| = |f&amp;rsquo;(c_i)(x_n-c)|\leq\alpha |x_n-c|\leq\alpha^n|x_1-c|\to 0.$$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以如果在固定點 $c$ 的微分小於 $1$, 那就存在一個包含 $c$ 的小區間使得函數的微分都在這區間內小於 $1$, 那根據這定理固定點迭代就會收斂.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;固定點迭代是求根問題(root finding problems)中很重要的一種迭代方式. 舉個例子來說, 假設我們想要找 $g(x)$ 這個函數的根, 那我們可以定義
$$
f(x) = x + g(x).
$$
這樣的話 $f$ 的固定點就會是 $g$ 的根了. 不過跟上面一樣, 這樣的定義方式有無窮多種, 哪種是最好的? 其中一個最有名的就是牛頓法 (Newton&amp;rsquo;s method):&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;newton-s-iteration&#34;&gt;Newton&amp;rsquo;s iteration&lt;/h2&gt;

&lt;p&gt;$$x_{n+1} = x_n - \frac{g(x_n)}{g&amp;rsquo;(x_n)}.$$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我們可以定義 $f(x) = x - \frac{g(x)}{g&amp;rsquo;(x)}$, 這樣上面這個式子就是個固定點迭代. 接著我們可以發現, 如果 $c$ 是 $g$ 函數的根, 也就是 $g(c )=0$, 那 $f&amp;rsquo;(c ) = 0$. 所以根據上面的定理就存在某個包含 $c$ 的小區間使得迭代會收斂.&lt;/p&gt;

&lt;p&gt;更進一步我們可以利用泰勒展開式(Taylor&amp;rsquo;s series expansion) 來證明牛頓法事實上有二次收斂,
$$
|x_{n+1} - c| \approx \beta |x_n-c|^2.
$$
這個證明我們這邊就先略過不寫. 不過接著我們來看一下牛頓法究竟有多快. (&amp;ndash;To be finished)&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Maximum and minimum of a function</title>
      <link>https://teshenglin.github.io/post/2019_maxmin/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_maxmin/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;這裡我們要討論一個函數的最大值以及最小值.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我們有極值定理&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;theorem-extreme-value-theorem&#34;&gt;Theorem: Extreme value theorem&lt;/h2&gt;

&lt;p&gt;If $f$ is a real-valued continuous function on the closed interval $[a,b]$, then $f$ must attain a maximum and a minimum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以對於定義在封閉區間的連續函數, 必定會有極值. 接下來我們看一下實際上我們怎麼把極值找出來.&lt;/p&gt;

&lt;p&gt;在微積分課本裡有所謂的封閉區間法, 如下:&lt;/p&gt;

&lt;h2 id=&#34;the-closed-interval-method&#34;&gt;The closed interval method&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
  B[f is `continuous` on a `closed interval`]--&amp;gt;A;
  B--&amp;gt;C;
  A[Determine the critical points]--&amp;gt;|f&#39;=0| D(The largest value at these points is the abs. max. and the smallest value is the abs. min.);
  A--&amp;gt;|f&#39; not exists| D;
  C[Determine the end points]--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個方法的原理跟做法都很簡單, 我這邊就不多做說明.&lt;/p&gt;

&lt;p&gt;不過我要做一些補充. 事實上這個方法要能用還有一個很重要的假設是&lt;code&gt;假設這個函數只在有限個地方微分不存在&lt;/code&gt;. 如果一個函數在無窮多地方微分不存在, 雖然最大值還會是 &amp;ldquo;微分等於 0&amp;rdquo;, &amp;ldquo;微分不存在&amp;rdquo;, &amp;ldquo;端點&amp;rdquo; 這些地方的函數值中找最大的. 不過實作上會找不完. 所以等於是沒有用.&lt;/p&gt;

&lt;p&gt;當然這樣的假設看起來很正常, 難道有函數是連續的, 但是在無窮多地方微分不存在嗎? 很不幸的也很幸運的, 真的有! 其中有一個很特別的函數叫做 &lt;a href=&#34;https://en.wikipedia.org/wiki/Weierstrass_function&#34; target=&#34;_blank&#34;&gt;Weierstrass function&lt;/a&gt;. 它是定義在實數軸上的函數, 在每個點都連續, 但是同時在任何一個點微分都不存在. 所以如果套用 the closed interval method 在這函數上會發現所有的點都是 critical point, 所以套用之後還是必須要找出所有點中函數值最大的. 完全沒有簡化到.&lt;/p&gt;

&lt;h3 id=&#34;question-1-是否存在連續-但是在每個點微分都等於-0-的函數&#34;&gt;Question 1: 是否存在連續, 但是在每個點微分都等於 0 的函數?&lt;/h3&gt;

&lt;p&gt;當然有! 常數函數就是. 不過這個很好 check 最大最小值所以沒什麼問題.&lt;/p&gt;

&lt;h3 id=&#34;question-2-是否存在連續-但是在每個點微分都等於-0-的非常數函數-non-constant-function&#34;&gt;Question 2: 是否存在連續, 但是在每個點微分都等於 0 的非常數函數(non-constant function)?&lt;/h3&gt;

&lt;p&gt;I will leave it as an exercise.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最後再補充一點, 函數在某個點連續但是微分不存在有幾種情形:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尖點. 例如 $f(x) = |x|$ 在 $x=0$ 時.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;垂直切線. 例如 $f(x) = \sqrt[3]{x}$ 在 $x=0$ 時.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;微分定義中的極限不存在. 例如 $f(x) = x\sin(x)$ 在 $x=0$ 時.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Slant asymptotes</title>
      <link>https://teshenglin.github.io/post/2019_slant_asymp/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_slant_asymp/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 slant asymptotes, 也就是所謂的斜漸近線.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;section-1-slant-asymptotes&#34;&gt;Section 1: slant asymptotes&lt;/h2&gt;

&lt;p&gt;斜漸近線定義如下:
The line $y=mx+b$, $m\ne 0$, is called a slant asymptote of $f(x)$ if
$$
\lim_{x\to\infty} [f(x) - (mx+b)] = 0.
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 亦可將上列式子中改為 $x\to-\infty$. 滿足此條件的也是斜漸近線. 所以斜漸近線最多有兩條.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;section-1-1-長除法&#34;&gt;Section 1.1: 長除法&lt;/h3&gt;

&lt;p&gt;要求得斜漸近線的方法其中之一是長除法. 例如以下這個函數
$$
f(x) = \frac{4x^3-10x^2-11x+1}{x^2-3x}.
$$
將這個函數的分子與分母做長除法發現
$$
4x^3-10x^2-11x+1 = (4x+2)(x^2-3x) + (-5x+1),
$$
也就是說
$$
f(x) = (4x+2) + \frac{-5x+1}{x^2-3x}.
$$
這樣我們很明顯可以看出來
$$
\lim_{x\to\pm\infty} [f(x) - (4x+2)] = \lim_{x\to\pm\infty} \frac{-5x+1}{x^2-3x} = 0.
$$
所以 $y=4x+2$ 就是這個函數的斜漸近線.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;section-1-2-直接法&#34;&gt;Section 1.2: 直接法&lt;/h3&gt;

&lt;p&gt;不過如果遇到無法做長除法的函數, 以上的招數就失效了. 例如
$$
g(x) = \sqrt{x^2-1}+3,
$$
就無法以長除法來找斜漸近線.&lt;/p&gt;

&lt;p&gt;我們先觀察一下原本斜漸近線的定義, 然後很快就可以發現, 如果 $y=mx+b$ 是一條斜漸近線則我們有
$$
\lim_{x\to\infty} \frac{f(x)}{x} = m.
$$
所以透過以上這個式子我們可以找到斜漸近線中的第一個參數 $m$. 知道這個參數之後我們一樣再把原本定義改寫一下則有
$$
\lim_{x\to\infty} [f(x) - mx] = b.
$$
利用這個式子就可以找到斜漸近線中的第二個參數 $b$.&lt;/p&gt;

&lt;p&gt;我們以上面的 $g(x)$ 函數為例來找一下它的斜漸近線.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先第一步我們先看一下 $g(x)$ 在正負無窮遠的行為:
$$
\lim_{x\to\infty} g(x) = \infty, \quad \lim_{x\to-\infty} g(x) = \infty.
$$
發現它會趨近無窮大, 所以有機會有斜漸近線.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果趨近一個常數那就會得到橫漸近線 (horizontal asymptotes), 那就沒有斜漸近線.&lt;/li&gt;
&lt;li&gt;如果極限不是正負無窮大其中之一, 那也不可能會有斜漸近線.&lt;/li&gt;
&lt;li&gt;以上都是在講單邊 ($x\to\infty$, 或是 $x\to -\infty$), 有可能兩邊行為完全不一樣.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接著我們試著求出 $m$:
$$
\lim_{x\to\infty} \frac{g(x)}{x} = \lim_{x\to\infty} \frac{\sqrt{x^2-1}+3}{x} = 1.
$$
所以 $m=1$. 接著我們求解 $b$:
$$
\lim_{x\to\infty} [g(x) - mx] = \lim_{x\to\infty} \left[\sqrt{x^2-1}+3 - x\right] = 3.
$$
所以 $b=3$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同樣做法可以得到 $x\to -\infty$ 時我們有 $m=-1$, $b=3$.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因此我們得到 $g(x)$ 在正無窮遠處的斜漸近線為 $y=x+3$, 在負無窮遠處的斜漸近線為 $y=-x+3$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;section-1-3-summary&#34;&gt;Section 1.3: Summary&lt;/h3&gt;

&lt;p&gt;總結一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;斜漸近線可以用長除法或直接法求得.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不過不管長除法或直接法都是求出斜漸近線的計算過程. 實際上不管用哪種方法做, 長除法, 直接法, 或是當你很有經驗時可以一眼看出來, 要&lt;strong&gt;證明&lt;/strong&gt;你所得到的直線是斜漸近線就是要驗證最初的定義是否正確. 也就是要驗證以下這個式子是對的:
$$
\lim_{x\to\infty} [f(x) - (mx+b)] = 0.
$$
如果是對的, 你就得到它了.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算微分</title>
      <link>https://teshenglin.github.io/post/2019_derivate_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_derivate_evaluate/</guid>
      <description>

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    前情提要: &lt;a href=&#34;https://teshenglin.github.io/post/2019_limit_evaluate&#34;&gt;用電腦算極限&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;這裡我們要講的是用數值計算來算函數的微分值.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;已知一個函數 $f(x)$ 在某個點 $a$ 的微分值定義是
$$
f&amp;rsquo;(a) = \lim_{h\to 0} \frac{f(a+h)-f(a)}{h}.
$$&lt;/p&gt;

&lt;p&gt;我們用一個簡單的例子試試看. 假設我們想求 $f(x)=x^2$ 在 $x=\pi$ 的微分. 根據定義我們有&lt;/p&gt;

&lt;p&gt;$$
f&amp;rsquo;(\pi) = \lim_{h\to 0} \frac{(\pi+h)^2-\pi^2}{h}.
$$&lt;/p&gt;

&lt;p&gt;接著我們將 $h$ 取靠近 $0$ 的 $1000$ 的點並帶入上列這個式子試著來算其極限值.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000×2 Array{Float64,2}:
 1.0    7.28319
 0.999  7.28219
 0.998  7.28119
 0.997  7.28019
 0.996  7.27919
 0.995  7.27819
 0.994  7.27719
 0.993  7.27619
 0.992  7.27519
 0.991  7.27419
 0.99   7.27319
 0.989  7.27219
 0.988  7.27119
 ⋮
 0.012  6.29519
 0.011  6.29419
 0.01   6.29319
 0.009  6.29219
 0.008  6.29119
 0.007  6.29019
 0.006  6.28919
 0.005  6.28819
 0.004  6.28719
 0.003  6.28619
 0.002  6.28519
 0.001  6.28419
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上列數字左邊是 $h$ 值, 右邊為估計的微分值. 我們發現的確這個數字會越來越接近真實的解, 也就是 $2\pi$, 約等於 $6.283185307179586$.&lt;/p&gt;

&lt;p&gt;接著我們算一下這個值與真實值 $2\pi$ 之間的差, 我們取其絕對值來表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000×2 Array{Float64,2}:
 1.0    1.0
 0.999  0.999
 0.998  0.998
 0.997  0.997
 0.996  0.996
 0.995  0.995
 0.994  0.994
 0.993  0.993
 0.992  0.992
 0.991  0.991
 0.99   0.99
 0.989  0.989
 0.988  0.988
 ⋮
 0.012  0.012
 0.011  0.011
 0.01   0.01
 0.009  0.009
 0.008  0.008
 0.007  0.007
 0.006  0.006
 0.005  0.005
 0.004  0.004
 0.003  0.003
 0.002  0.002
 0.001  0.001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的確, 當 $x$ 越來越靠近 $\pi$ 時這個估計出來的微分值離 $2\pi$ 的距離越來越小.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 用數值計算微分能有多精確? 這個誤差能不能一直遞減下去?&lt;/p&gt;

&lt;p&gt;接著我們取更多靠近 $0$ 的點來計算微分的極限值, 我們列出其與真實值 $2\pi$ 之間的差, 並且把它畫出來.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;241×2 Array{Float64,2}:
 0.00673795   0.00673795
 0.00609675   0.00609675
 0.00551656   0.00551656
 0.00499159   0.00499159
 0.00451658   0.00451658
 0.00408677   0.00408677
 0.00369786   0.00369786
 0.00334597   0.00334597
 0.00302755   0.00302755
 0.00273944   0.00273944
 0.00247875   0.00247875
 0.00224287   0.00224287
 0.00202943   0.00202943
 ⋮
 7.64159e-13  0.000179905
 6.9144e-13   0.000756556
 6.25641e-13  9.69264e-5
 5.66103e-13  0.00196331
 5.12231e-13  0.00285478
 4.63486e-13  0.00227874
 4.1938e-13   0.0016747
 3.7947e-13   0.00576551
 3.43359e-13  0.00259406
 3.10684e-13  0.000421242
 2.81119e-13  0.00220945
 2.54367e-13  0.001922
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;觀察最後一列數字發現, 當 $h=2.54367*10^{-13}$ 時, 估計出來的微分值與真實值差了 $0.001922$ 這麼多!!&lt;/p&gt;

&lt;p&gt;我們把它畫出來看看, 橫軸是 $h$, 縱軸是 $\left|\frac{(\pi+h)^2-\pi^2}{h}-2\pi\right|$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_22_0.svg&#34; alt=&#34;svg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那誤差最小值出現在什麼時候呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1×2 Array{Float64,2}:
 5.05653e-8  7.25251e-9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們發現當 $h=5.05653*10^{-8}$ 時, 其估計出來的微分值離真實值誤差最小, 其誤差為 $7.25251*10^{-9}$.&lt;/p&gt;

&lt;p&gt;不過, WHY?? 為什麼誤差不會一直往下遞減? 其實這也是因為捨入誤差的關西.&lt;/p&gt;

&lt;p&gt;觀察一下我們的式子
$$
\frac{f(a+h)-f(a)}{h}
$$
當我們在用數值計算這個式子的時候其實並不完全是這樣子, 在分子應該會有捨入誤差在, 也就是說, 其實我們看到的數字應該是以下這個式子算出來的
$$
\frac{f(a+h)-f(a) + \epsilon}{h}
$$
其中的 $\epsilon$ 就是捨入誤差. 所以, 我們計算的時候會多出了 $\frac{\epsilon}{h}$ 這麼多.&lt;/p&gt;

&lt;p&gt;如果依我們之前所算的 $\epsilon\approx 10^{-16}$, 那當 $h=10^{-8}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-8}} = 10^{-8}$.&lt;/p&gt;

&lt;p&gt;而當 $h=10^{-13}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-13}} = 10^{-3}$. 跟我們之前所發現的完全吻合!!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;

&lt;p&gt;最後總結一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我們可以用數值計算來估計一個函數在某點的微分值
$$
f&amp;rsquo;(a) = \lim_{h\to 0} \frac{f(a+h)-f(a)}{h}.
$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不過計算時 $h$ 值不能無限取小, 需考慮到捨入誤差的影響.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算極限</title>
      <link>https://teshenglin.github.io/post/2019_limit_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_limit_evaluate/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹如何用電腦算極限, 以及我們來看一下當我們真的這樣做的時候有可能會發生什麼問題. 我們以 $sinc$ 函數為例來做說明.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;sinc-function&#34;&gt;sinc function&lt;/h3&gt;

&lt;p&gt;首先我們要介紹一個特別的函數, $sinc(x)$, 定義如下:
$$
sinc(x) = \frac{\sin(x)}{x}, \quad x\ne 0.
$$
很明顯可以看出來當 $x=0$ 的時候分母會等於零, 是一件壞事, 所以把 $x=0$ 這個點先拿掉.&lt;/p&gt;

&lt;p&gt;比較有趣的是我們可以把這個函數畫出來. 首先我們在 $[-20, 20]$ 這個區間取 $1000$ 個點, 然後帶入上面 $sinc$ 函數的定義, 再把所有點連起來看看.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 有件事需要先說明一下, 由於我們是在 $[-20, 20]$ 這個區間均勻的取偶數個點, 所以會有 $500$ 個正數以及 $500$ 個負數, 重點是保證不會取到 $x=0$ 這個點, 所以沒有問題. 相反的, 如果取奇數個點就一定會取到 $x=0$, 那就會有函數無定義的問題了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_3_0.svg&#34; alt=&#34;svg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我們很輕易可以看出來, 連起來的線還蠻&amp;rdquo;光滑&amp;rdquo;的. 函數值在 $x=0$ 附近似乎不會趨近正無窮大或負無窮大, 也沒有跳躍的現象. 接著我們試著在 $x=0$ 附近放大一點看看, 我們在 $[-0.1, 0.1]$ 這個區間取 $1000$ 個點, 然後帶入 $sinc$ 函數的定義再把它畫出來:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_0.svg&#34; alt=&#34;svg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看起來真的很光滑!! 而且似乎當 $x$ 很靠近 $0$ 時, $sinc(x)$ 的值很靠近 $1$.&lt;/p&gt;

&lt;p&gt;接著我們取一個會越來越靠近 $0$ 的數列, 然後看一下當把 $sinc$ 函數在這個數列的點上取值時, 其值會不會越來越靠近 $1$.  我們取以下數列:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;20-element Array{Float64,1}:
 0.36787944117144233
 0.1353352832366127
 0.049787068367863944
 0.01831563888873418
 0.006737946999085467
 0.0024787521766663585
 0.0009118819655545162
 0.00033546262790251185
 0.00012340980408667956
 4.539992976248485e-5
 1.670170079024566e-5
 6.14421235332821e-6
 2.2603294069810542e-6
 8.315287191035679e-7
 3.059023205018258e-7
 1.1253517471925912e-7
 4.139937718785167e-8
 1.522997974471263e-8
 5.602796437537268e-9
 2.061153622438558e-9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算一下 $sinc$ 函數在這些點上面的值, 並觀察他的趨勢:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;20-element Array{Float64,1}:
 0.9775962588920379
 0.9969501878216637
 0.9995869258359702
 0.9999440904998019
 0.9999924333622158
 0.9999989759649225
 0.9999998614118859
 0.9999999812441376
 0.9999999974616701
 0.9999999996564743
 0.9999999999535089
 0.9999999999937081
 0.9999999999991485
 0.9999999999998848
 0.9999999999999845
 0.9999999999999979
 0.9999999999999997
 1.0
 1.0
 1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赫然發現算到後來就等於 $1$ 了!! 所以我們發現&lt;/p&gt;

&lt;p&gt;$$
\lim_{x\to 0} sinc(x) = \lim_{x\to 0} \frac{\sin(x)}{x} = 1.
$$&lt;/p&gt;

&lt;p&gt;不過有一點點詭異的是, 在剛剛的計算裡我們最多也只是取到離 $1$ 很近的點而已, 但是算出來的結果卻是 $1$. 難道不只是 $sinc(0)=1$, 我們也有 $sinc(2.061153622438558*10^{-9})=1$ 嗎?&lt;/p&gt;

&lt;p&gt;事實上並不是這樣. 電腦有所謂的捨入誤差(rounding error). 這是因為電腦需要用有限位數來表達無窮小數, 所以一定要捨棄後面的位數. 我們把算出來的數字減去 $1$ 看看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;20-element Array{Float64,1}:
 -0.02240374110796206
 -0.0030498121783363308
 -0.000413074164029803
 -5.590950019807028e-5
 -7.566637784228725e-6
 -1.0240350775125862e-6
 -1.3858811409583893e-7
 -1.8755862418728952e-8
 -2.5383298796199938e-9
 -3.435256523687258e-10
 -4.649114426769074e-11
 -6.291855925155687e-12
 -8.515410598874951e-13
 -1.1524114995609125e-13
 -1.554312234475219e-14
 -2.1094237467877974e-15
 -3.3306690738754696e-16
  0.0
  0.0
  0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們可以發現這個數字最小可以到大約 $10^{-16}$, 之後就變成 $0$ 了. 也就是說我們目前用個這個程式語言其捨入誤差大約就是 $10^{-16}$.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;

&lt;p&gt;稍微總結一下目前我們看到的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我們用程式跑數值發現 $sinc(x\to 0)=1$, 所以我們可以定義 sinc 函數為
$$
sinc(x) =
\begin{cases}
\frac{\sin(x)}{x}, \quad x\ne 0 \\&lt;br /&gt;
1, \quad x=0.
\end{cases}
$$
在這樣的定義之下 $sinc$ 函數是個&lt;code&gt;連續函數&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在數值計算上有所謂的捨入誤差, 這是用有限位元來表達無限位數一定會有的差異.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更多關於 $sinc$ 函數的性質可以參考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Sinc_function&#34; target=&#34;_blank&#34;&gt;wiki&lt;/a&gt; 上的介紹.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>
