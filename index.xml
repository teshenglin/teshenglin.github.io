<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Te-Sheng Lin</title>
    <link>https://teshenglin.github.io/</link>
      <atom:link href="https://teshenglin.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Te-Sheng Lin</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 03 Dec 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://teshenglin.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Te-Sheng Lin</title>
      <link>https://teshenglin.github.io/</link>
    </image>
    
    <item>
      <title>Least square method 1</title>
      <link>https://teshenglin.github.io/post/2023_la_least_square_1/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_la_least_square_1/</guid>
      <description>&lt;h1 id=&#34;最小平方法-1&#34;&gt;最小平方法 1&lt;/h1&gt;
&lt;p&gt;給定一個矩陣 $A$ 以及一個向量 $b$, 我們想要找到一個向量 $x$ 使得 $\|Ax - b\|^2$ 最小.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$$
A\in M_{m\times n}, \quad b \in M_{m\times 1}, \quad x\in M_{m\times 1}.
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們定義 $\hat{x}$ 為找到的那個解, 也就是說, 我們要解以下這個問題&lt;/p&gt;
&lt;p&gt;$$
\newcommand{\argmin}{\arg\min}
\tag{1}
\hat{x} = \argmin_{x\in\mathbb{R}^n}\|Ax - b\|^2.
$$&lt;/p&gt;
&lt;h2 id=&#34;1-notations&#34;&gt;1. Notations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$C(A)$: column space of $A$.
$$
C(A) = \{Ax  |  x\in\mathbb{R}^n\}\subseteq\mathbb{R}^m.
$$&lt;/li&gt;
&lt;li&gt;$N(A)$: null space of $A$.
$$
N(A) = \{x\in\mathbb{R}^n | Ax = 0\}\subseteq\mathbb{R}^n.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-最小平方解與投影子空間&#34;&gt;2. 最小平方解與投影子空間&lt;/h2&gt;
&lt;p&gt;要找到最小平方解首先我們做個重要的觀察.&lt;/p&gt;
&lt;p&gt;事實上, 以下三件事是等價敘述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;給定 $A$ 與 $b$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\in\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.&lt;/li&gt;
&lt;li&gt;將 $b$ 投影到 $C(A)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因為 $A\hat{x}$ 可以視為 $A$ 的 columns 的線性組合. 而任何在 column space $C(A)$ 裡的向量也都可以被寫成 $Ax$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以若我們知道怎樣解其中一個, 另外兩個問題就同時解出來了. 我們先證明以下這個 lemma.&lt;/p&gt;
&lt;h3 id=&#34;lemma&#34;&gt;Lemma&lt;/h3&gt;
&lt;p&gt;任意給定一個向量 $b\in\mathbb{R}^m$, 如果我們能夠找到一個向量 $\hat{b}\in\mathbb{R}^m$ 滿足 $(\hat{b}-b)\perp C(A)$, 那這個向量就會是 $b$ 在 $C(A)$ 的投影向量,
$$
\tag{2}
\hat{b} = \arg\min_{\hat{b}\in\mathbb{R}^m}\|\hat{b}-b\|^2.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pf:&lt;/p&gt;
&lt;p&gt;Let $\hat{b}\in C(A)\subseteq\mathbb{R}^m$ such that $(\hat{b}-b)\perp C(A)$.&lt;/p&gt;
&lt;p&gt;Given $p\in C(A)$, we define $e = p - \hat{b}$ and we have $e\in C(A)$.&lt;/p&gt;
&lt;p&gt;$$
\tag{3}
\begin{align}
\|p - b\|^2 &amp;amp;= &amp;lt;p-b, p-b&amp;gt; \\&lt;br&gt;
&amp;amp;= &amp;lt;\hat{b} + e - b, \hat{b} + e - b&amp;gt;\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2 + 2&amp;lt;\hat{b} - b, e&amp;gt; + \|e\|^2\\&lt;br&gt;
&amp;amp;= \|\hat{b} - b\|^2  + \|e\|^2,
\end{align}
$$&lt;/p&gt;
&lt;p&gt;where we have used the fact that $(\hat{b}-b)\perp C(A)$ and $e\in C(A)$, so that $&amp;lt;\hat{b} - b, e&amp;gt;=0$.&lt;/p&gt;
&lt;p&gt;Therefore, for any $p\in C(A)$, $\|p - b\|^2 \ge \|\hat{b} - b\|^2$, and the minimal of $\|p - b\|^2$ occurs when $\|e\|^2=0$, that is when $p=\hat{b}$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由這 lemma 我們知道 $\hat{b}$ 可以從 $(\hat{b}-b)\perp C(A)$ 這個條件下手, 也就是要找一個 $\hat{b}$ 滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{4}
A^T(\hat{b}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;那因為 $\hat{b}\in C(A)$, 一定存在某個 $\hat{x}\in\mathbb{R}^n$ 使得 $A\hat{x}=\hat{b}$. 因此 (4) 就變成&lt;/p&gt;
&lt;p&gt;$$
\tag{5}
A^T(A\hat{x}-b)=0.
$$&lt;/p&gt;
&lt;p&gt;展開就知道 $\hat{x}$ 要滿足&lt;/p&gt;
&lt;p&gt;$$
\tag{6}
A^TA\hat{x}=A^Tb.
$$&lt;/p&gt;
&lt;p&gt;因此, 我們剛剛說的事其解就是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一個向量 $\hat{x}\subseteq\mathbb{R}^n$, 使得 $\|A\hat{x}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{x}$ 滿足 $A^TA\hat{x}=A^Tb$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;找到一個向量 $\hat{b}\in C(A)\subseteq\mathbb{R}^m$, 使得 $\|\hat{b}-b\|^2$ 最小.
&lt;ul&gt;
&lt;li&gt;$\hat{b}$ 滿足 $(\hat{b}-b)\perp C(A)$, 或是 $A^T(\hat{b}-b)=0$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以上推導都是充分條件, 就是如果我們解出 (4) 或 (6), 那他們就一定是 (1) 的解.&lt;/li&gt;
&lt;li&gt;以上推導跟 $A$ 的 column 有沒有 linearly independent 無關.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-independent-columns&#34;&gt;3. Independent columns&lt;/h2&gt;
&lt;p&gt;如果 $A$ 的 column 是 linearly independent, 那 $A^TA$ 就可逆, 然後我們就可以把 $\hat{x}$ 顯式的寫下來, 就得到
$$
\tag{7}
\hat{x} = (A^TA)^{-1}A^Tb.
$$
在這情況下, $b$ 在 $C(A)$ 的投影也可以寫下來, 就是
$$
\tag{8}
\hat{b} = A(A^TA)^{-1}A^Tb.
$$
或是我們可以更近一步定義投影到 $C(A)$ 的投影矩陣, 就是
$$
\tag{9}
P = A(A^TA)^{-1}A^T.
$$&lt;/p&gt;
&lt;h2 id=&#34;4-independent-columns&#34;&gt;4. Independent columns&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;$A^TA$ 不可逆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;case-1&#34;&gt;Case 1&lt;/h3&gt;
&lt;p&gt;假設 $m&amp;lt;n$ 並且 $\text{rank}(A)=n$.&lt;/p&gt;
&lt;p&gt;在這情況下, $A$ 的 columns 不是 linearly independent, $A^TA$ 不可逆, 並且 $N(A)\ne{0}$. 所以若有一個最小平方解, 那就還會有無窮多個. 不過我們至少先找到一個再說.&lt;/p&gt;
&lt;p&gt;因為 $A$ 的 rows 會線性獨立, 因此我們對 $A^T$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{10}
A^T = QR,
$$
where $Q^TQ= I$, $Q\in M_{n\times m}$ and $R\in M_{m\times m}$. 並且我們知道 $R$ 是可逆矩陣.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{11}
QRR^TQ^T \hat{x} = QRb.
$$&lt;/p&gt;
&lt;p&gt;兩邊同乘 $(R^T)^{-1}R^{-1}Q^T$ 我們得到&lt;/p&gt;
&lt;p&gt;$$
\tag{12}
Q^T \hat{x} = (R^T)^{-1}b.
$$&lt;/p&gt;
&lt;p&gt;最後, 如果我們選擇&lt;/p&gt;
&lt;p&gt;$$
\tag{13}
\hat{x} = Q(R^T)^{-1}b,
$$&lt;/p&gt;
&lt;p&gt;那可以很容易驗證 (12) 是滿足的. 也就是說 (13) 會是這個問題的一個解.&lt;/p&gt;
&lt;h3 id=&#34;case-2&#34;&gt;Case 2&lt;/h3&gt;
&lt;p&gt;假設 $\text{rank}(A)=r$, 並且 $r&amp;lt;m$, $r&amp;lt;n$.&lt;/p&gt;
&lt;p&gt;我們對 $A$ 做 (reduced) QR 分解得到&lt;/p&gt;
&lt;p&gt;$$
\tag{14}
A = QR,
$$
where $Q^TQ= I$, $Q\in M_{m\times r}$ and $R\in M_{r\times n}$.&lt;/p&gt;
&lt;p&gt;接著我們知道最小平方解必須滿足 (6), 也就是&lt;/p&gt;
&lt;p&gt;$$
\tag{15}
R^TR \hat{x} = R^TQ^Tb.
$$&lt;/p&gt;
&lt;p&gt;不過要注意的是這裡 $R^TR\in M_{n\times n}$ 不是一個可逆矩陣, 所以操作上無法兩邊同乘其反矩陣. 但是好消息是 $R^T$ 的 columns 是線性獨立的, 所以我們會有&lt;/p&gt;
&lt;p&gt;$$
\tag{16}
R \hat{x} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;接著我們試著在 row space 裡找解. 假設 $\hat{x} = R^T \hat{y}$, $\hat{y}\in\mathbb{R}^r$, 那 (16) 可以改寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{17}
RR^T \hat{y} = Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;這樣, 由於 $RR^T\in M_{r\times r}$ 並且可逆, 我們就有 $\hat{y} = (RR^T)^{-1}Q^Tb$. 最後&lt;/p&gt;
&lt;p&gt;$$
\tag{18}
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;p&gt;一樣可以很容易驗證 (16) 是滿足的. 也就是說 (18) 會是這個問題的一個解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; QR 的這整套做法也適用於 $A$ 的 columns 線性獨立的情形. 而且在這情形之下的 $R$ 矩陣會是個可逆方陣, 因此有 $(RR^T)^{-1} = (R^T)^{-1}R^{-1}$. 代入之後得到&lt;/p&gt;
&lt;p&gt;$$
\tag{19}
\hat{x} = R^{-1}Q^Tb.
$$&lt;/p&gt;
&lt;h2 id=&#34;5-conclusion&#34;&gt;5. Conclusion&lt;/h2&gt;
&lt;p&gt;我們考慮以下最小平方法問題&lt;/p&gt;
&lt;p&gt;$$
\min_{x\in\mathbb{R}^n}|Ax - b|^2.
$$&lt;/p&gt;
&lt;p&gt;並且我們令最佳解為 $\hat{x}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $A$ 的 columns 線性獨立
$$
\hat{x} = (A^TA)^{-1}A^Tb.
$$
&lt;ul&gt;
&lt;li&gt;如果對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{n\times n}$,
$$
\hat{x} = R^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 $A$ 的 columns 線性相依
&lt;blockquote&gt;
&lt;p&gt;則有無窮多解, 以下是一特解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;對 $A$ 做 (reduced) QR, $A=QR$, 並且 $Q^TQ=I_{r\times r}$,
$$
\hat{x} = R^T(RR^T)^{-1}Q^Tb.
$$&lt;/li&gt;
&lt;li&gt;或是若 $\text{rank}(A)=n$, 則可對 $A^T$ 做 (reduced) QR, $A^T=QR$, 並且 $Q^TQ=I_{m\times m}$,
$$
\hat{x} = Q(R^T)^{-1}b.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Trace, determinant 與 eigenvalue 的關係</title>
      <link>https://teshenglin.github.io/post/2023_la_det_trace_zh/</link>
      <pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_la_det_trace_zh/</guid>
      <description>&lt;h2 id=&#34;方陣-a-的行列式等於其特徵值相乘&#34;&gt;方陣 A 的行列式等於其特徵值相乘&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Determinant of A equals to the product of its eigenvalues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定一個 $n\times n$ 的方陣 $A$, 我們定義一個變數為 $\lambda$ 的函數 $P(\lambda)$ 如下:
$$
\tag{1}
P(\lambda) = det(\lambda I-A).
$$
根據行列式的算法我們馬上知道 $P$ 其實就是個 $\lambda$ 的 $n$ 次多項式, 可以寫成
$$
\tag{2}
P(\lambda) = \lambda^n + c_{n-1}\lambda^{n-1}\cdots + c_1\lambda + c_0.
$$
因此這個多項式必有 $n$ 個根 $\lambda_1, \cdots, \lambda_n$ (有可能是實根, 虛根, 或重根, 不過必有 $n$ 個), 所以我們可以將 $P$ 改寫為
$$
\tag{3}
P(\lambda) = (\lambda - \lambda_1)\cdots (\lambda - \lambda_n).
$$&lt;/p&gt;
&lt;p&gt;最後, 我們算一下 $P(0)$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 (1)
$$
\tag{4}
P(0) = det(-A) = (-1)^n det(A).
$$&lt;/li&gt;
&lt;li&gt;由 (3)
$$
\tag{5}
P(0) = (- \lambda_1)\cdots (- \lambda_n) = (-1)^n\lambda_1\cdots\lambda_n.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此, 由 (4) 以及 (5),
$$
det(A) = \lambda_1\cdots\lambda_n.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;方陣-a-的跡httpszhwikipediaorgzh-tw跡等於其特徵值相加&#34;&gt;方陣 A 的
&lt;a href=&#34;https://zh.wikipedia.org/zh-tw/%e8%b7%a1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跡&lt;/a&gt;等於其特徵值相加&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Trace of A equals to the sum of its eigenvalues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定一個 $n\times n$ 的方陣 $A$:
$$
\tag{6}
A = \begin{bmatrix}
a_{11} &amp;amp; \cdots &amp;amp; a_{1n}\\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
a_{n1} &amp;amp; \cdots &amp;amp; a_{nn}
\end{bmatrix}.
$$&lt;/p&gt;
&lt;p&gt;因此我們有
$$
\tag{7}
\lambda I - A =
\begin{bmatrix}
\lambda - a_{11} &amp;amp; -a_{12} &amp;amp; \cdots &amp;amp; -a_{1n} \\&lt;br&gt;
-a_{21} &amp;amp; \lambda-a_{22} &amp;amp; \cdots &amp;amp; -a_{2n} \\&lt;br&gt;
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;
-a_{n1} &amp;amp; -a_{n2} &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}.
$$&lt;/p&gt;
&lt;p&gt;接著我們來算 $det(\lambda I - A)$. 我們直接沿著第一行使用降階法 (
&lt;a href=&#34;https://en.wikipedia.org/wiki/Laplace_expansion&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cofactor expansion&lt;/a&gt;):
$$
\tag{8}
det(\lambda I - A) =
(\lambda - a_{11})C_{11} +(- a_{21}) C_{21}+ \cdots,
$$
其中
$$
\tag{9}
C_{11} =
\begin{bmatrix}
\lambda-a_{22} &amp;amp; \cdots &amp;amp; -a_{2n}\\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
-a_{n2} &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}_{(n-1)\times(n-1)},
$$
以及
$$
\tag{10}
C_{21} =
\begin{bmatrix}
-a_{12} &amp;amp; -a_{13} &amp;amp; \cdots &amp;amp; -a_{1n}\\&lt;br&gt;
-a_{32} &amp;amp; \lambda-a_{33} &amp;amp; \cdots &amp;amp; -a_{3n}\\&lt;br&gt;
\vdots &amp;amp;  \vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
-a_{n2} &amp;amp; \cdots &amp;amp;  \cdots &amp;amp; \lambda - a_{nn}
\end{bmatrix}_{(n-1)\times(n-1)}.
$$&lt;/p&gt;
&lt;p&gt;簡單觀察可以發現 $C_{21}$ 是個最多 $n-2$ 次的多項式. 並且對所有 $k&amp;gt;1$ 的 $C_{k1}$, 他們全都是最多 $n-2$ 次的多項式. 因此我們就有
$$
\tag{11}
det(\lambda I - A) = (\lambda - a_{11})C_{11} + \hat{Q}_{n-2}(\lambda),
$$
其中 $\hat{Q}_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;接著我們對 $C_{11}$ 做展開, 並且用以上的論述一直做下去. 最終我們就會得到
$$
\tag{12}
det(\lambda I - A) = (\lambda - a_{11})(\lambda - a_{22})\cdots (\lambda - a_{nn}) + \tilde{Q}_{n-2}(\lambda),
$$
其中 $\tilde{Q}_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;我們接著把 (12) 展開, 得到
$$
\tag{13}
det(\lambda I - A) = \lambda^n - (a_{11} + a_{22} + \cdots + a_{nn})\lambda^{n-1}  + Q_{n-2}(\lambda),
$$
其中 $Q_{n-2}(\lambda)$ 是個最多 $n-2$ 次的多項式.&lt;/p&gt;
&lt;p&gt;另一方面, 我們也可以同樣把 (3) 展開, 得到
$$
\tag{14}
P(\lambda) = \lambda^n - (\lambda_1 + \lambda_2 + \cdots + \lambda_n)\lambda^{n-1}  + \cdots.
$$
因此, 由 (13) 以及 (14),
$$
a_{11} + a_{22} + \cdots + a_{nn} = \lambda_1 + \lambda_2 + \cdots + \lambda_n.
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Euler equations</title>
      <link>https://teshenglin.github.io/post/2023_ode_euler_en/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_ode_euler_en/</guid>
      <description>&lt;h1 id=&#34;euler-equations&#34;&gt;Euler equations&lt;/h1&gt;
&lt;p&gt;Here, we consider Euler equations:
$$
\tag{1}
x^2 y&#39;&#39; + a xy&#39; + by = 0, \quad x\ne 0,
$$
where $a$, $b$ are constants.&lt;/p&gt;
&lt;h2 id=&#34;characteristic-polynomial&#34;&gt;characteristic polynomial&lt;/h2&gt;
&lt;p&gt;Assuming that $y = x^r$ in (1) we obtain&lt;/p&gt;
&lt;p&gt;$$
\left[r(r-1) + a r + b\right] x^r = 0.
$$&lt;/p&gt;
&lt;p&gt;Since $x\ne 0$, $x^r\ne 0$, so the equation reduces to&lt;/p&gt;
&lt;p&gt;$$
\tag{2}
r(r-1) + a r + b = 0.
$$&lt;/p&gt;
&lt;p&gt;(2) is called the characteristic polynomial of Euler equations. In principle, if (2) has a root $r_1$, then $y = x^{r_1}$ is a solution to (1).&lt;/p&gt;
&lt;p&gt;But, Euler equations is a 2nd-order linear homogeneous ODE that has two linearly independent solutions. In the following we aim to find them all.&lt;/p&gt;
&lt;h3 id=&#34;a-two-distinct-real-roots&#34;&gt;A. Two distinct real roots&lt;/h3&gt;
&lt;p&gt;Auppose (2) has two roots $r = r_1$, $r_2$, the general solution of (1) can be written as&lt;/p&gt;
&lt;p&gt;$$
\tag{3}
y(x) = c_1 x^{r_1} + c_2 x^{r_2},
$$
where $c_1$, $c_2$ are constant.&lt;/p&gt;
&lt;h4 id=&#34;remark&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;To calculate $x^{r}$, we usually use the following identity
$$
x^r = e^{r\ln x},
$$
so that, even if $r\in Q^c$, $x^r$ can be computed easily.&lt;/p&gt;
&lt;h3 id=&#34;b-two-complex-roots&#34;&gt;B. Two complex roots&lt;/h3&gt;
&lt;p&gt;Suppose (2) has two complex roots $r = \lambda \pm i\mu$, then $x^{\lambda \pm i\mu}$ is a solution. But what we want is real solutions, so we rewrite it as&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
x^{\lambda + i\mu} &amp;amp;= e^{(\lambda + i\mu)\ln x} \\&lt;br&gt;
&amp;amp;= e^{\lambda \ln x}\left[\cos(\mu\ln x) + i\sin(\mu\ln x)\right] \\&lt;br&gt;
&amp;amp;= x^r\cos(\mu\ln x) + ix^r\sin(\mu\ln x).
\end{align}
$$&lt;/p&gt;
&lt;p&gt;We know that both the real and imaginary part are the solution to (1). Therefore, the general solution to (1) is&lt;/p&gt;
&lt;p&gt;$$
\tag{4}
y(x) = c_1 x^{\lambda}\cos(\mu\ln x) + c_2 x^{\lambda}\sin(\mu\ln x),
$$
where $c_1$, $c_2$ are constant.&lt;/p&gt;
&lt;h3 id=&#34;c-only-one-root-with-multiplicity-2&#34;&gt;C. Only one root with multiplicity 2&lt;/h3&gt;
&lt;p&gt;Suppose there is only one root with multiplicity $2$, the characteristic polynomial must be in the form $(r-r_1)^2$, so that, by direct comparison with (2), we have $a = 1-2r_1$ and $b=r^2_1$. That is, Euler equation is given by&lt;/p&gt;
&lt;p&gt;$$
\tag{5}
x^2 y&#39;&#39; + (1 - 2r_1) xy&#39; + r^2_1 y = 0.
$$&lt;/p&gt;
&lt;p&gt;On the other hand, $y_1 = x^{r_1}$ must be a solution, and it is easy to check that $y_1$ satisfies the following 1st-order ODE:&lt;/p&gt;
&lt;p&gt;$$
\tag{6}
\left(x\frac{d}{dx} - r_1\right) y = 0.
$$&lt;/p&gt;
&lt;p&gt;We have the following observations:&lt;/p&gt;
&lt;h4 id=&#34;observation-1&#34;&gt;Observation 1&lt;/h4&gt;
&lt;p&gt;Use (6) and the fact that $r_1$ is a root with multiplicity $2$, one can easily see that (5) can be factored as&lt;/p&gt;
&lt;p&gt;$$
\tag{7}
\left(x\frac{d}{dx} - r_1\right)\left(x\frac{d}{dx} - r_1\right) y = 0.
$$&lt;/p&gt;
&lt;h4 id=&#34;observation-2&#34;&gt;Observation 2&lt;/h4&gt;
&lt;p&gt;Suppose we can find $y_2(x)$ such that&lt;/p&gt;
&lt;p&gt;$$
\tag{8}
\left(x\frac{d}{dx} - r_1\right) y_2 = cy_1,
$$
for some constant $c$, then we must have&lt;/p&gt;
&lt;p&gt;$$
\left(x\frac{d}{dx} - r_1\right)\left(x\frac{d}{dx} - r_1\right) y_2 = \left(x\frac{d}{dx} - r_1\right) cy_1 = 0.
$$&lt;/p&gt;
&lt;h4 id=&#34;observation-3&#34;&gt;Observation 3&lt;/h4&gt;
&lt;p&gt;Based on the idea of variation of parameters, since we have one solution being $x^{r_1}$, we can assume that $y_2 =  x^{r_1}u(x)$ and pluging-in to (8). It turns out that $u(x)$ should satisfy&lt;/p&gt;
&lt;p&gt;$$
\tag{9}
xu&#39; = cu,
$$
and the solution is $u(x) = c\ln(x)$. Therefore, we have $y_2=x^{r_1}\ln(x)$.&lt;/p&gt;
&lt;p&gt;Finally, the general solution is&lt;/p&gt;
&lt;p&gt;$$
\tag{10}
y(x) = c_1 x^{r_1} + c_2 x^{r_1}\ln(x),
$$
where $c_1$, $c_2$ are constant.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Euler equations</title>
      <link>https://teshenglin.github.io/post/2023_ode_euler_zh/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_ode_euler_zh/</guid>
      <description>&lt;h1 id=&#34;euler-equations&#34;&gt;Euler equations&lt;/h1&gt;
&lt;p&gt;這裡我們想要解 Euler equations, 長相如下:
$$
\tag{1}
x^2 y&#39;&#39; + a xy&#39; + by = 0,
$$
其中 $a$, $b$ 為常數.&lt;/p&gt;
&lt;h2 id=&#34;characteristic-polynomial&#34;&gt;characteristic polynomial&lt;/h2&gt;
&lt;p&gt;假設 $y = x^r$, 代入 (1) 可以得到&lt;/p&gt;
&lt;p&gt;$$
\left[r(r-1) + a r + b\right] x^r = 0.
$$&lt;/p&gt;
&lt;p&gt;假設 $x\ne 0$, 所以 $x^r\ne 0$, 因此上式可以簡化為&lt;/p&gt;
&lt;p&gt;$$
\tag{2}
r(r-1) + a r + b = 0.
$$&lt;/p&gt;
&lt;p&gt;(2) 這個方程就是 Euler equations 的特徵多項式. 理論上如果 (2) 的根是 $r_1$, 那 $y = x^{r_1}$ 就是方程式的解.&lt;/p&gt;
&lt;p&gt;不過 Euler equations 是個二階線性常微分方程, 應該要有兩個線性獨立的解. 因此接下來我們就要討論在各種&amp;quot;根&amp;quot;的情況下 (1) 的通解長相為何.&lt;/p&gt;
&lt;h3 id=&#34;a-兩相異實根&#34;&gt;A. 兩相異實根&lt;/h3&gt;
&lt;p&gt;假設 (2) 有兩個相異實根 $r = r_1$, $r_2$, 那(1) 的通解就可以被寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{3}
y(x) = c_1 x^{r_1} + c_2 x^{r_2},
$$
其中 $c_1$, $c_2$ 為常數.&lt;/p&gt;
&lt;h4 id=&#34;備註&#34;&gt;備註:&lt;/h4&gt;
&lt;p&gt;通常為了計算 $x^{r}$ 我們會使用以下恆等式&lt;/p&gt;
&lt;p&gt;$$
x^r = e^{r\ln x}.
$$
這樣即使 $r$ 是無理數, 我們也可以輕易地計算 $x^r$.&lt;/p&gt;
&lt;h3 id=&#34;b-兩複數根&#34;&gt;B. 兩複數根&lt;/h3&gt;
&lt;p&gt;假設 (2) 有兩個複數根 $r = \lambda \pm i\mu$, 那理論上  $x^{\lambda \pm i\mu}$ 就是一個解. 不過我們要的是實數解, 因此需要稍微再處理一下.&lt;/p&gt;
&lt;p&gt;首先我們有&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
x^{\lambda + i\mu} &amp;amp;= e^{(\lambda + i\mu)\ln x} \\&lt;br&gt;
&amp;amp;= e^{\lambda \ln x}\left[\cos(\mu\ln x) + i\sin(\mu\ln x)\right] \\&lt;br&gt;
&amp;amp;= x^r\cos(\mu\ln x) + ix^r\sin(\mu\ln x).
\end{align}
$$&lt;/p&gt;
&lt;p&gt;另外我們知道實部跟虛部都會是 (1) 的解. 因此, (1) 的通解就可以被寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{4}
y(x) = c_1 x^{\lambda}\cos(\mu\ln x) + c_2 x^{\lambda}\sin(\mu\ln x),
$$
其中 $c_1$, $c_2$ 為常數.&lt;/p&gt;
&lt;h3 id=&#34;c-一重根&#34;&gt;C. 一重根&lt;/h3&gt;
&lt;p&gt;假設 (2) 有一個重根, 那特徵多項式一定是長這樣 $(r-r_1)^2$. 直接跟 (2) 做比較我們就會發現 $a = 1-2r_1$, $b=r^2_1$. 也就是說, Euler equation 會長得像這樣子&lt;/p&gt;
&lt;p&gt;$$
\tag{5}
x^2 y&#39;&#39; + (1 - 2r_1) xy&#39; + r^2_1 y = 0.
$$&lt;/p&gt;
&lt;p&gt;接著我們來對這個式子做因式分解. 首先觀察, 由於 $y_1 = x^{r_1}$ 一定是個解, 因此我們來看一下這個解會滿足的方程式長怎樣. 直接微分得到&lt;/p&gt;
&lt;p&gt;$$
\frac{d}{dx} y_1 = r_1 x^{r_1-1} = \frac{r_1}{x} x^{r_1} = \frac{r_1}{x} y_1.
$$&lt;/p&gt;
&lt;p&gt;也就是說 $y_1$ 會滿足以下這個一階常微分方程&lt;/p&gt;
&lt;p&gt;$$
\tag{6}
\left(x\frac{d}{dx} - r_1\right) y = 0.
$$&lt;/p&gt;
&lt;p&gt;接著我們觀察以下幾件事:&lt;/p&gt;
&lt;h4 id=&#34;observation-1&#34;&gt;Observation 1&lt;/h4&gt;
&lt;p&gt;利用 (6) 以及 $r_1$ 是個重根, 就可以很快看出 (5) 可以被分解成&lt;/p&gt;
&lt;p&gt;$$
\tag{7}
\left(x\frac{d}{dx} - r_1\right)\left(x\frac{d}{dx} - r_1\right) y = 0.
$$&lt;/p&gt;
&lt;h4 id=&#34;observation-2&#34;&gt;Observation 2&lt;/h4&gt;
&lt;p&gt;假設我們能找到另一個函數 $y_2(x)$, 並且使得&lt;/p&gt;
&lt;p&gt;$$
\tag{8}
\left(x\frac{d}{dx} - r_1\right) y_2 = cy_1,
$$
其中 $c$ 是個常數. 那我們就可以得到&lt;/p&gt;
&lt;p&gt;$$
\left(x\frac{d}{dx} - r_1\right)\left(x\frac{d}{dx} - r_1\right) y_2 = \left(x\frac{d}{dx} - r_1\right) cy_1 = 0.
$$&lt;/p&gt;
&lt;h4 id=&#34;observation-3&#34;&gt;Observation 3&lt;/h4&gt;
&lt;p&gt;根據 method of variation of parameters 的想法, 如果我們已經得到一個解 $x^{r_1}$, 那另一個解可以直接假設為 $y_2 = x^{r_1}u(x)$. 將這個假設代入 (8) 得到 $u$ 所要滿足的方程為&lt;/p&gt;
&lt;p&gt;$$
\tag{9}
xu&#39; = cu.
$$&lt;/p&gt;
&lt;p&gt;這個方程的解為 $u(x) = c\ln(x)$. 因此, 我們得到 $y_2=x^{r_1}\ln(x)$.&lt;/p&gt;
&lt;p&gt;最後, (1) 的通解就可以被寫為&lt;/p&gt;
&lt;p&gt;$$
\tag{10}
y(x) = c_1 x^{r_1} + c_2 x^{r_1}\ln(x),
$$
其中 $c_1$, $c_2$ 為常數.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>A cusp-capturing PINN for elliptic interface problems</title>
      <link>https://teshenglin.github.io/publication/23_jcp_tlhl/</link>
      <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/23_jcp_tlhl/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Analysis and classification of coffee beans using single coffee bean mass spectrometry with machine learning strategy</title>
      <link>https://teshenglin.github.io/publication/23_jc_tchlc/</link>
      <pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/23_jc_tchlc/</guid>
      <description></description>
    </item>
    
    <item>
      <title>An efficient neural-network and finite-difference hybrid method for elliptic interface problems with applications</title>
      <link>https://teshenglin.github.io/publication/23_cicp_hltl/</link>
      <pubDate>Sun, 07 May 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/23_cicp_hltl/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Power method with Rayleigh Quotient</title>
      <link>https://teshenglin.github.io/post/2023_power_method_3/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_3/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;假設&#34;&gt;假設&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;$A$ 是一個對稱矩陣&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;演算法-power-method-with-rayleigh-quotient&#34;&gt;演算法: Power method with Rayleigh Quotient&lt;/h2&gt;
&lt;p&gt;Iterate until convergence:
$$
\tag{1}
\begin{align}
\hat{x}^{(k+1)} &amp;amp;= Ax^{(k)}\\&lt;br&gt;
\lambda^{(k+1)} &amp;amp;= x^{(k)T}\hat{x}^{(k+1)}\\&lt;br&gt;
x^{(k+1)} &amp;amp;= \hat{x}^{(k+1)}/|\hat{x}^{(k+1)}|_2
\end{align}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;收斂性證明&#34;&gt;收斂性證明&lt;/h2&gt;
&lt;p&gt;由於 $A$ 是個對稱矩陣, 因此存在一組 orthonormal 的 eigenvectors $\{v_1, \cdots, v_n\}$, 使得 $v_i^Tv_j=0$ if $i\ne j$, and $v_i^Tv_i=0$.&lt;/p&gt;
&lt;p&gt;任意給定初始值 $x^{(0)}\ne 0$, 他可以被 eigenvectors 組出來, 因此我們有
$$
x^{(0)} = \alpha_1 v_1 + \sum^n_{i=2} \alpha_i v_i,
$$
並且
$$
\tag{2}A^kx^{(0)} = \lambda_1^k\left[\alpha_1 v_1 + \sum^n_{i=2} \alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right].
$$
另一方面, 從迭代式 (1) 可以看出我們一直不斷地把得到的向量 normalize, 使其為單位長, 因此我們必定有
$$
x^{(k)} = \frac{A^kx^{(0)}}{|A^kx^{(0)}|_2}.
$$
將 (2) 代入得到
$$
\tag{3}
\begin{align}
x^{(k)}
&amp;amp;= \frac{\lambda_1^k\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{\lambda_1^{2k}\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}} \\&lt;br&gt;
&amp;amp;= \frac{\left[\alpha_1v_1 + \sum^n_{i=2}\alpha_i \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{\alpha^2_1 + \sum^n_{i=2}\alpha^2_i \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}}}\\&lt;br&gt;
&amp;amp;=\frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{\sqrt{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}}},
\end{align}
$$
其中我們用到了 $\{v_1, \cdots, v_n\}$ 是 orthonormal basis 這個事實.&lt;/p&gt;
&lt;p&gt;接著我們可以算 eigenvalue, 將 (3) 代入:
$$
\begin{align}
\lambda^{(k+1)} &amp;amp;= x^{(k)T}\hat{x}^{(k+1)} = x^{(k)T}(Ax^{(k)}) \\&lt;br&gt;
&amp;amp;= \frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[\lambda_1v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \lambda_i\left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^kv_i\right]^T\left[v_1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right) \left(\frac{\lambda_i}{\lambda_1}\right)^{k+1}v_i\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k+1}\right]}{1 + \sum^n_{i=2}\left(\frac{\alpha_i}{\alpha_1}\right)^2 \left(\frac{\lambda_i}{\lambda_1}\right)^{2k}} \\&lt;br&gt;
&amp;amp;= \lambda_1
\frac{\left[1 + O \left(\epsilon^{2k+1}\right)\right]}{1 + O \left(\epsilon^{2k}\right)} \\&lt;br&gt;
&amp;amp;= \lambda_1 + O\left(\epsilon^{2k}\right),
\end{align}
$$
where $\epsilon=|\lambda_2/\lambda_1|$.&lt;/p&gt;
&lt;p&gt;因此這個迭代式, &lt;strong&gt;power method with Rayleigh quotient for symmetric matrix&lt;/strong&gt;, 會是線性收斂, 並且其 rate of convergence 是 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;final-remark&#34;&gt;Final remark&lt;/h2&gt;
&lt;p&gt;若使用基本的 power 迭代, 就是每次將得到得向量單位化, 如以下方式:&lt;/p&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while diff &amp;gt; Tol
    v = A*u
    lambda = norm(v)
    u = v/lambda
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 $A$ 是個對稱矩陣, 會發現這個迭代式其收斂性為 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;p&gt;這是因爲, 若 $Au=\lambda u$,
$$
\|v\|_2 = \|Au\|_2 = \sqrt{(Au)^T(Au)} = |\lambda|.
$$
利用跟上面類似的推導手法即可證明收斂性為 $\left(\frac{\lambda_2}{\lambda_1}\right)^2$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Power method - deflation</title>
      <link>https://teshenglin.github.io/post/2023_power_method_2/</link>
      <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_2/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;deflation&#34;&gt;Deflation&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;對一方陣 $A$, 假設我們以 power iteration 找到了一組 eigenvalue/eigenvector, $\lambda$ and $v$, 使得 $Av = \lambda v$. 那要怎麼找下一組呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-matrix-tranformation&#34;&gt;1. Matrix tranformation&lt;/h2&gt;
&lt;p&gt;假設能找到一個向量 $x$ 使 $x^T v = 1$, 則我們定義
$$
\tag{1} B = A - \lambda v x^T,
$$
並且以 $B$ 來找 eigenvalue/eigenvector. 那 $A$ 與 $B$ 之間有什麼關係呢?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$B$ 的一組 eigenvalue/eigenvector 為 $0$ 與 $v$, 滿足 $Bv = 0v$.&lt;/li&gt;
&lt;li&gt;$B$ 其他所有的 eigenvalues 都跟 $A$ 一樣.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pf-of-1&#34;&gt;pf of 1:&lt;/h3&gt;
&lt;p&gt;$$
Bv = (A - \lambda v x^T)v = Av - \lambda v (x^Tv) = Av - \lambda v=0.
$$&lt;/p&gt;
&lt;h3 id=&#34;pf-of-2&#34;&gt;pf of 2:&lt;/h3&gt;
&lt;p&gt;假設 $w$ 是 $A$ 的 left-eigenvector, 其 eigenvalue 為 $\lambda_2\ne \lambda$, 滿足 $w^TA = \lambda_2w^T$, 則我們知道 $w^Tv=0$, 並且
$$
w^TB = w^T(A - \lambda v x^T) = w^TA - \lambda (w^Tv)x^T = w^TA = \lambda_2w^T.
$$
因此 $\lambda_2$ 亦為 $B$ 的 eigenvalue.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;所以我們會利用找 $B$ 的 eigenvalue 來找 $A$ 的 eigenvalue.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;那假設我們找到 $B$ 的 eigenvalue 跟 eigenvector 了, 稱之為 $\lambda_2$ 以及 $u_2$, 那我們知道 $\lambda_2$ 也是 $A$ 的 eigenvalue, 不過其相對應的 eigenvector 是誰呢?&lt;/p&gt;
&lt;p&gt;若 $B$ 有 eigenvalues $0,\lambda_2, \cdots, \lambda_n$ 以及 eigenvectors $v, u_2, u_3, \cdots, u_n$, 則
$$
\tag{2} v_i = (\lambda_i-\lambda) u_i + \lambda (x^T u_i) v, \quad i=2,\cdots, n,
$$
並且 $Av_i = \lambda_i v_i$.&lt;/p&gt;
&lt;h3 id=&#34;pf&#34;&gt;pf&lt;/h3&gt;
&lt;p&gt;因為 $u_i$ 是 $B$ 的 eigenvector, 所以
$$
\lambda_i u_i = Bu_i = (A - \lambda v x^T)u_i = Au_i - \lambda(x^Tu_i)v.
$$
因此
$$
Au_i = \lambda_i u_i +\lambda(x^Tu_i)v.
$$
那麼
$$
\begin{align}
Av_i &amp;amp;= (\lambda_i-\lambda) Au_i + \lambda (x^T u_i) Av \\&lt;br&gt;
&amp;amp;= (\lambda_i-\lambda)(\lambda_i u_i +\lambda(x^Tu_i)v) + \lambda^2 (x^T u_i) v\\&lt;br&gt;
&amp;amp;= \lambda_i((\lambda_i-\lambda) u_i + \lambda (x^T u_i) v) \\&lt;br&gt;
&amp;amp;=\lambda_i v_i.
\end{align}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 對 (1) 做 power iteration 可以找出下一個 eigenvalue, 並且利用 (2) 可以得到其 eigenvector.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;接下來我們介紹兩種 &lt;em&gt;&lt;strong&gt;看起來似乎可以使用&lt;/strong&gt;&lt;/em&gt; 的 deflation 作法.
不過實際使用起來有一些問題!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-eigen-decomposition&#34;&gt;2. Eigen-decomposition&lt;/h2&gt;
&lt;p&gt;對一個方陣, 如果我們可以找到所有的 eigenvalues 跟 eigenvectors, 並且有以下關係
$$
A V = V\Lambda  \quad \longleftrightarrow \quad A = V\Lambda V^{-1}
$$
並且我們將 $V$, $\Lambda$, $V^{-1}$ 記為
$$
V = [v_1, v_2, \cdots, v_n], \quad \Lambda = \text{diag}\{\lambda_1, \lambda_2, \cdots, \lambda_n\},\quad
V^{-1} = \begin{bmatrix}
w^T_1 \\ w^T_2 \\ \vdots \\ w^T_n\end{bmatrix}.
$$
則
$$
A = \lambda_1 v^1w^T_1 + \lambda_2 v^2w^T_2 + \cdots + \lambda_n v^nw^T_n.
$$&lt;/p&gt;
&lt;p&gt;有趣的是, 若我們定義
$$
\tag{3} B = A-\lambda_1 v^1w^T_1,
$$
則可以很輕易地看出 $B$ 的 eigenvectors 與 $A$ 的完全一樣, 而 eigenvalues 也幾乎完全一樣, 只有 $\lambda_1$ 被移到 $0$ 去了.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 若我們知道一個 eigenvalue, 以及其相對應的 left and right eigenvectors, 則可以用 (3) 來做 power iteration 找出下一個 eigenvalue, 並且它的 eigenvector 就會是 $A$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過實務上 left eigenvector 比較難找, 需要先找出 linear operator 的 adjoint operator (也就是 $A^T$) 才有辦法做矩陣-向量乘法, 因此這個方法除了對稱的情況外幾乎不會被使用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 當 $A$ 是 symmetric, 則可以選擇 $v_i$ 使得 $w_i = v_i$, 在這時候我們就可以輕易地使用 (3) 來找下一組了.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-annihilation&#34;&gt;3. Annihilation&lt;/h2&gt;
&lt;p&gt;給定 $A$ 為一個 $n\times n$ 方陣. 我們做以下兩個假設&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的 eigenvalues 滿足
$$
|\lambda_1| &amp;gt; |\lambda_2| &amp;gt; |\lambda_3| \cdots |\lambda_n|.
$$&lt;/li&gt;
&lt;li&gt;相對應的 eigenvectors, $\{v_1, v_2, \cdots, v_n\}$, 會構成 $R^n$ 的一組基底.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;observation&#34;&gt;Observation&lt;/h4&gt;
&lt;p&gt;如果初始向量我們選擇 $y$ 使得
$$
\tag{4} y = \sum_{i=2}^n c_iv_i,
$$
也就是沒有 $v_1$ 的分量, 則 power iteration 會找到 $\lambda_2$ 以及 $v_2$.&lt;/p&gt;
&lt;p&gt;當然, 任意給一個向量並無法滿足 (4) 這個條件, 不過若我們定義
$$
\tag{5} y = A x - \lambda_1 x,
$$
則對任意一個向量 $x$, 這個 $y$ 就會滿足 (4).&lt;/p&gt;
&lt;h3 id=&#34;pf-1&#34;&gt;pf&lt;/h3&gt;
&lt;p&gt;Let $x = \sum^{n}_{i=1} c_iv_i$, then&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
y &amp;amp;= A x - \lambda_1 x \\&lt;br&gt;
&amp;amp;= \sum^n_{i=1} (c_iAv_i - c_i\lambda_1v_i) \\&lt;br&gt;
&amp;amp;= \sum^n_{i=2} c_i(\lambda_i-\lambda_1)v_i.
\end{aligned}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 若我們知道一個 eigenvalue, 則可以任取一個向量 $x$ 再用 (5) 來做出 power iteration 的初始值, 這樣就可以找出下一個 eigenvalue, 並且它的 eigenvector 就會是 $A$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過實際在做的時候, 由於 $\lambda_1$ 有數值誤差, 因此 (5) 並不會完全滿足 (4), 在設計 power iteration 的時候要小心這件事.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Conjugate gradient method - iterative method</title>
      <link>https://teshenglin.github.io/post/2023_conjugate_gradient_method_2/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_conjugate_gradient_method_2/</guid>
      <description>&lt;p&gt;共軛梯度法 (CG method,  conjugate gradient method) 目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_1&#34;&gt;CG method - Direct mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;直接法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;CG method - iterate mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;For solving $Ax=b$, where $A$ is a square symmetric positive definite matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h2&gt;
&lt;p&gt;$A\in M_{n\times n}$ is a symmetric positive definite matrix.&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A-orthogonal (A-conjugate)
假設有兩個向量 $u_1$ 跟 $u_2$ 皆非 $0$ 且 $u_1 \neq u_2$，若這兩個向量滿足
$$
\langle{u_1},A{u_2}\rangle = {u_1}^TA{u_2} = 0,
$$
則稱之為 A-orthogonal (或 A-conjugate).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt; We can define
$$
\langle{u_1}, {u_2}\rangle_A = \langle{u_1},A{u_2}\rangle= \langle A{u_1},{u_2}\rangle,
$$
then $\langle \cdot\rangle_A$ is an inner product.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-an-iterative-method-first-attempt&#34;&gt;CG as an iterative method: First attempt&lt;/h2&gt;
&lt;h3 id=&#34;theorem-1&#34;&gt;Theorem 1:&lt;/h3&gt;
&lt;p&gt;假設對一個矩陣 A，我們可以找到一組 A-orthogonal set ${u_0, \ldots, u_{n-1}}$. 則給定一個初始值 $x_0$, 我們可定義一個迭代法: For $0\le i\le n-1$,
$$
\tag{1} x_{i+1}=x_i+t_{i}u_{i}, \quad
t_{i}=\frac{\langle b-Ax_i,u_{i}\rangle}{\langle u_i,Au_{i}\rangle}.
$$
並且我們可以證明以下兩件事&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義第 $k$ 步的 residual, $r_k = b-Ax_k$, 我們有 $\langle r_k, u_{j}\rangle=0$, for $0\le j&amp;lt; k\le n$.&lt;/li&gt;
&lt;li&gt;$Ax_n=b$, 也就是第 $n$ 次迭代保證得到解.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pf-of-1&#34;&gt;pf of 1:&lt;/h4&gt;
&lt;p&gt;首先我們可以推 residual 的迭代式
$$
\tag{2} \begin{align}
r_{k+1} &amp;amp;= b - Ax_{k+1} \\
&amp;amp;= b - A(x_k + t_ku_k) \\&lt;br&gt;
&amp;amp;= (b-Ax_k)  - t_kAu_k \\&lt;br&gt;
&amp;amp;= r_k  - t_kAu_k.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;接著, for $0\le j&amp;lt;k-1$, 由於 $u_{k-1}$ 與 $u_j$ 是 A-orthogonal, 因此
$$
\begin{align}
\langle r_{k}, u_{j}\rangle
&amp;amp;= \langle r_{k-1}, u_{j}\rangle-t_{k-1}\langle Au_{k-1}, u_{j}\rangle \\&lt;br&gt;
&amp;amp;= \langle r_{k-1}, u_{j}\rangle.
\end{align}
$$
同樣的理由可以一直使用得到
$$
\langle r_{k}, u_{j}\rangle
= \langle r_{k-1}, u_{j}\rangle
=\cdots
= \langle r_{j+1}, u_{j}\rangle.
$$&lt;/p&gt;
&lt;p&gt;此外, 若 $j=k-1$, 則我們直接有 $\langle r_{k}, u_{j}\rangle  = \langle r_{j+1}, u_j\rangle$.&lt;/p&gt;
&lt;p&gt;接著再用 (2) 一次, 並且用 (1) 裡 $t_j$ 的定義我們得到&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\langle r_{j+1}, u_j\rangle
&amp;amp;= \langle r_j, u_j\rangle-t_j\langle Au_j, u_j\rangle \\
&amp;amp;= \langle r_j, u_j\rangle-\frac{\langle r_j,u_j\rangle}{\langle u_j,Au_j\rangle}\langle Au_j, u_j\rangle\\&lt;br&gt;
&amp;amp;=0.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;因此, for $0\le j&amp;lt;k$, 我們有
$$
\langle r_{k}, u_{j}\rangle =0.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf-of-2&#34;&gt;pf of 2:&lt;/h4&gt;
&lt;p&gt;根據 1 我們有 $\langle r_n, u_{j}\rangle=0$ for $0\le j&amp;lt; n-1$, 也就是
$$
\langle b - Ax_n, u_{j}\rangle=0, \quad 0\le j&amp;lt; n-1.
$$
因為 $\{u_i\}^{n-1}_{i=0}$ span $\mathbb{R}^n$, 所以 $b - Ax_n$ 必為一個零向量, 也就是說 $Ax_n=b$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gram-schimidt-process-to-find-a-orthogonal-set&#34;&gt;Gram-Schimidt process to find A-orthogonal set&lt;/h2&gt;
&lt;p&gt;不過這方法建立在一個重要假設之下, 就是一開始我們可以找到一組 A-orthogonal set $\{u_0, \ldots, u_{n-1}\}$. 不過在實際解問題是這顯然是不容易做到的, 因此我們會需要一步一步地將 $u_i$ 求出來.&lt;/p&gt;
&lt;p&gt;這裡我們可以利用兩件事&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The residual vector $r_k = b - Ax_k$.
&lt;ul&gt;
&lt;li&gt;每次迭代都會產生出一組新的 residual vector, 並且我們知道 residual 是下降最快的方向, 因此我們可以將下個搜尋方向設為 $r_k$, 只不過這並不滿足 A-orthogonal 的條件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gram-Schimidt process
&lt;ul&gt;
&lt;li&gt;線性代數裡告訴我們, 可以用 Gram-Schimidt process 將一組向量正交化. 因此我們就利用這方法來造出一組 A-orthogonal 的 basis.&lt;/li&gt;
&lt;li&gt;若已經有 $\{u_0, \cdots, u_k\}$, 並且我們得到 $r_{k+1}$, 則 Gram-Schimidt process 告訴我們可以定義 $u_{k+1}$ 為
$$
u_{k+1} = r_{k+1} - \frac{\langle r_{k+1}, Au_0\rangle}{\langle u_0, Au_0\rangle}u_0 - \cdots - \frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle}u_k,
$$
並且 $u_{k+1}$ 會跟 $u_0, \cdots, u_k$ 是 A-orthogonal.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-iterative-method-second-attempt&#34;&gt;CG as iterative method: Second attempt&lt;/h2&gt;
&lt;p&gt;給一個初始猜測 $x_0$, 我們可以算 $r_0 = b-Ax_0$, 並且我們定義第一個方向為 $u_0 = r_0$.&lt;/p&gt;
&lt;p&gt;接著我們可以往下做, for $k\ge 0$,
$$
\begin{align}
t_{k} &amp;amp;=\frac{\langle b-Ax_k,u_{k}\rangle}{\langle u_k,Au_{k}\rangle}, \\&lt;br&gt;
x_{k+1} &amp;amp;= x_k + t_k u_k, \\&lt;br&gt;
r_{k+1} &amp;amp;= r_k - t_kAu_k, \\&lt;br&gt;
u_{k+1} &amp;amp;= r_{k+1} - \frac{\langle r_{k+1}, Au_0\rangle}{\langle u_0, Au_0\rangle}u_0 - \cdots - \frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle}u_k.
\end{align}
$$
這樣保證在第 $n$ 步得到解.&lt;/p&gt;
&lt;p&gt;不過一般而言這是個迭代法, 我們在過程中會看 residual 的大小, $\|r_{k+1}\|^2_2$, 如果 residual 夠小就會停止整個迭代, 不需要真的做到第 $n$ 步.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark :&lt;/strong&gt;
這樣子做有個很明顯的缺點, 就是為了求出 A-orthogonal set 我們需要把所有方向 $\{u_i\}$ 都一直記著. 這樣當問題維度非常大時會需要耗費大量記憶體在存這些方向.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過我們可以再觀察一下, 若使用 Gram-Schimidt process, 則這些 $\{u\}$ 都是從 $\{r\}$ 得來的, 因此這兩個所組出來的空間應該是一樣的, 也就是
$$
\text{span}\{u_0,\cdots, u_k\} = \text{span}\{r_0,\cdots, r_k\}.
$$
我們若定義 $V_k = \text{span}\{u_0,\cdots, u_k\}$, 則由 Theorem 1 我們知道,
$$
\langle r_{k+1}, u_{j}\rangle=0, \quad 0\le j\le k,
$$&lt;/p&gt;
&lt;p&gt;也就是 $r_{k+1}$ 這個向量會垂直於 $V_k$ 這個空間, 因此我們也有&lt;/p&gt;
&lt;p&gt;$$
\tag{3} \langle r_{k+1}, r_{j}\rangle=0, \quad 0\le j\le k.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事實上, 實作 second attempt 後會發現, 要算 $u_{k+1}$ 其實只需要他的前一項, $u_{k}$, 即可, 也就是
$$
\tag{4} u_{k+1} = r_{k+1}  + \beta_k u_k, \quad \beta_k =  -\frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle},
$$
因為其他項都自動為零了! 接著我們就來證明這件事.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lemma-&#34;&gt;&lt;em&gt;&lt;strong&gt;Lemma :&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;$$
\langle r_{k+1}, Au_j\rangle = 0, \quad 0\le j\le k-1.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;根據 (2), 我們可以得到 $Au_j = \frac{r_j - r_{j+1}}{t_j}$. 因此
$$
\tag{5} \langle r_{k+1}, Au_j\rangle = \frac{1}{t_j}\langle r_{k+1}, r_j - r_{j+1}\rangle= \frac{\langle r_{k+1}, r_j \rangle - \langle r_{k+1}, r_{j+1} \rangle}{t_j}.
$$&lt;/p&gt;
&lt;p&gt;接著我們利用 (3), 代入 (5) 我們就得到 $\langle r_{k+1}, Au_j\rangle=0$ for $0\le j\le k-1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;將 $j=k$ 代入 (5) 得到
$$
\tag{6}\langle r_{k+1}, Au_k\rangle =  \frac{\langle r_{k+1}, r_k \rangle - \langle r_{k+1}, r_{k+1} \rangle}{t_k} = \frac{ - \langle r_{k+1}, r_{k+1} \rangle}{t_k}.
$$&lt;/p&gt;
&lt;p&gt;利用 (1) 與 (4) $t_k$ 及 $u_k$ 的定義我們可以推得
$$
\tag{7}
\begin{align}
t_k &amp;amp;= \frac{\langle r_{k}, u_{k} \rangle}{\langle u_{k}, Au_{k} \rangle} = \frac{\langle r_{k}, r_{k} + \beta_{k-1}u_{k-1} \rangle}{\langle u_{k}, Au_{k} \rangle} \\&lt;br&gt;
&amp;amp;= \frac{\langle r_{k}, r_{k}  \rangle}{\langle u_{k}, Au_{k} \rangle} + \frac{\langle r_{k}, \beta_{k-1}u_{k-1} \rangle}{\langle u_{k}, Au_{k} \rangle} \\&lt;br&gt;
&amp;amp;= \frac{\langle r_{k}, r_{k}  \rangle}{\langle u_{k}, Au_{k} \rangle}.
\end{align}
$$
最後一個等號我們用到了 Theorem 1 的結果. 因此 $t_k$ 可改為以 (7) 來做.&lt;/p&gt;
&lt;p&gt;將 (7) 改寫一下我們得到
$$
\tag{8}\langle u_{k}, Au_{k} \rangle = \frac{\langle r_{k}, r_{k}  \rangle}{t_k}.
$$&lt;/p&gt;
&lt;p&gt;最後, 我們可以將 $\beta_k$ 重新計算一下, 利用 (6) 跟 (8) 得到
$$
\tag{9} \beta_k = -\frac{\langle r_{k+1}, Au_k\rangle}{\langle u_k, Au_k\rangle} = \frac{\langle r_{k+1}, r_{k+1}\rangle}{\langle r_{k}, r_{k}\rangle}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-iterative-method-the-algorithm&#34;&gt;CG as iterative method: The algorithm&lt;/h2&gt;
&lt;p&gt;給一個初始猜測 $x_0$, 我們可以算 $r_b = b-Ax_0$, 並且我們定義第一個方向為 $u_0 = r_0$.&lt;/p&gt;
&lt;p&gt;接著我們可以往下做, for $k\ge 0$,
$$
\begin{align}
t_{k} &amp;amp;=\frac{\langle r_k,r_{k}\rangle}{\langle u_k,Au_{k}\rangle},\\&lt;br&gt;
x_{k+1} &amp;amp;= x_k + t_k u_k, \\&lt;br&gt;
r_{k+1} &amp;amp;= r_k  - t_kAu_k, \\&lt;br&gt;
\beta_k &amp;amp;= \frac{\langle r_{k+1}, r_{k+1}\rangle}{\langle r_{k}, r_{k}\rangle},\\&lt;br&gt;
u_{k+1} &amp;amp;= r_{k+1} + \beta_k u_k.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;這樣保證在第 $n$ 步得到解, 而且每次迭代都只需要 &lt;em&gt;&lt;strong&gt;一個&lt;/strong&gt;&lt;/em&gt; 矩陣向量乘法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不過一般而言這是個迭代法, 我們在過程中會看 residual 的大小, $\|r_{k+1}\|^2_2=\langle r_{k+1}, r_{k+1}\rangle$, 如果 residual 夠小就會停止整個迭代, 不需要真的做到第 $n$ 步. 而且這個量是在過程中會被計算出來的, 所以不需花費額外力氣.&lt;/li&gt;
&lt;li&gt;Residual $r_{k+1}=r_k-t_kAu_k$ 這個式子可能會在迭代的過程由於誤差進來而越來越不準, 所以每隔一段時間要以原本公式重新更新一次, $r_{k+1} = b - Ax_{k+1}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Power method</title>
      <link>https://teshenglin.github.io/post/2023_power_method_1/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_power_method_1/</guid>
      <description>&lt;p&gt;Power 迭代法目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_1&#34;&gt;基本概念&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power iteration; inverse power method; shifted inver power method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;找第二大的 eigenvalue&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;deflation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_3&#34;&gt;Rayleigh Quotient 迭代及其收斂性&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Power method with Rayleigh Quotient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基本-power-method&#34;&gt;基本 Power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最大(in magnitude) 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定 $A$ 為一個 $n\times n$ 方陣. 我們做以下兩個假設&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的 eigenvalues 滿足
$$
|\lambda_1| &amp;gt; |\lambda_2| \ge |\lambda_3| \cdots |\lambda_n|.
$$&lt;/li&gt;
&lt;li&gt;相對應的 eigenvectors, $\{v_1, , v_2, , \cdots, v_n\}$, 會構成 $R^n$ 的一組基底.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;則若我們&lt;em&gt;&lt;strong&gt;任意取&lt;/strong&gt;&lt;/em&gt;一個 $n\times 1$ 向量 $u$, 它能被寫成 (根據假設 2)
$$
u =\sum^{n}_{i=1} c_iv_i.
$$&lt;/p&gt;
&lt;p&gt;我們將兩邊乘以 $A$ 得到&lt;/p&gt;
&lt;p&gt;$$
Au = \sum^{n}_{i=1} c_i\lambda_i v_i,
$$&lt;/p&gt;
&lt;p&gt;並且如果我們一直乘以 $A$, 共乘 $k$ 次, 則有
$$
\tag{1} A^ku =\sum^{n}_{i=1} c_i\lambda^k_i v_i.
$$&lt;/p&gt;
&lt;p&gt;因為 $|\lambda_1|$ 比其他的都大 (根據假設 1), 我們可以得到當 $k$ 夠大時
$$
\tag{2} \frac{1}{\lambda^k_1}A^ku = c_1 v_1 + \sum^{n}_{i=2} c_i\left(\frac{\lambda_i}{\lambda_1}\right)^k v_i \to c_1 v_1.
$$&lt;/p&gt;
&lt;p&gt;因此我們知道, 如果我們一開始隨機選取一個向量, 並且將之以 $A$ 矩陣一直乘它, 乘出來的這個向量應該會越來越接近第一個 eigenvector, 藉此我們也可以得到最大的 eigenvalue.&lt;/p&gt;
&lt;p&gt;另外我們也知道, 收斂速度 (rate of convergence) 會是 $\frac{\lambda_2}{\lambda_1}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以看到 (2) 式有個特別的地方是等號左邊我們把他除以 $\lambda^k_1$, 這樣等號右邊就會趨近於 $c_1v_1$.&lt;/li&gt;
&lt;li&gt;如果真的照 (1) 式的做法, 任意取一個 $u$ 然後矩陣一直乘會發生什麼事呢?
&lt;blockquote&gt;
&lt;p&gt;如果 $\lambda&amp;gt;1$ 那 $\lambda^k\to\infty$, 如果 $\lambda&amp;lt;1$ 那 $\lambda^k\to 0$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;因此, 實際執行 (1) 是不可行的. 而 (2) 也不可行, 因為 $\lambda_1$ 就是我們要找的東西, 所以無法除以 $\lambda_1^k$.&lt;/li&gt;
&lt;li&gt;實際執行 power iteration 時, 會將每次迭代所得到的向量 normalize, 這樣就可以避免爆掉或趨近於零的狀況. 而最簡單的 normalization 就是讓每次得到的向量為單位長.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;作法&#34;&gt;作法:&lt;/h4&gt;
&lt;p&gt;Input: A
Output: (取絕對值後)最大的 eigenvalue $\lambda_1$ 以及 $v_1$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隨機選取一個向量 $u$, 並使 $\|u\|=1$&lt;/li&gt;
&lt;li&gt;計算 $v = Au$, 並令 $\lambda=\|v\|$&lt;/li&gt;
&lt;li&gt;另 $u=v/\lambda$ 並重複步驟 2 直到 $\lambda$ 收斂為止&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: matrix A
Output: lambda1, u

u = random(size(A,1),1)
u = u/norm(u)

Tol=10**(-10)
max_iter = 1000

lambda0=1
diff=1

iter=0

while diff &amp;gt; Tol
    v = A*u
    lambda1 = norm(v)
    u = v/lambda1
    
    diff = abs(lambda1-lambda0)    
    lambda0 = lambda1
    
    iter =iter+1
    if iter &amp;gt; max_iter || diff &amp;lt; Tol
        break
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 不過這樣得到的 &lt;code&gt;lambda1&lt;/code&gt; 會是 $|\lambda_1|$, 要拿到 $\lambda_1$ 需要再乘一次矩陣.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事實上我們的目標只是不要讓向量爆掉或趨近於零, 所以可以簡單的把某個位置的值固定住, 比如說我們強迫 $v_1$ 的第一個位置等於 $1$, 這樣就沒問題了.&lt;/p&gt;
&lt;p&gt;Pseudo code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while diff &amp;gt; Tol
    v = A*u
    lambda1 = v(1)
    u = v/lambda1
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當然, 如果 $v_1$ 這個 eigenvector 本來他第一個位置就是 $0$ 那這招就不行了. 不過我們可以固定其他位置啊!&lt;/li&gt;
&lt;li&gt;理論上, 由於 $v_1$ 不是零向量, 因此一定有個位置非零, 可以被固定住. 不過通常就隨機選個位置固定住就好.&lt;/li&gt;
&lt;li&gt;這樣做的好處有兩個:
a. 取向量某一個位置的值遠比算向量的 norm 要快很多.
b. 這樣拿到的 eigenvalue 就是 $\lambda_1$, 沒有絕對值.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;若要找第二大的 eigenvalue 可以利用 deflation: 
&lt;a href=&#34;https://teshenglin.github.io/post/2023_power_method_2&#34;&gt;Power method with deflation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;inverse-power-method&#34;&gt;Inverse power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最小(in magnitude) 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;observation&#34;&gt;Observation:&lt;/h4&gt;
&lt;p&gt;如果 $\lambda$ 滿足 $Av = \lambda v$, 則 $A^{-1}v = \frac{1}{\lambda} v$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;因此, 如果我們想要找一個矩陣 $A$ 它(絕對值)最小的 eigenvalue, $\lambda_n$, 那我們就需要對 $A^{-1}$ 做 power method. 也就是計算 $(A^{-1})^k u$. 這樣我們可以找到 $\frac{1}{\lambda_n}$, 將之反過來就得到最小的 eigenvalue.&lt;/p&gt;
&lt;p&gt;這裡需注意兩件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必須先確定最小的 eigenvalue 不是 $0$, 也就是這矩陣 non-singular, 不然 inverse power method 也無法做.&lt;/li&gt;
&lt;li&gt;$A^{-1}u$ 是解線性系統, 不是乘以 $A^{-1}$ 矩陣.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Inverse power method 的 rate of convergence 是 $\frac{\lambda_{n}}{\lambda_{n-1}}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;shift-inverse-power-method&#34;&gt;Shift-inverse power method&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求一個方陣最靠近某個數字 $c$ 的 eigenvalue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;observation-1&#34;&gt;Observation:&lt;/h4&gt;
&lt;p&gt;如果 $\lambda$ 滿足 $Av = \lambda v$, 則 $(A-cI)v = (\lambda-c) v$. 因此
$$
(A-cI)^{-1}v = \frac{1}{\lambda-c} v.
$$
也就是說, $(A-cI)^{-1}$ 這矩陣最大的 eigenvalue, 會是使得 $\frac{1}{\lambda-c}$ 最大的那個, 我們可以據此反推 $A$ 矩陣其最靠近 $c$ 的那個 eigenvalue.&lt;/p&gt;
&lt;p&gt;因此, 若我們想要找矩陣 $A$ 它最靠近某個數字 $c$ 的 eigenvalue, 那我們就需要對 $(A-cI)^{-1}$ 做 power method. 也就是計算 $((A-cI)^{-1})^k u$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Conjugate gradient method - direct method</title>
      <link>https://teshenglin.github.io/post/2023_conjugate_gradient_method_1/</link>
      <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2023_conjugate_gradient_method_1/</guid>
      <description>&lt;p&gt;共軛梯度法 (CG method,  conjugate gradient method) 目錄:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_1&#34;&gt;CG method - Direct mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;直接法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;CG method - iterate mehtod&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;For solving $Ax=b$, where $A$ is a square symmetric positive definite matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h2&gt;
&lt;p&gt;$A\in M_{n\times n}$ is a symmetric positive definite matrix.&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A-orthogonal (A-conjugate)
假設有兩個向量 $u_1$ 跟 $u_2$ 皆非 $0$ 且 $u_1 \neq u_2$，若這兩個向量滿足
$$
\langle{u_1},A{u_2}\rangle = {u_1}^TA{u_2} = 0,
$$
則稱之為 A-orthogonal (或 A-conjugate).&lt;/li&gt;
&lt;li&gt;A-orthonormal
假設有兩個向量 $u_1$ 跟 $u_2$ 為 A-orthogonal, 並且 $\langle{u_i}, {u_i}\rangle_A = 1$ for $1\le i\le 2$, 則稱之為 A-orthonormal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Recall :&lt;/strong&gt; ${u_1}$ and ${u_2}$ are orthogonal if ${u_1}^T{u_2} = 0$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt; We can define
$$
\langle{u_1}, {u_2}\rangle_A = \langle{u_1},A{u_2}\rangle= \langle A{u_1},{u_2}\rangle,
$$
then $\langle \cdot\rangle_A$ is an inner product.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lemma&#34;&gt;Lemma&lt;/h3&gt;
&lt;p&gt;如果 ${u_0, \cdots, u_k}$ 是個 A-orthogonal set, 則 ${u_0, \cdots, u_k}$ 也是一個 linearly independent set.&lt;/p&gt;
&lt;h4 id=&#34;pf&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;假設 $c_0 u_0 + \cdots c_ku_k =0$.&lt;/p&gt;
&lt;p&gt;將此方程兩邊同時乘以 $u^T_j A$, 由於 $u_j^TAu_i=0$ for $i\ne j$, 因此得到 $c_j u^T_j Au_j = 0$. 此外, 由於 $A$ 是正定矩陣, $u^T_j Au_j &amp;gt; 0$, 因此 $c_j=0$.&lt;/p&gt;
&lt;p&gt;由於以上論述對所有 $j$ 都對, 因此得到 $c_i=0$ $\forall i$, 因此 ${u_0, \cdots, u_k}$ 為線性獨立.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note :&lt;/strong&gt;
如果 ${u_0, \cdots, u_{n-1}}\subset\mathbb{R}^n$ 是個 A-orthogonal set, 則他們也是 $\mathbb{R}^n$ 的一組 basis.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cg-as-a-direct-method&#34;&gt;CG as a direct method&lt;/h2&gt;
&lt;h3 id=&#34;theorem&#34;&gt;Theorem:&lt;/h3&gt;
&lt;p&gt;假設對一個矩陣 A，我們可以找到一組 A-orthogonal set ${u_0, \ldots, u_{n-1}}$, 則線性系統 $Ax=b$ 的解為
$$
x = \sum^{n-1}_{j=0}\frac{u^T_j b}{u^T_jAu_j} u_j.
$$&lt;/p&gt;
&lt;h4 id=&#34;pf-1&#34;&gt;pf:&lt;/h4&gt;
&lt;p&gt;假設 $x = \sum^{n-1}_{i=0} c_i u_i$, 則&lt;/p&gt;
&lt;p&gt;$$
Ax = \sum^{n-1}_{i=0} c_i Au_i.&lt;br&gt;
$$&lt;/p&gt;
&lt;p&gt;將之代入 $b = Ax$ 並將兩側同時乘以 $u^T_j$ 得到
$$
u^T_j b = \sum^{n-1}_{i=0} c_i u^T_jAu_i = c_ju^T_jAu_j.
$$
因此
$$
c_j = \frac{u^T_j b}{u^T_jAu_j}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;實作上我們需要以迭代來尋找 $A$-orthogonal set, 並以迭代法來解線性系統.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Conjugate_gradient_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Conjugate gradient method - wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;迭代法推導請見
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://teshenglin.github.io/post/2023_conjugate_gradient_method_2&#34;&gt;Conjugate gradient method - iterative method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>2023 Summer Research Internship</title>
      <link>https://teshenglin.github.io/courses/2023_summer_research/</link>
      <pubDate>Mon, 10 Apr 2023 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/2023_summer_research/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2023-暑期研究實習&#34;&gt;2023 暑期研究實習&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;研究實習辦法
&lt;ol&gt;
&lt;li&gt;實習期間, 時間, 地點
&lt;ul&gt;
&lt;li&gt;六週, 具體時間各自與指導教授訂定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;說明會
&lt;ul&gt;
&lt;li&gt;訂於 4/19 (週三) 12:00-13:00 SC207&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;報名
&lt;ul&gt;
&lt;li&gt;報名資格: 大學部就學中&lt;/li&gt;
&lt;li&gt;報名截止: 5/14&lt;/li&gt;
&lt;li&gt;報名方式: 與指導教授面談後填寫表單 - 
&lt;a href=&#34;https://forms.gle/KuEdBQHibfae3n8s9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;報名表單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;經錄取, 在符合以下條件的情況下將補助兩萬元整
&lt;ul&gt;
&lt;li&gt;於實習期間協助團隊指導教授進行相關研究&lt;/li&gt;
&lt;li&gt;研究成果海報展
&lt;ul&gt;
&lt;li&gt;每位參與實習的學生皆需參加研究成果海報展, 日期暫訂於 2023 FALL 開學前一週, 具體日期再另行通知.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;各研究團隊主題&#34;&gt;各研究團隊主題&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Contact Process
&lt;ul&gt;
&lt;li&gt;Advisor: 千野由喜 - 
&lt;a href=&#34;mailto:y.chino@math.nctu.edu.tw&#34;&gt;y.chino@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;矩陣的數值域
&lt;ul&gt;
&lt;li&gt;Advisor: 王國仲 - 
&lt;a href=&#34;mailto:kzwang@math.nctu.edu.tw&#34;&gt;kzwang@math.nctu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;在這個暑期計畫中，我們將學習矩陣的數值域上重要的性質，其中包含Toeplitz-Hausdorff、Ando、Anderson定理和冪不等式。另一方面，同學也將學習2或3階矩陣的數值域。&lt;/p&gt;
&lt;p&gt;預備知識:線性代數、分析導論。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;機器人運動學
&lt;ul&gt;
&lt;li&gt;Advisor: 吳金典 - 
&lt;a href=&#34;mailto:ctw@math.nctu.edu.tw&#34;&gt;ctw@math.nctu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://rsl.ethz.ch/education-students/lectures/robotdynamics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Robot dynamics&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;神經場模型的模式生成
&lt;ul&gt;
&lt;li&gt;Advisor: 吳昌鴻 - 
&lt;a href=&#34;mailto:changhong@math.nctu.edu.tw&#34;&gt;changhong@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理訊息神經網路
&lt;ul&gt;
&lt;li&gt;Advisor: 林得勝 - 
&lt;a href=&#34;mailto:tslin@math.nctu.edu.tw&#34;&gt;tslin@math.nctu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1NronWVEqkkcvf5ijBPd6r23sKl5R8-y6/view&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Physics-informed neural networks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有效介質近似理論與超材料
&lt;ul&gt;
&lt;li&gt;Advisor: 林奕亘 - 
&lt;a href=&#34;mailto:yihsuanlin3@math.nctu.edu.tw&#34;&gt;yihsuanlin3@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;探索平面鋪砌的藝術與數學
&lt;ul&gt;
&lt;li&gt;Advisor: 康明軒 - 
&lt;a href=&#34;mailto:mhkang@math.nctu.edu.tw&#34;&gt;mhkang@math.nctu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;在這個課程中，我們將深入探索平面鋪砌的有趣世界，探索藝術和數學的交集。我們將開始研究壁紙群的分類，學習如何構建和操作它們。接下來，我們將轉向非周期鋪砌，包括古典的彭羅斯鋪砌和最近剛被發現的愛因斯坦鋪砌，甚至設計我們自己的非周期鋪砌。這個課程的目標是深入理解平面鋪砌的數學概念，並與ChatGPT合作創造獨特而美麗的鋪砌設計。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;應用漸進分析
&lt;ul&gt;
&lt;li&gt;Advisor: 黃信元 - 
&lt;a href=&#34;mailto:hyhuang@math.nctu.edu.tw&#34;&gt;hyhuang@math.nctu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;在此暑期計畫中，我們將主要研究當某些參數或變數趨於無窮大或某些特定值時，積分的漸近行為。更精確地說，我們將學習拉普拉斯方法、最陡下降法和 stationey phase method(穩相方法)，並應用於指數型積分的漸近分析。同學將選擇參考書目的題材做更近一步的學習。預備知識有複變函數為佳。&lt;/p&gt;
&lt;p&gt;參考書目: Applied Asymptotic Analysis (Graduate Studies in Mathematics) By Peter Miller&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;壓縮感知應用於影像
&lt;ul&gt;
&lt;li&gt;Advisor: 薛名成 - 
&lt;a href=&#34;mailto:mcshiue@nycu.edu.tw&#34;&gt;mcshiue@nycu.edu.tw&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/SbU1pahbbkc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Compressed Sensing: Overview by Steve Brunton&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量子金融分析
&lt;ul&gt;
&lt;li&gt;Advisor: 蘇承芳 - 
&lt;a href=&#34;mailto:scf1204@nycu.edu.tw&#34;&gt;scf1204@nycu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;實習報名&#34;&gt;實習報名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;請先與各團隊指導教授線上面談後填寫以下表單&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forms.gle/KuEdBQHibfae3n8s9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;報名表單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;錄取名單&#34;&gt;錄取名單&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Contact Process
&lt;ul&gt;
&lt;li&gt;陳冠傑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;矩陣的數值域
&lt;ul&gt;
&lt;li&gt;羅楷崴, 張育萁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;神經場模型的模式生成
&lt;ul&gt;
&lt;li&gt;林瑜軒, 鄭吉呈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有效介質近似理論與超材料
&lt;ul&gt;
&lt;li&gt;張啟明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;應用漸進分析
&lt;ul&gt;
&lt;li&gt;楊羿愷, 黃鈺誠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;壓縮感知應用於影像
&lt;ul&gt;
&lt;li&gt;吳苡寧, 孔德立, 陳俊瑋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量子金融分析
&lt;ul&gt;
&lt;li&gt;王宣瑋, 陳怡如&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>On the transition to dripping of an inverted liquid film</title>
      <link>https://teshenglin.github.io/publication/23_jfm_blt/</link>
      <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/23_jfm_blt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A shallow physics-informed neural network for solving partial differential equations on surfaces</title>
      <link>https://teshenglin.github.io/publication/23_jcp_hsll/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/23_jcp_hsll/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Reduced Model for a Phoretic Swimmer</title>
      <link>https://teshenglin.github.io/publication/22_jfm_frhlrm/</link>
      <pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/22_jfm_frhlrm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Discontinuity Capturing Shallow Neural Network for Elliptic Interface Problems</title>
      <link>https://teshenglin.github.io/publication/22_jcp_hll/</link>
      <pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/22_jcp_hll/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Shallow Ritz Method for elliptic problems with Singular Sources</title>
      <link>https://teshenglin.github.io/publication/22_jcp_lclhl/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/22_jcp_lclhl/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2022 Summer Research Internship</title>
      <link>https://teshenglin.github.io/courses/2022_summer_research/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/2022_summer_research/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2022-暑期研究實習&#34;&gt;2022 暑期研究實習&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1U7er4LhCEyp8abvv-bezEYjhHGbG4sVU/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;海報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1BhapYq6SLe-7lzKSwpeSfCfDH72_AfWG/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;研究實習辦法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://hackmd.io/OUwIZ_7YQWW4SUJtFHykJQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;暑期專題研究成果海報展&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;各研究團隊說明&#34;&gt;各研究團隊說明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1DsFb21YWwVGvswV7Ntq6EA4C_q9KUoPU/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Random walk and electrical network&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;千野由喜 - 
&lt;a href=&#34;mailto:y.chino@math.nctu.edu.tw&#34;&gt;y.chino@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3D image processing
&lt;ul&gt;
&lt;li&gt;吳金典 - 
&lt;a href=&#34;mailto:ctw@math.nctu.edu.tw&#34;&gt;ctw@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1rCeDqggH1jSA3iiyzwKQzDm_WqgphKXK/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynamical behavior of some continuous/discrete models in mathematical biology&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;吳昌鴻 - 
&lt;a href=&#34;mailto:changhong@math.nctu.edu.tw&#34;&gt;changhong@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1nv0b-NSNj-tiEkFIdAbbu5p7kzc5oQ0v/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Image segmentation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;林得勝 - 
&lt;a href=&#34;mailto:tslin@math.nctu.edu.tw&#34;&gt;tslin@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1wJZ0l5WEuuPjywuFe4bmG2z6U6j1-xkX/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multiscale method, averaging and homogenization for differential equations&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;林奕亘 - 
&lt;a href=&#34;mailto:yihsuanlin3@math.nctu.edu.tw&#34;&gt;yihsuanlin3@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1lt32kdVda4p07gscrIbSUVs4kk09ndf5/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hyperbolic Geometry&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;康明軒 - 
&lt;a href=&#34;mailto:mhkang@math.nctu.edu.tw&#34;&gt;mhkang@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1ISUtYEE2EGyaO-h4ioeup_aoPEZniNqH/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Elliptic function and its application in differential equations&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;黃信元 - 
&lt;a href=&#34;mailto:hyhuang@math.nctu.edu.tw&#34;&gt;hyhuang@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1wv4hzFqzZ6a1-Nw4QHdSlOP1Na3l21-U/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Isogeometric analysis applied to Poisson equations; Wigner&amp;rsquo;s semicircle law of random matrices&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;薛名成 - 
&lt;a href=&#34;mailto:mcshiue@nycu.edu.tw&#34;&gt;mcshiue@nycu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;實習報名&#34;&gt;實習報名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;請先與各團隊指導教授線上面談後填寫以下表單&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forms.gle/LjncA23xMmUsFkW3A&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;報名表單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;錄取名單&#34;&gt;錄取名單&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Random walk and electrical network
&lt;ul&gt;
&lt;li&gt;謝翊庭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3D image processing
&lt;ul&gt;
&lt;li&gt;陳俊瑋, 林宜柔&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dynamical behavior of some continuous/discrete models in mathematical biology
&lt;ul&gt;
&lt;li&gt;謝心怡, 張凱智&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Image segmentation
&lt;ul&gt;
&lt;li&gt;陳明宏, 孫念慈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hyperbolic geometry
&lt;ul&gt;
&lt;li&gt;曹瑋, 張育浚, 陳羿愷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Wigner&amp;rsquo;s semicircle law of random matrices
&lt;ul&gt;
&lt;li&gt;謝杰穎&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Spontaneous locomotion of phoretic particles in three dimensions</title>
      <link>https://teshenglin.github.io/publication/22_prf_hlrm/</link>
      <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/22_prf_hlrm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Summer Research Internship</title>
      <link>https://teshenglin.github.io/courses/summer_research/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/summer_research/</guid>
      <description>&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2023_summer_research/&#34;&gt;2023 Summer research internship&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2022_summer_research/&#34;&gt;2022 Summer research internship&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2021_summer_research/&#34;&gt;2021 Summer research internship&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2020_summer_research/&#34;&gt;2020 Summer research internship&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Diffusion maps</title>
      <link>https://teshenglin.github.io/post/2021_diffusion_maps/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2021_diffusion_maps/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;擴散映射, 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Diffusion_map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diffusion maps&lt;/a&gt; (以下簡稱 DM), 是個資料分析, 流型學習或是資料降維的工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps 降維.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;algorithm---diffusion-maps-embeding&#34;&gt;Algorithm - diffusion maps embeding&lt;/h2&gt;
&lt;p&gt;先簡單介紹一下作法.&lt;/p&gt;
&lt;p&gt;假設我們有 $n$ 筆 $d$ 維的資料,
$$
\{x_1, x_2, \cdots, x_n\} \in R^d.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;我們需要先定一個 $K$ 矩陣, $K_{ij}=k(x_{i},x_{j})$, 一般而言我們使用 Guassian kernel
$$
k(x,y) = e^{-\frac{\lVert x-y \rVert^2}{\sigma^2}},
$$
其中 $\sigma$ 是個常數. 這樣造出來的 $K$ 矩陣會是個 $n\times n$ 對稱半正定的矩陣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著我們要定 diffusion matrix $P$, 其定義為
$$
P=D^{-1}K,
$$
其中 $D$ 是個只有對角線有值的矩陣, 其元素為相對應 $K$ 矩陣的 rowsum, $D_{ii} = \sum^n_{j=1} K_{ij}$.
因此可以知道 $P$ 矩陣其實就是將 $K$ 矩陣的每個 row 做 normalize 的動作, 使其 rowsum 等於 $1$.&lt;/p&gt;
&lt;p&gt;$P$ 這矩陣可看成是個機率矩陣, 其第 $i$ 個 row 表示從 $x_{i}$ 這個點跳到其他點的機率分佈.&lt;/p&gt;
&lt;p&gt;接著我們考慮 $Q$ 矩陣, 定義為
$$
Q=D^{-\frac{1}{2}}KD^{-\frac{1}{2}}.
$$
我們可以很輕易發現 $P$ 以及 $Q$ 兩個矩陣有完全相同的 eigenvalues, 而 $P$ 的 eigenvectors 是
$$
v = D^{-1/2}v_Q,
$$
其中 $v_Q$ 是 $Q$ 的 eigenvector.&lt;/p&gt;
&lt;p&gt;另一個重要觀察是 $Q$ 矩陣跟 $K$ 一樣是對稱半正定的矩陣, 因此它的 eigenvalues 都非負, 而且他的 eigenvalues 跟 singular values 會完全一模一樣.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;先將 $Q$ 的 eigenvalues 跟 eigenvectors 都找出來, 接著 $P$ 的 eigenvalues 跟 eigenvectors 就依照上面的公式可以輕易得到.&lt;/p&gt;
&lt;p&gt;我們令 $P$ 的 eigenvalues 跟 eigenvectors 分別為 $\lambda_i$ 跟 $\psi_i$, $1\le i\le n$.&lt;/p&gt;
&lt;p&gt;需要注意的是, $\lambda_1=1$ 並且 $\psi_1$ 是一個常數向量, 因為我們要拿的是從第二個開始.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;接著我們定義 $Y$ 矩陣為
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \cdots, \lambda_n\psi_n\right],
$$
這是個 $n\times (n-1)$ 的矩陣.&lt;/p&gt;
&lt;p&gt;如果我們想要將原始資料投射到 $k$ 維, $k \le (n-1)$, 那我們就只要到第 $k+1$ 個 eigenvector 就好. 比如說要投影到三維, 我們只需要取
$$
Y = \left[\lambda_2\psi_2, \lambda_3\psi_3, \lambda_4\psi_4\right].
$$
而 diffusion maps embedding 的每個點就是這個 $Y$ 矩陣的 row, 也就是 $y_i = Y(i,:)$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;implementation-in-julia&#34;&gt;Implementation in &lt;code&gt;julia&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;接著我們就可以來看要怎樣以 &lt;code&gt;julia&lt;/code&gt; 來做 diffusion maps.&lt;/p&gt;
&lt;p&gt;我們需要以下幾個 packages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Distances
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;以下例子為一個 spiral curve, 我們想要看經過 diffusion maps 的投射到二或三維後會長什麼樣子.&lt;/p&gt;
&lt;p&gt;我們先把 spiral curve 上面的點造出來 (取 $300$ 個點)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# generating the data - a spiral curve&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# n: number of sampling&lt;/span&gt;
n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;

theta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi,length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n);
&lt;span style=&#34;color:#75715e&#34;&gt;# x and y-coordinates&lt;/span&gt;
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(theta);
&lt;span style=&#34;color:#75715e&#34;&gt;# X is a n-by-2 data matrix&lt;/span&gt;
X &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x y];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;畫出來看看原始 data 長怎樣. 我們照順序將點標為藍色, 紅色以及綠色.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(X[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), aspect_ratio&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:equal&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_01.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;1-affinity-matrix-k-1&#34;&gt;1. Affinity matrix $K$&lt;/h4&gt;
&lt;p&gt;先來造出 $K$ 矩陣:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pairwise(Euclidean(), X, dims&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
sigma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;;
K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(E&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;(sigma&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;2-normalized-affinity-matrix-q-1&#34;&gt;2. Normalized affinity matrix $Q$&lt;/h4&gt;
&lt;p&gt;接著造出 $Q$ 矩陣, 並求出其 eigenvalues 跟 eigenvectors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Q = zeros(n,n);
d_sq = zeros(n);
for ii = 1:n
    d_sq[ii] = sqrt(sum(K[ii,:]));
end
for ii = 1:n
    for jj = 1:n
        Q[ii,jj] = K[ii,jj]/(d_sq[ii]*d_sq[jj]);
    end
end
U,S,V = svd(Q);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;3-求出-p-矩陣的-eigenvalues-跟-eigenvectors-1&#34;&gt;3. 求出 $P$ 矩陣的 eigenvalues 跟 eigenvectors&lt;/h4&gt;
&lt;p&gt;$P$ 矩陣的 eigenvalues 跟 $Q$ 一樣, eigenvectors 也可以依公式得到:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; n
    V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[ii,&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;d_sq[ii];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;將 eigenvalues 畫出來看看. 左圖是第 $2$ 到第 $11$ 個, 右圖則是以 semilogy 畫出全部的 eigenvalues. 可以看出 eigenvalues 遞減的非常快, 所以其實 embedding 不需要取到全部 $(n-1)$ 維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scatter(S[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;], title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues 2:11&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(S), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eigenvalues in log&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false);
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_02.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h4 id=&#34;4-define-diffusion-map-y-1&#34;&gt;4. Define diffusion map $Y$&lt;/h4&gt;
&lt;p&gt;最後我們定義 embedding $Y$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;Y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(n,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
    Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;S[ii&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們知道 $Y$ 的每個 row 就是這個 embedding 的座標.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們將 embedding 畫出來看看. 左圖是 embed 到二維, 右圖則是 embed 到三維.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), reshape(Y[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3D&amp;#34;&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
plot(p1, p2, layout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), fmt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:png&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們一樣照順序將點標為藍色, 紅色以及綠色. 有趣的是, 我們發現這個 embedding 將整個 spiral curve &lt;strong&gt;打開了&lt;/strong&gt;. 因此, 經由 diffusion maps 投射之後我們比較榮以可以看出點資料真正在整個曲線上彼此間距離的遠近.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/DM_spiral_03.png&#34; alt=&#34;&#34; width=&#34;500px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;extension&#34;&gt;Extension&lt;/h2&gt;
&lt;p&gt;Diffusion maps 也常被拿來搭配 
&lt;a href=&#34;https://en.wikipedia.org/wiki/K-means_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k-means&lt;/a&gt; 做成分群演算法, 算是 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Spectral_clustering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spectral clustering&lt;/a&gt; 的其中一種.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Diffusion maps 的 &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;julia&lt;/code&gt; 以及 &lt;code&gt;matlab&lt;/code&gt; 程式都可以在這裡找到: 
&lt;a href=&#34;https://github.com/teshenglin/diffusion_maps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github - teshenglin/diffusion_maps&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Thin liquid films in a funnel</title>
      <link>https://teshenglin.github.io/publication/21_jfm_ldk/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/21_jfm_ldk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2021 Summer Research Internship</title>
      <link>https://teshenglin.github.io/courses/2021_summer_research/</link>
      <pubDate>Wed, 19 May 2021 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/2021_summer_research/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2021-暑期研究實習&#34;&gt;2021 暑期研究實習&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1vJ0LKWxjjpTvwlTxEwnRus77fKgSRyL3/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;海報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1g4zek59NaqxUbT1mbx_7K2KEDNXAuLET/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;研究實習辦法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://youtu.be/sFL47gziK30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;說明會錄影&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;各研究團隊說明&#34;&gt;各研究團隊說明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1TKMdkvROkfCE-BtSqu-40O7JdOkPpn1I/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;量子電腦投資組合最佳化&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;游家牧 - 
&lt;a href=&#34;mailto:chiamuyu@gmail.com&#34;&gt;chiamuyu@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1duzGRTSHBUBIdwtgzHhAzD-GroUp773c/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;訊號與影像處理&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;薛名成 - 
&lt;a href=&#34;mailto:mshiue@math.nctu.edu.tw&#34;&gt;mshiue@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;吳金典 - 
&lt;a href=&#34;mailto:ctw@math.nctu.edu.tw&#34;&gt;ctw@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1MIzVXC_qljcNoVXppBKve6OvF7LUbLTb/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;數學建模與機器學習&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;吳昌鴻 - 
&lt;a href=&#34;mailto:changhong@math.nctu.edu.tw&#34;&gt;changhong@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;林得勝 - 
&lt;a href=&#34;mailto:tslin@math.nctu.edu.tw&#34;&gt;tslin@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1fO83ISqJizCJppeJ78XlaxUwwl65_jCW/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AI與量化投資交易&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;康明軒 - 
&lt;a href=&#34;mailto:mhkang@math.nctu.edu.tw&#34;&gt;mhkang@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;鄧惠文 - 
&lt;a href=&#34;mailto:venteng@gmail.com&#34;&gt;venteng@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://drive.google.com/file/d/1qw5bEPD-7hXrmRCBxBCDHNvQx_9st1Oy/view?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可積系統專題&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;黃信元 - 
&lt;a href=&#34;mailto:hyhuang@math.nctu.edu.tw&#34;&gt;hyhuang@math.nctu.edu.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;實習報名&#34;&gt;實習報名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;請先與各團隊指導教授線上面談後填寫以下表單&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forms.gle/SBMPbUpzV7jbBdWv6&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;報名表單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;錄取名單&#34;&gt;錄取名單&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;量子電腦投資組合最佳化
&lt;ul&gt;
&lt;li&gt;施欣宜, 賴叡禹, 江皓霖, 翁翊豪, 張秀麗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;數位訊號與影像處理
&lt;ul&gt;
&lt;li&gt;張詠瑄, 郭庭佑, 王怡智&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;數學建模與機器學習
&lt;ul&gt;
&lt;li&gt;白宜平, 陳文皓, 林沛霆, 周品萱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AI與量化投資交易
&lt;ul&gt;
&lt;li&gt;戴晨洋, 李國誠, 蔡博凱, 王宣瑋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>主成分分析 - 2</title>
      <link>https://teshenglin.github.io/post/2020_principal_component_analysis_2/</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_principal_component_analysis_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們補充一下主成分分析裡的證明部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;假設我們有 $n$ 筆 $p$ 維的資料, 記成
$$
\{x_1, x_2, \cdots, x_n\} \in R^p.
$$
假設想要投影到 $k$ 維, $k\le p$, 數學上來說就是想要找到 $\mu$, $U$ 以及 $\beta_i$ 使得下式 $E$ 有最小值
$$
E = \sum_{i=1}^n \|x_i - (\mu + U\beta_i)\|^2,
$$
其中有兩個條件, $U^TU=I_k$, 以及 $\sum^n_{i=1} \beta_i=\vec{0}$.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;要求極值就是要找微分等於零的解, 由於這式子是 convex, 所以保證找到唯一解而且是最小的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;所以以下做法就是對每個變數做偏微分, 並求出偏微分等於零的解. 這樣就把最佳解找出來了!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1-首先看-mu&#34;&gt;1. 首先看 $\mu$&lt;/h4&gt;
&lt;p&gt;對 $\mu$ 做偏微分並且利用 $\sum^n_{i=1} \beta_i=\vec{0}$ 我們可以得到
$$
\partial_{\mu} E = -2 \left(\sum_i x_i - n\mu\right)=0.
$$
因此, 最佳的 $\mu$ 是
$$
\mu = \frac{1}{n}\sum_{i=1}^n x_i.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-接著找-beta_i&#34;&gt;2. 接著找 $\beta_i$&lt;/h4&gt;
&lt;p&gt;找到平均後我們將所有資料做平移使得中心為原點, 定 $y_i = x_i-\mu$, 我們有
$$
E = \sum_{i=1}^n \|y_i - U\beta_i\|^2.
$$
接著對 $\beta_i$ 微分得到
$$
\partial_{\beta_i} E = 2\left(\beta_i - U^Ty_i\right)=0.
$$
因此可以得到
$$
\beta_i = U^T y_i = \sum^k_{j=1}&amp;lt;u_j, y_i&amp;gt;,
$$
其中 $U=[u_1, \cdots, u_k]$.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-最後找-u&#34;&gt;3. 最後找 $U$&lt;/h4&gt;
&lt;p&gt;代入最佳的 $\beta_i$ 後我們又可將原本的 $E$ 改寫為
$$
E = \sum_{i=1}^n \|y_i - UU^Ty_i\|^2 = \|Y - UU^TY\|^2_F,
$$
其中 $Y=[y_1, \cdots, y_n]$, 而下標 $F$ 代表矩陣的 Frobenius norm.&lt;/p&gt;
&lt;p&gt;我們先定 $P = UU^T$, 則有 $P^T=P$, $P^2=P$. 接著我們改寫 $E$ 為
$$
E = \|Y - PY\|^2_F = trace\left[(Y-PY)^T(Y-PY)\right] = trace\left(Y^TY-Y^TPY\right).
$$
由於 $Y$ 不會變, 因此求 $E$ 的最小值變成求 $trace\left(-Y^TPY\right)$ 的最小值, 也就是求 $trace\left(Y^TPY\right)$ 的最大值, 換回來得到是求 $trace\left(Y^TUU^TY\right)$ 的最大值.&lt;/p&gt;
&lt;p&gt;接著我們用線性代數裡一個定理, $trace(AB)=trace(BA)$, 將原式轉換成求 $trace\left(U^TYY^TU\right)$ 的最大值, 最後得到
$$
\arg\min_U E = \arg\max_U trace\left(U^T\Sigma U\right),
$$
其中 $\Sigma=YY^T$ 也就是原資料的共變異數矩陣. 上式是個非常重要的式子, 它告訴我們以下兩件事是等價的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使得原始資料與投影後的資料之間的&lt;em&gt;&lt;strong&gt;距離平方和最小&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使得資料有&lt;em&gt;&lt;strong&gt;最大的變異性&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後, 線性代數告訴我們等號右邊這問題的解就是 $\Sigma$ 最大的 $k$ 個 eigenvalues 其相對應的 eigenvectors, 收集起來得到 $U=[u_1, \cdots, u_k]$.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上使用的線性代數結果, 其證明可見 
&lt;a href=&#34;https://math.stackexchange.com/questions/252272/is-trace-invariant-under-cyclic-permutation-with-rectangular-matrices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tr(AB)=tr(BA) proof&lt;/a&gt;, 以及 
&lt;a href=&#34;https://math.stackexchange.com/questions/1199852/maximize-the-value-of-vtav&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;maximize v^T Av&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;總結一下最佳解如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\mu$ 是原始資料的平均
$$
\mu = \frac{1}{n}\sum^n_{i=1} x_i
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到平均後我們將所有資料做平移使得中心為原點, 定 $y_i = x_i-\mu$, 求出這組新資料的共變異數矩陣 $\Sigma=YY^T$, 其中 $Y=[y_1, \cdots, y_n]$.&lt;/p&gt;
&lt;p&gt;對 $\Sigma$ 做譜分解(spectral decomposition), 找到其最大的 $k$ 個 eigenvalues 以及相對應的 eigenvectors, 將 eigenvectors 收集起來就得到 $U=[u_1, \cdots, u_k]$, 也就是 affine subspace 的 basis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將平移後的資料投影到子空間中得到 $\beta_i$, 也就是
$$
\beta_i = \sum^k_{j=1}&amp;lt;u_j, y_i&amp;gt;.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;references&#34;&gt;References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://sites.google.com/view/manifoldlearning2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NCTS mini-course on manifold learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://liorpachter.wordpress.com/2014/05/26/what-is-principal-component-analysis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is principal component analysis?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Multidimensional scaling</title>
      <link>https://teshenglin.github.io/post/2020_multi_dimensional_scaling/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_multi_dimensional_scaling/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Multidimensional scaling, 簡稱 MDS, 是個資料分析或是資料降維的工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要談一下從數學角度來說 MDS 的原理及做法, 更精確的說, 這裡講的是 classical MDS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;假設我們有 $n$ 筆 $p$ 維的資料, 記成
$$
\{x_1, x_2, \cdots, x_n\} \in \mathbb{R}^p
$$
那我們可以據此構造出一個距離平方矩陣 $D$, Euclidian distance matrix, 簡稱 EDM, 其中 $D_{ij} = \|x_i-x_j\|^2$, 也就是 $(x_i)$ 及 $x_j$ 這兩個點距離的平方.&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;舉例來說&#34;&gt;舉例來說&lt;/h5&gt;
&lt;p&gt;以下我們用 Matlab 隨機生出 $R^2$ 空間中的 $5$ 個點, 並求出他的 EDM:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
X = rand(2,5);                                  % R^2 中的 5 個點
D = squareform(pdist(X&#39;, &#39;squaredeuclidean&#39;));  % 求出其 EDM
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;D =
     0    0.3839    0.2333    0.2675    0.6373
0.3839         0    0.1571    0.1272    0.0470
0.2333    0.1571         0    0.0028    0.3725
0.2675    0.1272    0.0028         0    0.3222
0.6373    0.0470    0.3725    0.3222         0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可看出 EDM 的幾個性質&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一定是個對稱矩陣&lt;/li&gt;
&lt;li&gt;所有元素都非負&lt;/li&gt;
&lt;li&gt;對角線元素必為零&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;而 MDS 要做的事是以上的反問題:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假設我們拿到一個 EDM 矩陣, 我想要把它原始生成的點 $x_i$ 找出來.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;這樣子的問題稱為 classical MDS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;classical MDS 處理這些距離用 Euclidean distance 來量出來的矩陣.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;要講 MDS 做法之前我們先定義一個矩陣稱為&lt;strong&gt;置中矩陣&lt;/strong&gt; $H$, centering matrix, 也就是把一組資料平移使得其中心為坐標原點:
$$
H = I_n - \frac{1}{n}{\bf 1}{\bf 1}^T,
$$
其中 $I_n$ 是 $n\times n$ 的單位矩陣, ${\bf 1}$ 則是元素全為 $1$ 的 $n\times 1$ 向量.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以輕易看出來 $H$ 是一個對稱矩陣, $H^T=H$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若我們將原始資料收集一起成一個 $p\times n$ 矩陣 $X = [x_1, \cdots, x_n]$, 也就是把原始資料每一筆當成一個 column 排隊排好, 則有
$$
X H = X (I_n - \frac{1}{n}{\bf 1}{\bf 1}^T) = X - \frac{1}{n}\left(\sum_i x_i\right) {\bf 1}^T = X - \mu {\bf 1}^T = Y,
$$
其中 $\mu=\frac{1}{n}\sum_i x_i \in \mathbb{R}^p$ 就是原始資料的平均,
而 $Y=[y_1, \cdots, y_n]$, $y_i = x_i-\mu$, 也就是把每筆資料減去平均之後記成 $y_i$ 再排排站好.
所以的確 $XH$ 就是把資料平移使得其中心為坐標原點.&lt;/p&gt;
&lt;p&gt;推導一下後也可以發現, 若將每筆資料當成一個 row 擺好變成 $\hat{X}$,
則要用 $H\hat{X}$ 將資料做平移使資料中心為原點.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們有以下這個定理&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem&#34;&gt;Theorem&lt;/h2&gt;
&lt;p&gt;給定原始資料 $X = [x_1, \cdots, x_n]$, 且其相對應的 EDM 為 $D$, 則我們有
$$Y^T Y = -\frac{1}{2}HDH.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個定理證明很簡單.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;proof&#34;&gt;Proof&lt;/h3&gt;
&lt;h3 id=&#34;sketch-not-complete-please-full-in-the-details-by-yourself&#34;&gt;(Sketch, not complete, please full-in the details by yourself)&lt;/h3&gt;
&lt;p&gt;我們先重新整理一下這個 EDM 矩陣:
$$
\begin{aligned}
D_{ij} &amp;amp;= \|x_i-x_j\|^2 = &amp;lt;x_i-x_j, x_i-x_j&amp;gt; \\ &amp;amp;= &amp;lt;x_i, x_i&amp;gt; + &amp;lt;x_j, x_j&amp;gt; - 2&amp;lt;x_i, x_j&amp;gt;
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;接著我們定義一個 $n\times 1$ 向量 ${\bf k}$, 其中 ${\bf k}_i = &amp;lt;x_i, x_i&amp;gt;$, 則可以將 $D$ 改寫為
$$D = {\bf k}{\bf 1}^T + {\bf 1}{\bf k}^T - 2 X^TX.$$
接著兩邊乘上 $H$, 並利用 ${\bf 1}^T H = 0$ 以及 $H {\bf 1} = 0$ (分別將一個常數列向量以及常數行向量置中都會得到零向量), 我們可得
$$HDH = -2HX^TXH = -2(XH)^T(XH) = -2Y^TY.$$
故得證.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;這個定理告訴我們的是, 如果我們只知道一組資料的 EDM 矩陣 $D$, 那要怎樣把資料給還原回來.&lt;/p&gt;
&lt;h4 id=&#34;remark&#34;&gt;Remark&lt;/h4&gt;
&lt;p&gt;當然, 不可能把原始資料完全還原回來! 如同定理中所述我們所能算出的等號左邊是 $Y$, 也就是置中後的原始資料. 事實上我們也很容易想像, 若將一組資料平移或是旋轉後其 EDM 應該是完全不會變的. 也就是說我們若只知道 EDM, 則其原始資料應該有無限多解. 這裡所謂的還原回來是找到其中一組解, 其他所有可能的解則都可以將之&lt;strong&gt;平移&lt;/strong&gt;或&lt;strong&gt;旋轉&lt;/strong&gt;後得到.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;定理等號右邊由於是個對稱矩陣, 所以可以對角化為
$$
-\frac{1}{2}HDH = V\Lambda V^T = V\sqrt{\Lambda}\sqrt{\Lambda} V^T,
$$
其中 $\Lambda$ 是個對角矩陣包含所有特徵值, 而 $\sqrt{\Lambda}$ 則是將 $\Lambda$ 對角線元素都開根號.&lt;/p&gt;
&lt;p&gt;跟定理對照一下可以輕易地看出來, 平移後的原始資料點可以被還原出來: $Y = \sqrt{\Lambda}V^T$.&lt;/p&gt;
&lt;p&gt;這就是 classical MDS 的作法!! 非常簡單.&lt;/p&gt;
&lt;h4 id=&#34;remark-1&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;若原始資料 $x_i\in R^p$ (並假設排排站之後的 $X$ 其 rank 為 $p$), 則 $Y^TY$ 的 rank 為 $p$, 必有至少 $n-p$ 個為零的特徵值. 所以, 若我們將 $-\frac{1}{2}HDH$ 對角化後發現有 $m$ 個為零的特徵值, 表示原資料的 $p=n-m$, 那我們就把這些零特徵值都拿掉, 使 $\sqrt{\Lambda}$ 為一個 $p\times n$ 的矩陣, 這樣我們就有 $Y = \sqrt{\Lambda}V^T \in R^{p\times n}$.&lt;/p&gt;
&lt;h4 id=&#34;remark-2&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;若將 $Y$ 做奇異值分解 (Singular Value Decomposition, SVD), 得到
$$
Y = \hat{U}\hat{\Sigma}\hat{V}^T, \quad \hat{U}\in R^{p\times p}, \quad \hat{\Sigma}\in R^{p\times n}, \quad \hat{V}\in R^{n\times n},
$$
並且 $\hat{U}^T\hat{U}=I_p$ 以及 $\hat{V}^T\hat{V}=I_n$. 則 $Y^TY = \hat{V}\hat{\Sigma}^T\hat{\Sigma}\hat{V}^T$. 對照一下定理可以看出, 如果 $D$ 是個 EDM 矩陣, 那他的 eigenvalues 一定都是非負.&lt;/p&gt;
&lt;p&gt;依照上面兩個 remark 稍微整理一下 MDS 的做法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將 EDM 矩陣 $D$ 做 double centering 並乘以 $-1/2$ 求出 $-\frac{1}{2}HDH$.&lt;/li&gt;
&lt;li&gt;做對角化得到 $\Lambda$ 以及 $V$&lt;/li&gt;
&lt;li&gt;拿掉所有零特徵值及其相對應的特徵向量, 求出 $Y = \sqrt{\Lambda}V^T$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;一般來說我們會將 MDS 當成一個降維的工具, 希望在低維度(二或三, 或 $k$)找到一組資料使得其 EDM 與原始資料的 EDM 最像. 而作法就是保留前 $k$ 個特徵值及其特徵向量.&lt;/p&gt;
&lt;p&gt;給定一個 $n\times n$ 的 EDM 以及欲投影的維度 $k$, MDS 簡單的程式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
function Y = multidimensional_scaling(D, k)

%   Input: D, n*n EDM 矩陣, 元素為距離平方
%          k, 要降到的維度, k 為正整數, k&amp;lt;=p
%   Output: Y: k*n data matrix, k 個 features 以及 n 個 samples

    n = size(D, 1);                         % n 個 samples
    mu = sum(D, 1)/n; D = D - mu;           %
    mu = sum(D, 2)/n; B = D - mu;           %
    B = -0.5*B;                             % B = -0.5*H*D*H
    [V, D] = eig(B, &#39;vector&#39;);              % 求出特徵值及特徵向量
    [sqD, ind] = sort(sqrt(D), &#39;descend&#39;);  % 將特徵值按大小排列
    sqD = sqD(1:k);                         % 取前 k 個
    V = V(:, ind(1:k));                     % 取相對應的特徵向量
    Y = V&#39;.*(sqD*ones(1,n));                % 求出 k 維資料點
end
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;extension&#34;&gt;Extension&lt;/h2&gt;
&lt;p&gt;廣義一點的 MDS 可以想像是, 我們拿到的距離也許不是用歐式距離量的. 比如說手裡有許多照片, 照片與照片兩兩之間的距離就有非常多種測量的方式. 而不管是用什麼方式量的, 只要他們是 &lt;strong&gt;距離(metric)&lt;/strong&gt; , 我們就可以定出一個 $D$ 矩陣, 其中 $d_{ij}$ 就是 sample points $x_i$ 與 $x_j$ 之間的距離.&lt;/p&gt;
&lt;p&gt;接著我們可以定義一個 cost function, 稱之為 stress:
$$
Stress_D(x_1, \cdots, x_n) = \left(\sum_i\sum_j\left(d_{ij} - \|x_i-x_j\|\right)^2\right)^{1/2}.
$$
Metric Multidimensional scaling (mMDS) 要做的事就是要找到一組資料點 $\{x_1, \cdots, x_n\}$ 使得上式 stress 有最小值.&lt;/p&gt;
&lt;h4 id=&#34;remark-3&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;若 $D$ 是用廣義距離造出來的, 就無法保證 $-\frac{1}{2}HDH$ 這矩陣的特徵值都是正的. 不過我們依然可以用 classical MDS 的做法來做, 只是這時候我們會將所有負的特徵值全都丟掉.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;extension-1&#34;&gt;Extension&lt;/h2&gt;
&lt;p&gt;原始點資料若是在某個 weighted inner product space 裡, 內積定義為
$$
&amp;lt;x, y&amp;gt;_Q = x^TQy.
$$
則我們可以將原本的定理推廣如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem-1&#34;&gt;Theorem&lt;/h2&gt;
&lt;p&gt;$$Y^T QY = -\frac{1}{2}HDH.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;extension-classical-mds-vs-pca&#34;&gt;Extension: classical MDS v.s. PCA&lt;/h2&gt;
&lt;p&gt;給定 $n$ 筆 $p$ 維的資料, 記成
$$
\{x_1, x_2, \cdots, x_n\} \in R^p,
$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我們可以造出其 EDM, 再用 classical MDS 投影到 $k$ 維.&lt;/li&gt;
&lt;li&gt;我們也可以直接用 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_principal_component_analysis&#34;&gt;PCA&lt;/a&gt; 投影到 $k$ 維.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有趣的是以上兩個做法得到完全相同的結果.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不管 PCA 或 classical MDS 最後都是考慮置中後的資料, 所以我們只需看 $Y$ 即可, $y_i = x_i-\mu$, 而 $\mu$ 是平均數.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;PCA 是對 $\Sigma = YY^T$ 做 spectral decomposition&lt;/li&gt;
&lt;li&gt;classical MDS 是對 $Y^TY$ 做 spectral decomposition&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若將 $Y$ 做 SVD 得到 $Y = \hat{U}\hat{\Sigma}\hat{V}^T$, 則&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PCA 我們知道最後投影的結果為 $B = \hat{\Sigma}\hat{V}^T$&lt;/li&gt;
&lt;li&gt;classical MDS 我們也是投影到 $\hat{\Sigma}\hat{V}^T$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以雖然出發點不同, 不過結果真的一模一樣.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PCA = classical MDS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;references&#34;&gt;References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://sites.google.com/view/manifoldlearning2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NCTS mini-course on manifold learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://liorpachter.wordpress.com/2014/05/26/what-is-principal-component-analysis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is principal component analysis?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://youtu.be/Yt0o8ukIOKU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GeostatsGuy Lectures - Multidimensional Scaling&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>主成分分析</title>
      <link>https://teshenglin.github.io/post/2020_principal_component_analysis/</link>
      <pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_principal_component_analysis/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;主成分分析, Principal component analysis, 簡稱 PCA, 是個資料分析或是資料降維的工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;資料降維簡單來說, 假設我們有一些資料, 這資料中的每一筆維度都很高, 導致我們很難 &amp;ldquo;看出&amp;rdquo; 或 &amp;ldquo;分析&amp;rdquo; 這資料集的特性, 這時候我們就會想要在低維度空間裡(通常三維以下)建構一組點資料, 並且想辦法使新的這組點資料在某些程度上能表示出原本高維度的點資料, 或保有某種特性. 這種將高維度資料在低維度表現出來的方式就稱為資料降維. 而 PCA 就是其中一種線性降維的方式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要談一下從數學角度來說 PCA 的原理及做法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;假設我們有 $n$ 筆 $p$ 維的資料, 記成
$$
\{x_1, x_2, \cdots, x_n\} \in R^p
$$
那我們想要做以下等價的兩件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到一組低維度的投影並且使得資料有 &lt;em&gt;&lt;strong&gt;最大的變異性&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;找到一組低維度的投影並且使得原始資料與投影後的資料之間的 &lt;em&gt;&lt;strong&gt;距離平方和最小&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;remark&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;這裡所謂低維度的投影講精確一點, 事實上是在原本的 $R^p$ 空間中找到一個低維度的仿射子空間(affine subspace), 可以想像成一個不穿過原點的點或直線或平面, 找到之後再把原始資料點投影上去.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;example-投影到-0-維&#34;&gt;Example: 投影到 $0$ 維&lt;/h3&gt;
&lt;p&gt;先舉一個最簡單的例子, 假設我們想要投影到 $0$ 維, 也就是投影到一個點.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是說我們想要找一個點來代表整組資料.&lt;/p&gt;
&lt;p&gt;直覺上來想, 如果我要幫一組資料找一個最具代表性的點, 應該就會用 &amp;ldquo;平均數&amp;rdquo; 或 &amp;ldquo;中位數&amp;rdquo; 來當這個點.&lt;/p&gt;
&lt;p&gt;不過這邊我們需要講清楚的是究竟是以何種機制來做選擇的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PCA 的做法就是要找一個點 $\mu\in R^p$ 使得所有資料點到這個點的距離平方和最小, 也就是要讓下式有最小值
$$
\sum_{i=1}^n \|x_i - \mu\|^2.
$$
簡單的微分求極值我們可以得到其最佳解為
$$
\mu = \frac{1}{n}\sum^n_{i=1} x_i,
$$
也就是原始資料點的平均值.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我們想要的是&amp;quot;距離&amp;quot;和最小而不是&amp;quot;距離平方&amp;quot;和, 也就是要使下式最小,
$$
\sum_{i=1}^n \|x_i - \mu\|,
$$
則最佳解為資料的中位數. 證明可見 
&lt;a href=&#34;https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-l-1-norm#:~:text=111-,The%20Median%20Minimizes%20the%20Sum,Deviations%20%28The%20L1%20Norm%29&amp;amp;text=is%20minimal%20if%20x%20is%20equal%20to%20the%20median&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Median minimizes sum of absolute deviations&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;example-投影到-1-維&#34;&gt;Example: 投影到 $1$ 維&lt;/h3&gt;
&lt;p&gt;投影到 $0$ 維也許過於簡化, 接著我們來投影到 $1$ 維試試, 我們直接用圖形來說明:















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_pca_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_pca_01.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

藍色小圈就是原始資料點, 共10筆資料. 而 PCA 要做的事就是找到一個一維的 affine subspace, 就是中間那條斜線. 這樣我們就能把原始資料都投影到這個子空間去, 投影後的資料就是紅色點.&lt;/p&gt;
&lt;p&gt;而這 affine subspace 怎麼找到的呢, 事實上這個子空間就是使得所有虛線段(原始資料到投影點連線)距離平方加起來最小的那個.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下來我們來定義更一般的投影, 假設想要投影到 $k$ 維, $k\le p$, 也就是我們想要在 $R^p$ 空間中找一個 $k$ 維的 affine subspace, 使得說投影後資料與原始資料的距離平方和最小. 數學上來說就是要讓下式有最小值
$$
\sum_{i=1}^n \| x_i - (\mu + U\beta_i)\|^2,
$$
其中未知數有 $\mu\in R^p$, $U\in R^{p\times k}$, 以及 $\beta_i\in R^{k\times 1}$.&lt;/p&gt;
&lt;p&gt;稍微解釋一下以上這些變數:&lt;/p&gt;
&lt;p&gt;事實上這個 affine subspace 可以表示成
$$
\mu + V, \quad V = span\{u_1, \cdots, u_k\},
$$
其中 $\mu$ 是 $R^p$ 空間中的一個點, $\{u_1, u_2, \cdots, u_k\}$ 是這 affine subspace 的基底, 收集在一起構成 $U$, 也就是 $U=[u_1, u_2, \cdots, u_k]$. 而 $\mu + U\beta_i$ 就是 $x_i$ 這個資料點在這 affine subspace 上的投影, 所以 $\beta_i$ 可以想像是原始資料第 $i$ 筆投影到 affine subspace 之後的座標, 或是係數.&lt;/p&gt;
&lt;p&gt;此外, 我們可以特別要求這基底要正交, 也就是 $U^TU = I_k$, 其中 $I_k$ 表示 $k\times k$ 的 identity matrix.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再稍微整理一下, 我們想要找到 $\mu$, $U$ 以及 $\beta_i$ 使得下式 $E$ 有最小值
$$
E = \sum_{i=1}^n \|x_i - (\mu + U\beta_i)\|^2,
$$
其中有兩個條件, $U^TU=I_k$, 以及 $\sum^n_{i=1} \beta_i=\vec{0}$.&lt;/p&gt;
&lt;h4 id=&#34;remark-1&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;第二個條件 $\sum_i \beta_i=\vec{0}$ 看起來似乎是憑空冒出來的, 不過這可以從兩方面來說.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我們希望投影之後的解他們的平均是 $0$, 所以新資料點的中心就在新座標原點的位置.&lt;/li&gt;
&lt;li&gt;數學上來說, 其實 $\mu$ 並沒有唯一性. 也就是雖然 affine subspace 表示成 $\mu +V$, 但是這個 $\mu$ 是這子空間裡的任何一個點都可以. 為了讓解有唯一性我們加了這個條件.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;這問題可以被完全解出來, 也就是說給定 $x_i$, 我們可以決定出最佳的 $\mu$, $U$ 以及 $\beta_i$ 使得上式的值為最小.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推導過程我們在這先省略, 有興趣的請見 references, 或是 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_principal_component_analysis_2&#34;&gt;主成分分析 - 2&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其最佳解整理如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\mu$ 就剛好是投影到 $0$ 維的解, 也就是資料點的平均:
$$
\mu = \frac{1}{n}\sum^n_{i=1} x_i
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到平均後我們將所有資料做平移使得中心為原點, 定 $y_i = x_i-\mu$, 求出這組新資料的共變異數矩陣 $\Sigma=YY^T$, 其中 $Y=[y_1, \cdots, y_n]$ 是個 $p\times n$ 的矩陣, 而 $\Sigma$ 則是 $p\times p$.&lt;/p&gt;
&lt;p&gt;對 $\Sigma$ 做譜分解(spectral decomposition), 找到其最大的 $k$ 個 eigenvalues 以及相對應的 eigenvectors, 將 eigenvectors 收集起來就得到 $U=[u_1, \cdots, u_k]$, 也就是 affine subspace 的 basis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將原資料投影到此 affine subspace 中得到 $\beta_i$, 也就是
$$
\beta_i = \sum^k_{j=1}&amp;lt;u_j, (x_i-\mu)&amp;gt;
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;一般最基礎的 PCA 做法就是從 $x_i$, 得到 $\mu$. 將資料平移求出 $y_i$, 接著求共變異數矩陣 $\Sigma$. 接著對 $\Sigma$ 做 eigen-decomposition 求出其特徵值及特徵向量. 拿出最大的幾個就可以定出 affine subspace. 然後將 $y_i$ 投影下去就得到 $\beta_i$, 也就是投影之後的座標了.&lt;/p&gt;
&lt;p&gt;以上這做法的 &lt;code&gt;Matlab&lt;/code&gt; 程式如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$X$ 是 $p\times n$ 的 data matrix 含有 $p$ 個 features 以及 $n$ 個 samples.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;投影到 $k$ 維子空間, 投影後得到 $B$, 為 $k\times n$ 的 data matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
function B = principal_component_analysis(X, k)

%   Input: X, p*n data matrix, p 個 features 以及 n 個 samples
%          k, 要降到的維度, k 為正整數, k&amp;lt;=p
%   Output: B: k*n data matrix, k 個 features 以及 n 個 samples

    [p, n] = size(X);               % p 個 features 以及 n 個 samples
    mu = sum(X, 2)/n;               % 計算 sample 的平均 mu
    Y = X - mu*ones(1,n);           % 資料平移得到 Y
    S = Y*Y&#39;;                       % 求出共變異數矩陣 S
    [U, D] = eig(S, &#39;vector&#39;);      % 求出特徵值 D 及特徵向量 U
    [D, ind] = sort(D, &#39;descend&#39;);  % 將特徵值由大到小排列
    U = U(:, ind);                  % 將特徵向量照樣排列
    B = U(:,1:k)&#39;*Y;                % 投影到前 k 個組成的空間中並求出係數 B
end
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;remark-2&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;這做法會造出一個 $p\times p$ 的共變異數矩陣 $\Sigma$, 並且算出全部的特徵值及特徵向量. 不過其實我們只需要前 $k$ 個. 所以多出來的部分會丟掉, 有點浪費.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們再來看一下這個共變異數矩陣 $\Sigma=YY^T$, 可以很輕易地看出來這是個對稱矩陣, 所以特徵值一定是實數, 也一定存在 orthonormal 的實數特徵向量組. 因此我們以上的要求(將特徵值按大小排列, 特徵向量要彼此正交)都一定做得到. 而分解之後可以得到
$$
\Sigma = U\Lambda U^T,
$$
其中 $U$ 是個 $p\times p$ 矩陣.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事實上由 $\Sigma=YY^T$ 可以知道 $\Sigma$ 一定是個半正定矩陣, 所以它的 eigenvalues 一定都非負.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們事實上可以將矩陣 $Y$ 做奇異值分解 (Singular Value Decomposition, SVD), 得到
$$
Y = \hat{U}\hat{\Sigma}\hat{V}^T, \quad \hat{U}\in R^{p\times p}, \quad \hat{\Sigma}\in R^{p\times n}, \quad \hat{V}\in R^{n\times n},
$$
並且 $\hat{U}$ 及 $\hat{V}$ 都是 orthogonal matrix, 也就是 $\hat{U}^T\hat{U}=I_p$ 以及 $\hat{V}^T\hat{V}=I_n$.&lt;/p&gt;
&lt;p&gt;既然我們有 $\Sigma=YY^T$, 很容易可以看出來其實
$$
U = \hat{U}, \quad \Lambda = \hat{\Sigma}\hat{\Sigma}^T\in R^{p\times p}.
$$
也就是說將 $Y$ 的 singular values 平方就可以得到 $\Sigma$ 的 eigenvalues. 而 $Y$ 的 left singular vectors 事實上就是 $\Sigma$ 的 eigenvectors.&lt;/p&gt;
&lt;p&gt;而投影後的係數我們可以算一下:
$$
B=U^TY = \hat{U}^T\hat{U}\hat{\Sigma}\hat{V}^T = \hat{\Sigma}\hat{V}^T.
$$
所以如果我們只需要投影後的係數, 將 $Y$ 做 SVD 並且我們需要的是 $Y$ 的 right singular vectors.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;remark-3&#34;&gt;Remark:&lt;/h4&gt;
&lt;p&gt;以上這式子很有趣, 告訴我們投影之後的座標 $B$ 與投影之前的座標 $Y$ 的 SVD 之間的關係.
另一種降維方法: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_multi_dimensional_scaling&#34;&gt;Multidimensional scaling (MDS)&lt;/a&gt; 在某些情況下會有一模一樣的關係. 這樣就把兩種方法 PCA 跟 MDS 連在一起了. 雖然出發點不一樣, 竟然(在某些情況下)結果是一樣的!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;利用以上關係我們可以將程式改寫如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
function B = principal_component_analysis2(X, k)

%   Input: X, p*n data matrix, p 個 features 以及 n 個 samples
%          k, 要降到的維度, k 為正整數, k&amp;lt;=p
%   Output: B: k*n data matrix, k 個 features 以及 n 個 samples

    [p, n] = size(X);               % p 個 features 以及 n 個 samples
    mu = sum(X, 2)/n;               % 計算 sample 的平均, mu
    Y = X - mu*ones(1,n);           % 資料平移得到 Y
    [~, S, V] = svds(Y, k);         % 將 Y 做奇異值分解並取前 k 個 eigenvectors
    B = S*V&#39;;                       % 求出投影後的係數
end
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;而事實上, matlab 已經內建 PCA 程式了, 所以其實完全不用自己寫. 只是要注意一下 matlab 裡 PCA 的輸入 sample points 是 $n\times p$, 由於我們以上都是將 $X$ 設成 $p\times n$ 的矩陣, 所以要轉置一下, 程式只有兩行, 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
[U, B] = pca(X&#39;);
B = B(:,1:k)&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;working-example&#34;&gt;Working example&lt;/h1&gt;
&lt;p&gt;這裡我們舉一個例子, 我們先構造 sample points, 是一個類似螺旋狀結構, 程式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% Matlab program
n = 1000;                                   % 取 n 個點
t = 3*pi*(1:n)/n;                           % 利用參數化來構造, 取 t\in[0, 3*pi]
X = [t.*cos(t); 5*rand(1,n); t.*sin(t)];    % 先利用 random 構造三圍中的一個面
M = makehgtform(&#39;axisrotate&#39;,[1 1 1], 30);  % 構造旋轉矩陣
X = M(1:3, 1:3)*X + 10*rand(3,1)*ones(1,n); % 將 sample 旋轉並且隨機平移
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其圖形長這樣:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scatter3(X(1,:), X(2,:), X(3,:), [], (1:n)/n, &#39;fill&#39;)
&lt;/code&gt;&lt;/pre&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_pca_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_pca_02.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;接著我們用 PCA 投影到二維, 圖形長這樣:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[~, B] = pca(X&#39;);
B=B&#39;;
scatter(B(1,:), B(2,:), [], (1:n)/n, &#39;fill&#39;)
&lt;/code&gt;&lt;/pre&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_pca_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_pca_03.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;可以發現 PCA 找到一個正確的軸來做投影, 使得原本的螺旋線可以看得很清楚.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;extension&#34;&gt;Extension&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;另一種降維方法: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_multi_dimensional_scaling&#34;&gt;Multidimensional scaling (MDS)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;PCA 推導過程及證明: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_principal_component_analysis_2&#34;&gt;主成分分析 - 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;references&#34;&gt;References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://sites.google.com/view/manifoldlearning2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NCTS mini-course on manifold learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://liorpachter.wordpress.com/2014/05/26/what-is-principal-component-analysis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is principal component analysis?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Graduate student workshops</title>
      <link>https://teshenglin.github.io/courses/gsw/</link>
      <pubDate>Tue, 04 Aug 2020 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/gsw/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2021&#34;&gt;2021&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://sites.google.com/mail.nuk.edu.tw/2021twsiamstudentmeeting&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2021 Graduate Students Meeting on Applied Mathematics&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2020&#34;&gt;2020&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://ppt.cc/f2RBWx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2020 Summer Workshop for Scientific Computing&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://sites.google.com/go.nuk.edu.tw/2020amsc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Workshop on Applied Mathematics and Scientific Computing&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2019&#34;&gt;2019&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://sites.google.com/view/twsiam-nctu/%e6%bc%94%e8%ac%9b%e6%b4%bb%e5%8b%95/2019626-2019-graduate-student-meeting-on-applied-mathematics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Graduate Student Meeting on Applied Mathematics&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Effect of driving on coarsening dynamics in phase-separating systems</title>
      <link>https://teshenglin.github.io/publication/20_non_talt/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/20_non_talt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Courses taught</title>
      <link>https://teshenglin.github.io/courses/taught/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/taught/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2023-fall&#34;&gt;2023 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linear algebra (1):&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Differential Equations:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2023-spring&#34;&gt;2023 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Computational Mathematics&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applied Mathematics Methods&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2022-fall&#34;&gt;2022 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2022-spring&#34;&gt;2022 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (2):&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/2021calculus2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Computational Mathematics&lt;/strong&gt; 
&lt;a href=&#34;https://tulip-stamp-c53.notion.site/Computational-Mathematics-3a67f78f167f4bbf950b9908be2811f3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Notion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2021-fall&#34;&gt;2021 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (1):&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/2021calculus1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Introduction to Machine Learning&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/2021machinelearning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;, 
&lt;a href=&#34;https://hackmd.io/@teshenglin/2021machinelearning_lin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part I&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2021-spring&#34;&gt;2021 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linear algebra (2):&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/la2_syllabus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applied Mathematics Methods&lt;/strong&gt; 
&lt;a href=&#34;https://www.notion.so/Applied-Mathematics-Methods-4e19750f9b0047c6b4ae3789f444f56a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Notion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2020-fall&#34;&gt;2020 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linear algebra (1):&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/la_syllabus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Introduction to Practice of Mathematics Software:&lt;/strong&gt; 
&lt;a href=&#34;https://hackmd.io/@NYCUAM/BJVxDJVJ2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Syllabus&lt;/a&gt;; 
&lt;a href=&#34;https://hackmd.io/@teshenglin/ms_project&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;期末專題作品集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2020-spring&#34;&gt;2020 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (2):&lt;/strong&gt; 
&lt;a href=&#34;https://piazza.com/demo_login?nid=k51uwl2ir6z4pr&amp;amp;auth=4cdef20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Piazza&lt;/a&gt;, 
&lt;a href=&#34;https://www.piazza.com/stats/report/k51uwl2ir6z4pr?mc_id=cr_1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;piazza report&lt;/a&gt;, 
&lt;a href=&#34;https://teshenglin.github.io/tags/applied-project/&#34;&gt;Applied projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Numerical Methods for Partial Differential Equations:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2019-fall&#34;&gt;2019 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (1):&lt;/strong&gt; 
&lt;a href=&#34;https://piazza.com/demo_login?nid=jzxisxpsg422ww&amp;amp;auth=e156da1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Piazza&lt;/a&gt;, 
&lt;a href=&#34;https://www.piazza.com/stats/report/jzxisxpsg422ww?mc_id=cr_1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;piazza report&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2019fall_colloquium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Colloquium&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2019-spring&#34;&gt;2019 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (2)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Introduction to Partial Differential Equations:&lt;/strong&gt; 
&lt;a href=&#34;https://piazza.com/demo_login?nid=js5xmev3tbf4yl&amp;amp;auth=30f892e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Piazza&lt;/a&gt;, 
&lt;a href=&#34;https://www.piazza.com/stats/report/js5xmev3tbf4yl?mc_id=cr_1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;piazza report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2018-fall&#34;&gt;2018 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Introduction to Practice of Mathematics Software&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2018-spring&#34;&gt;2018 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (2):&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Computational mathematics:&lt;/strong&gt; 
&lt;a href=&#34;https://piazza.com/demo_login?nid=jcb5154fcku290&amp;amp;auth=8768c90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Piazza&lt;/a&gt;, 
&lt;a href=&#34;https://www.piazza.com/stats/report/jcb5154fcku290?mc_id=cr_1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;piazza report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2017-fall&#34;&gt;2017 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Calculus (1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vector Calculus&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2017-spring&#34;&gt;2017 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service - Learning (2)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applied Mathematics Methods&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2016-fall&#34;&gt;2016 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service - Learning (1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Introduction to Practice of Mathematics Software&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2016fall_colloquium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Colloquium&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2016-spring&#34;&gt;2016 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Applied Mathematics Methods&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;
&lt;a href=&#34;https://teshenglin.github.io/courses/2016spring_colloquium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Colloquium&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2015-fall&#34;&gt;2015 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service - Learning (1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Numerical Analysis&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topical mathematical modeling and computing (1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2015-spring&#34;&gt;2015 Spring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service - Learning (2)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Calculus (2)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applied Mathematics Methods&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2014-fall&#34;&gt;2014 Fall&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service - Learning (1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topical mathematical modeling and computing (1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Student supervised</title>
      <link>https://teshenglin.github.io/courses/students/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/students/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;phd-students&#34;&gt;PhD students&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Chiu-Yao He (何秋瑤)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;master-students&#34;&gt;Master students&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;李玉萱&lt;/li&gt;
&lt;li&gt;郭昱婕&lt;/li&gt;
&lt;li&gt;王詠慈 (Co-advised with Prof. Chiun-Chang Li)&lt;/li&gt;
&lt;li&gt;林顯堯&lt;/li&gt;
&lt;li&gt;唐翊瑄 (Co-advised with Prof. Chiun-Chang Li)&lt;/li&gt;
&lt;li&gt;楊家睿&lt;/li&gt;
&lt;li&gt;蔡宛玲&lt;/li&gt;
&lt;li&gt;陳重凱&lt;/li&gt;
&lt;li&gt;官恩琳&lt;/li&gt;
&lt;li&gt;Ching-Ru Chung (鍾俊儒) - graduated 2023-08&lt;/li&gt;
&lt;li&gt;Guan-Yu Lai (賴冠宇) - graduated 2023-07&lt;/li&gt;
&lt;li&gt;Tang-Syuan Tseng (曾堂軒) - graduated 2022-08&lt;/li&gt;
&lt;li&gt;Chia-Chen Yang (楊珈禎) - graduated 2022-08&lt;/li&gt;
&lt;li&gt;Yu-Jie Ho (何禹潔) - graduated 2022-07&lt;/li&gt;
&lt;li&gt;Yi-Lin Zheng (鄭怡琳) - graduated 2022-07&lt;/li&gt;
&lt;li&gt;Ya-Wei Hseih (謝亞衛) - graduated 2022-07&lt;/li&gt;
&lt;li&gt;Hau-An Kao (高浩恩) - graduated 2022-02&lt;/li&gt;
&lt;li&gt;Fang-Yu Lee (李芳妤) (Co-advised with Prof. Chiun-Chang Li) - graduated 2021-07&lt;/li&gt;
&lt;li&gt;Chien-Hao Wu (巫健豪)&lt;/li&gt;
&lt;li&gt;Yun-Yu Wang (王云郁) - graduated 2020-02&lt;/li&gt;
&lt;li&gt;Yi-Chen Chen (陳逸蓁) - graduated 2019-08&lt;/li&gt;
&lt;li&gt;Yi-Ting Chen (陳奕廷) - graduated 2019-07&lt;/li&gt;
&lt;li&gt;Pei-Wen Luo (羅珮文) - graduated 2018-07&lt;/li&gt;
&lt;li&gt;Chung-Hsuan Liu (劉仲軒) - graduated 2018-07&lt;/li&gt;
&lt;li&gt;Thu-Hsu Chen (陳慈煦) (Co-advised with Prof. Yi-Wen Liu) - graduated 2018-07&lt;/li&gt;
&lt;li&gt;Cheng Chiu (邱晟) - graduated 2017-07&lt;/li&gt;
&lt;li&gt;Chiu-Yao He (何秋瑤) - graduated 2016-07&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;undergraduate-project-students&#34;&gt;Undergraduate project students&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Wan-Ling Tsai (蔡宛玲)&lt;/li&gt;
&lt;li&gt;Ching-Ru Chung (鍾俊儒)&lt;/li&gt;
&lt;li&gt;Yu-Jie Ho (何禹潔)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.10.3 - 極座標曲線家族</title>
      <link>https://teshenglin.github.io/post/2020_cal_s10p3_ch/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s10p3_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Laboratory Project in Sec.10.3, Calculus by Stewart
English version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s10p3&#34;&gt;Families of Polar Curves&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這個研究中，你將發現極座標曲線家族有趣又漂亮的形狀。同時，當常數改變時，你也會觀察到曲線形狀的變化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a) 探討以下列極座標方程式： $r=\sin(n\theta)$ 定義的曲線家族，其中 $n$ 為正整數。請問圖形中的環的數量與 $n$ 有何關係？&lt;/p&gt;
&lt;p&gt;(b) 若將 (a) 中方程式改成 $r= |\sin(n\theta)|$ ，會發生什麼事？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a)&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_1.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;
















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_2.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;我們發現當 $n$ 為奇數, 環的數量為$n$, 而當 $n$ 為偶數, 環的數量為$2n$.&lt;/p&gt;
&lt;p&gt;(b)&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_3.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_3.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;我們發現環的數量恆為$2n$ 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一曲線家族由方程式 $r=1+c\sin(n\theta)$ 定義，其中 $c$ 為實數，$n$ 為正整數。請問隨 $n$ 值增加，曲線圖形會如何改變？隨 $c$ 值改變，圖形又會如何改變？繪出此曲線家族中足夠的成員來說明，以支持你的結論。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$c=1$, $n=1$















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_4.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_4.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$c=1$, $n=2$















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_9.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_9.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$c=1$, $n=3$















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_10.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s10p3_10.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;隨 $n$ 值增加，環數增加，環數等於 $n$，當 $|c|&amp;gt;1$，則環數等於 $2n$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$c$ 值的絕對值增加，使圖形多出 $n$ 個小環後，小環和大環會漸漸變大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n=1$

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/iGdYNHExGj4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n=2$

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/pSkd6K3psHw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n=3$

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/VXR2MjaYQjc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一曲線家族有極座標方程式 $r= \frac{1-acos\theta}{1+acos\theta}$, 探討隨$a$ 值改變，圖形會如何改變。你應該特別辨別曲線基本形狀改變時的$a$ 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隨著 $a$ 絕對值增加，圓形逐漸變桃型，當$|a|&amp;gt;1$ ，桃型尖端向內形成另一小環。隨 $a$ 值增加，小環逐漸變大。&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/wogB45xcXdA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;天文學家喬凡尼·多美尼科·卡西尼 (1625-1712) 研究有極座標方程式 $r^4 -2c^2r^2\cos(2\theta)+c^4-a^4=0$ 的曲線家族，其中 $a$ 和 $c$ 為正實數。這些曲線叫做&lt;strong&gt;卡西尼卵形線&lt;/strong&gt;，即便它們只有在特定 $a$ 值和 $c$ 值才會呈卵形。（卡西尼認為這些曲線，比起克卜勒的橢圓，可能更能代表行星軌道。）探討這些曲線的各種形狀。尤其，當曲線裂成兩部分時，$a$ 和 $c$ 彼此關係為何？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$a=1$

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/NUpHIoy9dsc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$c=1$

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/6kNj_GaEeUo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;卡西尼卵形線主要有三種形狀，倒8形狀、包含兩焦點的環以及各包含一焦點的兩環。當環曲線裂成兩部分時，代表在極座標中的某些$\theta$ 值，$r$ 不存在。&lt;/p&gt;
&lt;p&gt;令 $A=r^2$, 方程式可以改寫成 $A^2- 2c^2A \cos(\theta) +c^4 -a^4 =0$. 此二次方程式的判別式為
$$
D = 4c^4 cos^2(2\theta) -4(c^4 -a^4) = 4\left(a^2-c^2\sin^2(2\theta)\right)
$$
當 $|a|&amp;lt;|c|$，將存在某些$\theta$ 值， $D&amp;lt;0$, 則 $A$ 無實數解因此 $r$ 不存在。&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.14.7 - Designing a dumpster</title>
      <link>https://teshenglin.github.io/post/2020_cal_s14p7/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s14p7/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.14.7, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s14p7_ch&#34;&gt;設計垃圾桶&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For this project we locate a rectangular trash Dumpster in order to study and describe all its shape and construction. We then attempt to determine the dimensions of a container of similar design that minimize construction cost.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First locate a trash dumpster in your area. Carefully study and describe all details of its construction, and determine its volume. Include a sketch of the container.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer：&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p7_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p7_1.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Width $x = 0.2 (m)$&lt;/li&gt;
&lt;li&gt;Length $y = 0.25 (m)$&lt;/li&gt;
&lt;li&gt;Height $z = 0.3 (m)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
volume = 0.2 \times 0.25 \times 0.3 = 0.015 (m^3)
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While maintaining the general shape and method of construction, determine the dimensions such a container of the same volume should have in order to minimize the cost of construction. Use the following assumptions in your analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sides, back, and front are to be made from 12-gauge ($2.657 (mm)$ thick) steel sheets, which cost $8.00 per square foot (including any required cuts or bends).&lt;/li&gt;
&lt;li&gt;The base is to be made from a 10-gauge ($3.416 (mm)$ thick) steel sheet, which costs $10.00 per square foot.&lt;/li&gt;
&lt;li&gt;Lids cost approximately $50.00 each, regardless of dimensions.&lt;/li&gt;
&lt;li&gt;Welding costs approximately $0.60 per square meter for material and labor combined.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Give justification of any further assumptions or simplifications made of the details of construction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;From these figures the cost equation of a rectangular dumpster was determined to be:
$$
8\times 2\times (x+y)\times z+10xy+50+0.6\times (2x+2y+4z)
$$
Where the dimensions are based on a 3-dimentional graph, Width=x, Length=y, and Height=z. It is also known that the dumpster volume will have to equal to $0.015 (m^3)$, i.e.,
$$
xyz=0.015\ or\ z=\frac{0.015}{xy}
$$
so the expression for Total Cost $(f)$ becomes
$$
f=0.24\left(\frac{1}{x}+\frac{1}{y}\right)+10xy+50+1.2x+1.2y+\frac{0.036}{xy}
$$
To have a minimum we should have $f_x=f_y=0$ where
$$
f_x=\frac{-0.24}{x^2}+10y+1.2-\frac{0.036}{x^2y}\&lt;br&gt;
f_y=\frac{-0.24}{y^2}+10x+1.2-\frac{0.036}{xy^2}
$$
Since $x$ and $y$ must be positive in this problem, we have $x=y$. We then get $10x^4+ 1.2x^3 -0.24x -0.036=0$ that has only one positive root $x\approx 0.295$.&lt;/p&gt;
&lt;p&gt;So we find Total cost is about $53.6.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Describe how any of your assumptions or simplifications may affect the actual result.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since the length of the side is much bigger then it&amp;rsquo;s thickness we simply ignore the thickness.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you were hired as a consultant on this investigation, what would your conclusion be? Would you recommend altering the design of the dumpster? If so, describe the savings that would result.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The cost of the original trash dumpster is $53.92, which is larger than the dumpster we design. So we would recommend altering the design of the dumpster, and we can save about $0.3.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.14.7 - 設計垃圾桶</title>
      <link>https://teshenglin.github.io/post/2020_cal_s14p7_ch/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s14p7_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.14.7, Calculus by Stewart&lt;br&gt;
English version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s14p7&#34;&gt;Designing a dumpster&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這個專題中，我們先測量出一個長方體垃圾桶出他的外型和結構。希望設計出一個和它一樣大的容器，並將所需的花費最小化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，測量垃圾桶的大小，形狀和體積，並畫出垃圾桶的圖案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p7_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p7_1.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;長 $x = 0.2 (m)$&lt;/li&gt;
&lt;li&gt;寬 $y = 0.25 (m)$&lt;/li&gt;
&lt;li&gt;高 $z = 0.3 (m)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
體積 = 0.2 \times 0.25 \times 0.3 = 0.015 (m^3)
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;維持垃圾桶大概的形狀，設計出一個體積和原垃圾桶相同而且價格最便宜的容器。使用下列條件進行分析:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前後和側邊都是用12-gauge (厚度 $2.657$ 毫米) 的鋼板做成，價格為每平方公尺$8.00&lt;/li&gt;
&lt;li&gt;底部是由10-gauge (厚度 $3.416$ 毫米) 的鋼板製成，價格為每平方公尺 $10.00&lt;/li&gt;
&lt;li&gt;蓋子不論大小，每片約 $50.00&lt;/li&gt;
&lt;li&gt;焊接的價格為每公尺 $0.60&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自行提出其他假設，敘述所設計的容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從上面的規定，我們可以算出長方體容器價格的方程式:
$$
8\times 2\times (x+y)\times z+10xy+50+0.6\times (2x+2y+4z)
$$
其中x是寬，y是長，z是高 ，容器的體積和垃圾桶一樣，為$0.015 m^3$ ，因此我們可以得到：
$$
xyz=0.015\ or\ z=\frac{0.015}{xy}
$$
所以可以將花費的式子 $f$ 改寫成：
$$
f=0.24\left(\frac{1}{x}+\frac{1}{y}\right)+10xy+50+1.2x+1.2y+\frac{0.036}{xy}
$$
如果$f$要是最小值，那 $f_x=f_y=0$, 其中
$$
f_x=\frac{-0.24}{x^2}+10y+1.2-\frac{0.036}{x^2y}\&lt;br&gt;
f_y=\frac{-0.24}{y^2}+10x+1.2-\frac{0.036}{xy^2}
$$
但是x 和y 一定是正數，所以 x=y。接著，將x=y 帶入偏微分的式子，可以得到 $10x^4+ 1.2x^3 -0.24x -0.036=0$，能夠找出長方體容器的長寬高：
$$
x=寬=y=長\approx0.295\&lt;br&gt;
z=高\approx0.172\&lt;br&gt;
$$
總花費=TotalCost=$53.61473&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述所做的假設或省略會帶來怎麼樣的影響&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為容器的長寬高和容器壁的厚度大小差距約100倍，因此我將厚度忽略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我變成這個研究的顧問，我的結論會是？我會建議更換垃圾桶的設計嗎？如果會的話，能夠省下多少錢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原本垃圾桶的花費要 $53.92，比我們設計的容器還要貴，因此如果只從成本方面考量，我會建議更改垃圾桶的設計，可以省下至少$0.3。&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Clenshaw–Curtis quadrature</title>
      <link>https://teshenglin.github.io/post/2020_numerical_integration_4/</link>
      <pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_numerical_integration_4/</guid>
      <description>&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_numerical_integration&#34;&gt;數值積分初探&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_2&#34;&gt;以內插多項式來做數值積分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_3&#34;&gt;高斯積分&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我們想要利用 Chebyshev polynomial 來算積分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;goal-任意給定一可積分函數-fx-xin-1-1-我們想要算-int1_-1-fx-dx&#34;&gt;Goal: 任意給定一可積分函數 $f(x)$, $x\in[-1, 1]$, 我們想要算 $\int^1_{-1} f(x) dx$.&lt;/h4&gt;
&lt;hr&gt;
&lt;h4 id=&#34;idea&#34;&gt;Idea:&lt;/h4&gt;
&lt;p&gt;我們簡單做個變數變換 $x = \cos\theta$ 可以得到
$$
\int^1_{-1} f(x) dx = \int^{\pi}_0 f(\cos\theta)\sin\theta d\theta.
$$
所以如果我能將 $f(x)$ 這個函數以 first kind Chebyshev polynomial 來做展開, i.e.,
$$
f(x) = \sum^N_{k=0} a_k T_k(x) = \sum^N_{k=0} a_k \cos(k\cos^{-1}x).
$$
那代入後我們就有
$$
\int^1_{-1} f(x) dx = \int^{\pi}_0 \sum^N_{k=0} a_k \cos(k\theta)\sin\theta d\theta = \sum^{N/2}_{k=0}\frac{2 a_{2k}}{1-(2k)^2}.
$$&lt;/p&gt;
&lt;p&gt;因此, 若我們知道如何求一個函數的 Chebyshev coefficients, $a_k$, 那我們很容易就可以計算 $\int^1_{-1}f(x)dx$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;簡單的 Matlab 程式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% generate grid points
N = 25;
x = -sin((-N:2:N)&#39;*pi/(2*N));

% evaluate at grid points
f = cos(x).*exp(sin(x));

% extend the function and take scaled FFT
f_extend = [f; f(N: -1:2)];
f_hat = fft(f_extend)/(2*N);

% obtain the Chebyshev coefficients
a = zeros(N+1,1);
a(1) = real(f_hat(1));
a(2:N) = 2*real(f_hat(2:N));
a(N+1) = real(f_hat(N+1));

% Clenshaw–Curtis weights
w = zeros(1,N+1);
if(mod(N,2)==0)
    M = N/2;
else
    M = (N-1)/2;
end
w(1:2:end) = 2./(1-4*(0:M).^2);

% Clenshaw–Curtis quadrature
cc_quad = w*a;

% error
exact_quad = exp(sin(1)) - exp(sin(-1));
abs(cc_quad - exact_quad)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;以上做法是先將函數取值, 算其係數, 再求其積分.
不過實際上我們應該能將積分權重直接算出來, 如此一來我們就能直接由函數值求積分了.
也就是說我們希望能寫成以下這式子:
$$
\int^1_{-1} f(x)dx \approx \sum^N_{k=0} w_k f(x_k), \quad x_k = \cos\left(\frac{k\pi}{N}\right).
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;積分權重&#34;&gt;積分權重:&lt;/h4&gt;
&lt;p&gt;要求得積分權重我們首先回顧一下上面的作法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先將點做 even extension&lt;/li&gt;
&lt;li&gt;做 FFT&lt;/li&gt;
&lt;li&gt;由 Fourier coefficients 求得 Chebyshev coefficients&lt;/li&gt;
&lt;li&gt;再將係數乘上積分權重即得到積分值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步驟可以寫成矩陣形式:
$$
q = [\pmb{w}][\pmb{I}]^T[\pmb{F}][\pmb{I}][\pmb{f}]
$$
其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[\pmb{f}]$ 是函數值, 是個 $(N+1)\times 1$ 的矩陣&lt;/li&gt;
&lt;li&gt;$[\pmb{I}]$ 是 even extension 是個 $2N\times (N+1)$ 的矩陣&lt;/li&gt;
&lt;li&gt;$[\pmb{F}]$ 是 Fourier transform 是個 $2N\times 2N$ 的矩陣&lt;/li&gt;
&lt;li&gt;$[\pmb{w}]$ 是 Clenshaw–Curtis 對於係數的 weights 是個 $1\times (N+1)$ 的矩陣&lt;/li&gt;
&lt;li&gt;$q$ 是最後得到的數值積分值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以這樣看就很清楚, Clenshaw–Curtis 對於函數值的 weights 事實上就是 $[\pmb{w}][\pmb{I}]^T[\pmb{F}][\pmb{I}]$ 這串矩陣乘法.
也就是說如果我定義
$$
[CCW]=[\pmb{w}][\pmb{I}]^T[\pmb{F}][\pmb{I}],
$$
則我們有
$$
q = [CCW][\pmb{f}]
$$
而由於 $[\pmb{F}]$ 是對稱矩陣, 我們可以把這整個做矩陣轉置, 這樣就很清楚要怎樣求 weight 了
$$
[CCW]^T = [\pmb{I}]^T[\pmb{F}]^T[\pmb{I}][\pmb{w}]^T,
$$
其中 $[\pmb{F}]^T$ 這個矩陣乘法則是以 iFFT 來加速計算.&lt;/p&gt;
&lt;p&gt;簡單的 Matlab 程式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;N=25;

w = zeros(1,N+1);
if(mod(N,2)==0)
    M=N/2;
else
    M = (N-1)/2;
end
w(1:2:end) = 2./(1-4*(0:M).^2);

w2 = [w, w(N: -1:2)];
CCW = ifft(w2&#39;);
CCW = [CCW(1), 2*CCW(2:N)&#39;, CCW(N+1)];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了權重後即可由函數值直接求得積分值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% generate grid points
N = 25;
x = -sin((-N:2:N)&#39;*pi/(2*N));

% evaluate at grid points
f = cos(x).*exp(sin(x));

% Clenshaw–Curtis quadrature
cc_quad2 = CCW*f;

% error
exact_quad = exp(sin(1)) - exp(sin(-1));
abs(cc_quad2 - exact_quad)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;最後附上 &lt;code&gt;python&lt;/code&gt; 程式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import numpy as np
from numpy.fft import fft,ifft,fftshift

N = 25

# Clenshaw–Curtis weights 
if N % 2 ==0:
    M= int(N/2)
else:
    M = int((N-1)/2)

w = np.zeros(N+1)

w[0:N+1:2] = 2./(1-4*np.linspace(0,M,M+1)**2);
w2 = np.append(w, w[N-1:0:-1])
CCW2 = np.real(ifft(w2))

CCW = 2*CCW2[0:N+1]
CCW[0] = CCW2[0]
CCW[N] = CCW2[N]

# Chebyshev points of the second kind
x = -np.sin(np.arange(-N, N+1, 2)*np.pi/(2*N))

#f = np.exp(np.sin(x));
f = np.cos(x)*np.exp(np.sin(x))
cc_quad2 = np.inner(CCW, f)

# error
exact_quad = np.exp(np.sin(1)) - np.exp(np.sin(-1));
np.abs(cc_quad2 - exact_quad)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.5 - Families of Implicit Curves</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p5/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.5, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p5_ch&#34;&gt;隱式曲線集合&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this project you will explore the changing shapes of implicitly defined curves as you vary the constants in a family, and determine which features are common to all members of the family.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider the family of curves
$$
y^2-2x^2(x+8)=c[(y+1)^2(y+9)-x^2]
$$&lt;/p&gt;
&lt;p&gt;(a) By graphing the curves with $c=0$ and $c=2$ , determine how many points of intersection there are. (You might have to zoom in to find all of them.)&lt;/p&gt;
&lt;p&gt;(b) Now add the curves with $c=5$ and $c=10$ to your graphs in part (a) . What do you notice? What about other values of $c$?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; There appear to be nine points of intersection. The &amp;ldquo;inner four&amp;rdquo; near the origin are about $(\pm0.2, -0.9)$ and $(\pm0.3,-1.1)$. The &amp;ldquo;outer five&amp;rdquo; are about $(2.0,-8.9)$, $(-2.8,-8.8)$, $(-7.5,-7.7)$, $(-7.8,-4.7)$, and $(-8.0,1.5)$.
&lt;img src=&#34;https://i.imgur.com/DJwb3iP.png&#34; alt=&#34;1(a)&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt; We see from the graphs with $c=5$ and $c=10$, and for other values of $c$, that the curves change but the nine points of intersection are the same.
&lt;img src=&#34;https://i.imgur.com/gIuQrL8.png&#34; alt=&#34;1(b)&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a) Graph several members of the family of curves
$$
x^2+y^2+cx^2 y^2=1
$$
Describe how the graph changes as you change the value of $c$.&lt;/p&gt;
&lt;p&gt;(b) What happens to the curve when $c=-1$? Describe what appears on the screen. Can you prove it algebraically?&lt;/p&gt;
&lt;p&gt;(c) Find $y&#39;$ by implicit differentiation. For the case $c=-1$, is your expression for $y&#39;$ consistent with what you discovered in part (b)?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; If $c=0$, the graph is the unit circle. As $c$ increases, the graph looks more diamondlike and more crosslike (see the graph for $c\geq 0$)&lt;/p&gt;
&lt;p&gt;For $-1&amp;lt;c&amp;lt;0$(see the graph), there are four hyperboliclike branches as well as an ellipticlike curve bounded by $|x|\leq1$ and $|y|\leq1$ for values of $c$ close to $0$. As $c$ gets closer to $-1$, the branches and the curve become more rectangular, approaching the lines $|x|=1$ and $|y|=1$.&lt;/p&gt;
&lt;p&gt;For $c=-1$, we get the lines $x=\pm1$ and $y=\pm1$. As $c$ decreases, we get four test-tubelike curves (see the graph) that are bounded by $|x|=1$ and $|y|=1$, and get thinner as $|c|$ gets larger.
&lt;img src=&#34;https://i.imgur.com/8MuCqVK.png&#34; alt=&#34;2(a)&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.5 - 隱式曲線集合</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p5_ch/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p5_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.5, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p5&#34;&gt;Families of Implicit Curves&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這個專題中你將會發現，若你改變一個隱式曲線集合中的常數，它的形狀會如何改變，並決定集合中的成員會有哪些共同的特徵。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;問題-1&#34;&gt;問題 1.&lt;/h2&gt;
&lt;p&gt;考慮以下的曲線集合
$$
y^2-2x^2(x+8)=c[(y+1)^2(y+9)-x^2]
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; 藉由畫出$c=0$ 和 $c=2$ 的圖形，找出共有幾個交點。 (你可能需要放大來找出全部的交點。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt; 將$c=5$ 和 $c=10$ 加到 &lt;strong&gt;(a)&lt;/strong&gt; 的圖形。你注意到了什麼?  $c$ 帶入其他數值結果又會如何?&lt;/p&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; 共有九個交點。「內部」的四個交點大概位於 $(\pm0.2, -0.9)$ 和 $(\pm0.3,-1.1)$. 「外部」的五個交點大概位於 $(2.0,-8.9)$, $(-2.8,-8.8)$, $(-7.5,-7.7)$, $(-7.8,-4.7)$, 和 $(-8.0,1.5)$。
&lt;img src=&#34;https://i.imgur.com/DJwb3iP.png&#34; alt=&#34;1(a)&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt; 觀察$c=5$ 及 $c=10$的圖形，以及對其他的 $c$ 而言，曲線的圖形會改變但交點的位置不變。
&lt;img src=&#34;https://i.imgur.com/gIuQrL8.png&#34; alt=&#34;1(b)&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;問題-2&#34;&gt;問題 2.&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; 畫出
$$
x^2+y^2+cx^2 y^2=1
$$
曲線集合中的數個成員，並描述當你改變$c$的值，曲線的圖形出現了什麼改變？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt; 當$c=-1$會發生什麼事?描述螢幕上發生了什麼事？你能夠代數性的證明它嗎？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(c)&lt;/strong&gt; 使用隱微分找到 $y&#39;$ 。當$c=-1$,你寫的 $y&#39;$ 與你在 &lt;strong&gt;(b)&lt;/strong&gt; 發現的相符嗎?&lt;/p&gt;
&lt;h2 id=&#34;解答-1&#34;&gt;解答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(a)&lt;/strong&gt; 當 $c=0$圖形為單位圓。當 $c$ 增加，圖形看起來越來越像寶石和十字架 (看 $c\geq0$的圖)&lt;/p&gt;
&lt;p&gt;當 $-1&amp;lt;c&amp;lt;0$(看圖), $c$ 靠近 $0$ 時有四個部分的雙曲線和一個由 $|x|\leq1$ 和 $|y|\leq1$ 圍出的橢圓。$c$ 越靠近 $-1$, 橢圓和曲線就變得越方正, 靠近 $|x|=1$和$|y|=1$。&lt;/p&gt;
&lt;p&gt;當$c=-1$, 我們得到直線 $x=\pm1$ 和 $y=\pm1$。當 $c$ 減少,我們得到四個試管形狀的曲線(看圖) 由 $|x|=1$ 和 $|y|=1$ 圍出，當$|c|$越大，圖形就變得越小。
&lt;img src=&#34;https://i.imgur.com/8MuCqVK.png&#34; alt=&#34;2(a)&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>擲硬幣問題</title>
      <link>https://teshenglin.github.io/post/2020_coin_problem/</link>
      <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_coin_problem/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;重複擲一枚硬幣, 當出現連續兩次為正時停止, 平均要扔幾次?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第一種做法-窮舉法&#34;&gt;第一種做法: 窮舉法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我們以正負號 (+ -) 代表正面反面.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;觀察&#34;&gt;觀察&lt;/h3&gt;
&lt;p&gt;假設花 $n$ 次才擲到連續兩次為正, $n \geq 2$.&lt;/p&gt;
&lt;p&gt;我們發現, 可以從第 $n-1$ 次的結果進行窮舉法得到第 $n$ 次的結果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當 $n = 2$, 只會有 1 種情況 : &lt;code&gt;++&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要窮舉 $n = 3$, 要知道三次中的尾巴兩次必須是 $n=2$ 的所有情況. 由於 $n=2$ 的第一個為正, 因此要在前加一項只能為負, 因此 $n=3$ 只有 &lt;code&gt;-++&lt;/code&gt; 這情況&lt;/li&gt;
&lt;li&gt;對 $n=4$, 尾巴三次必須是 $n=3$ 的所有情況. 由於 $n=3$ 的第一個為負, 因此要在前加正或負皆可, 因此 $n=4$ 有兩種情況: &lt;code&gt;+-++&lt;/code&gt;,  &lt;code&gt;--++&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小結論&#34;&gt;小結論&lt;/h4&gt;
&lt;p&gt;對 $n=k+1$ 而言, 我們只需要考慮 $n=k$ 所有情況的第一個是正或負即可. 若為正則只能在前面再加個負, 若為負則可以在前面加正或負.&lt;/p&gt;
&lt;p&gt;也就是說, 假設 $n=k$ 中有 $x_k$ 個情況第一個為正, 有 $y_k$ 個情況第一個為負, 那 $n=k+1$ 的所有情況中必有 $y_k$ 個情況第一個為正, $x_k+y_k$ 個情況第一個為負.
寫成矩陣型式就是
$$
\begin{bmatrix} x_{k+1} \\ y_{k+1}\end{bmatrix}
= A
\begin{bmatrix} x_{k} \\ y_{k}\end{bmatrix}, \quad
A =
\begin{bmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 1 \end{bmatrix}
$$
則我們有
$$
\begin{bmatrix} x_{k} \\ y_{k}\end{bmatrix}
= A^{k-2}
\begin{bmatrix} 1 \\ 0\end{bmatrix}, \quad k\ge 2.
$$
並且我們知道花 $k$ 次才達到連續兩次為正共會有 $x_k+y_k$ 種情況, 意即
$$
\begin{bmatrix} 1 &amp;amp; 1\end{bmatrix}
A^{k-2}
\begin{bmatrix} 1 \\ 0\end{bmatrix}.
$$
另外我們還知道丟硬幣 $k$ 次之任一情況的機率為 $\frac{1}{2^k}$.&lt;/p&gt;
&lt;h3 id=&#34;計算期望值&#34;&gt;計算期望值&lt;/h3&gt;
&lt;p&gt;利用以上結果我們可以知道期望值為
$$
E = \sum_{k=2}^\infty
\left(
\begin{bmatrix} 1 &amp;amp; 1\end{bmatrix}
A^{k-2}
\begin{bmatrix} 1 \\ 0\end{bmatrix}
\right)
\cdot \frac{k}{2^{k}}
=\sum_{k=0}^\infty
\left(
\begin{bmatrix} 1 &amp;amp; 1\end{bmatrix}
A^{k}
\begin{bmatrix} 1 \\ 0\end{bmatrix}
\right)
\cdot \frac{k+2}{2^{k+2}}.
$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;對角化
$$
A = \begin{bmatrix}0 &amp;amp; 1 \\ 1 &amp;amp; 1\end{bmatrix}
= \frac{1}{\sqrt{5}}
\begin{bmatrix}1 &amp;amp; 1 \\ \frac{1+\sqrt{5}}{2} &amp;amp; \frac{1-\sqrt{5}}{2}\end{bmatrix}
\begin{bmatrix}\frac{1+\sqrt{5}}{2} &amp;amp; 0 \\ 0 &amp;amp; \frac{1-\sqrt{5}}{2}\end{bmatrix}
\begin{bmatrix}\frac{\sqrt{5}-1}{2} &amp;amp; 1 \\ \frac{1+\sqrt{5}}{2} &amp;amp; -1\end{bmatrix}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可得
$$
A^k
= \frac{1}{\sqrt{5}}
\begin{bmatrix}1 &amp;amp; 1 \\ \frac{1+\sqrt{5}}{2} &amp;amp; \frac{1-\sqrt{5}}{2}\end{bmatrix}
\begin{bmatrix}\left(\frac{1+\sqrt{5}}{2}\right)^k &amp;amp; 0 \\ 0 &amp;amp; \left(\frac{1-\sqrt{5}}{2}\right)^k\end{bmatrix}
\begin{bmatrix}\frac{\sqrt{5}-1}{2} &amp;amp; 1 \\ \frac{1+\sqrt{5}}{2} &amp;amp; -1\end{bmatrix}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接著我們有
$$
\begin{bmatrix} 1 &amp;amp; 1\end{bmatrix}
A^{k}
\begin{bmatrix} 1 \\ 0\end{bmatrix}
=\frac{1}{\sqrt{5}}\left[(\frac{1+\sqrt{5}}{2})^{k-1}\cdot\frac{3+\sqrt{5}}{2} - (\frac{1-\sqrt{5}}{2})^{k-1}\cdot\frac{3-\sqrt{5}}{2}\right]
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此
$$
E = \frac{3+\sqrt{5}}{16\sqrt{5}} \underbrace{\sum_{k=0}^{\infty}(k+2)\cdot(\frac{1+\sqrt{5}}{4})^{k-1}}_{(a)} - \frac{3-\sqrt{5}}{16\sqrt{5}} \underbrace{\sum_{k=0}^{\infty}(k+2)\cdot(\frac{1-\sqrt{5}}{4})^{k-1}}_{(b)}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;recall-calculus&#34;&gt;Recall Calculus&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;要算 (a) 與 (b) 我們先 recall 微積分裡的一個結果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$
\sum_{n=0}^{\infty} x^n = \frac{1}{1-x}, \quad |x| &amp;lt; 1.
$$
兩邊微分得到
$$
\sum_{n=0}^{\infty} n x^{n-1} = \frac{1}{(1-x)^2}, \quad |x| &amp;lt; 1.
$$&lt;/p&gt;
&lt;p&gt;利用這個我們可以算 (a)
$$
\sum_{k=0}^{\infty}(k+2)\cdot(\frac{1+\sqrt{5}}{4})^{k-1} = 18 + 10\sqrt{5}
$$
也可以算 (b)
$$
\sum_{k=0}^{\infty}(k+2)\cdot(\frac{1-\sqrt{5}}{4})^{k-1} = 18 - 10\sqrt{5}
$$&lt;/p&gt;
&lt;p&gt;最後,
$$
E = \frac{3+\sqrt{5}}{16\sqrt{5}}\cdot (18+10\sqrt{5}) - \frac{3-\sqrt{5}}{16\sqrt{5}}\cdot (18-10\sqrt{5}) = 6
$$&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論&lt;/h3&gt;
&lt;p&gt;重複擲一枚硬幣, 當出現連續兩次為正時停止, 平均要扔&lt;strong&gt;六&lt;/strong&gt;次.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第二種做法&#34;&gt;第二種做法:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我們可以用 Markov chain 來想這問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;觀察-1&#34;&gt;觀察&lt;/h3&gt;
&lt;p&gt;假設目前連續投擲出 0 個正, 那下一投有 $0.5$ 機率是正以及 $0.5$ 機率是負.
也就是 $0.5$ 機率會是到 &lt;code&gt;1正&lt;/code&gt; 這狀態以及 $0.5$ 機率回到 &lt;code&gt;0正&lt;/code&gt; 這狀態.&lt;/p&gt;
&lt;p&gt;假設目前連續投擲出 1 個正, 那下一投則 $0.5$ 機率會是到 &lt;code&gt;2正&lt;/code&gt; 這狀態以及 $0.5$ 機率回到 &lt;code&gt;0正&lt;/code&gt; 這狀態.&lt;/p&gt;
&lt;p&gt;根據這些觀察我們可以做出以下的 diagram:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph LR;
A[0 正] -- 0.5 --&amp;gt;B(1 正)
  B -- 0.5 --&amp;gt; C(2 正)
  A -- 0.5 --&amp;gt; A
  B -- 0.5 --&amp;gt; A
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著我們假設從 &lt;code&gt;0正&lt;/code&gt; 這狀態需要投 $k_0$ 次才會到 &lt;code&gt;2正&lt;/code&gt;, 而從 &lt;code&gt;1正&lt;/code&gt; 這狀態需要投 $k_1$ 次才會到 &lt;code&gt;2正&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;對 &lt;code&gt;0正&lt;/code&gt; 狀態而言, 投一次有 $0.5$ 機會到&lt;code&gt;1正&lt;/code&gt;狀態, 然後再需要 $k_1$ 次到&lt;code&gt;2正&lt;/code&gt;, 所以這樣總共投 $1+k_1$ 次.
而 &lt;code&gt;0正&lt;/code&gt; 投一次也有 $0.5$ 機會會回到自己原始 &lt;code&gt;0正&lt;/code&gt; 狀態, 然後再需要 $k_0$ 次到&lt;code&gt;2正&lt;/code&gt;, 所以這樣總共投 $1+k_0$ 次.
如此可以列式:
$$
k_0 = 0.5(1+k_1) + 0.5(1+k_0)
$$&lt;/p&gt;
&lt;p&gt;同理, 對 &lt;code&gt;1正&lt;/code&gt; 狀態而言我們有以下式子
$$
k_1 = 0.5(1) + 0.5(1+k_0)
$$&lt;/p&gt;
&lt;p&gt;這樣我們有兩個未知數兩個方程式, 解出來得到
$$
k_0=6, \quad k_1=4.
$$&lt;/p&gt;
&lt;p&gt;所以, 從 &lt;code&gt;0正&lt;/code&gt; 狀態到出現連續兩次為正平均要投 $6$ 次.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Lagrange Multiplier - 01</title>
      <link>https://teshenglin.github.io/post/2020_lagrange_multiplier/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_lagrange_multiplier/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在微積分課程裡我們有學到如何利用 Lagrange multiplier 來解 constraint optimization 問題. 這邊要介紹課本裡沒教的 Lagrangian function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;goal-我們想要解以下這個問題&#34;&gt;Goal: 我們想要解以下這個問題&lt;/h4&gt;
&lt;p&gt;$$
\min_{x} f(x), \quad \text{subject to } \quad  g(x)=0.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Observation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微積分課本告訴我們一個相對好懂的直觀, 就是這個解會發生在兩個等高線相切的地方, 因此在這個問題的解那個點的位置, 兩個函數 $f$ 與 $g$ 等高線的法向量會平行, 因此可以列出以下兩個式子
$$
\partial_x f + \lambda \partial_x g = 0, \quad  g(x)=0.
$$
這裡我們引進一個新的未知數 $\lambda$, 即稱為 Lagrange multiplier.
因為有兩個方程式, 因此我們可以解出兩個未知數 $x$ 以及 $\lambda$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上列的這個方程組有另一種相對好記的方式, 就是引進所謂的 Lagrangian function
$$
L(x, \lambda) = f(x) + \lambda g(x)
$$
這是一個雙變數方程式, 而原本問題的解會發生在這個方程的 critical point, 也就是會滿足 $\nabla L=0$.&lt;/p&gt;
&lt;p&gt;要注意的是由於 $L$ 是個雙變數函數, 所以 $\nabla = (\partial_x, \partial_{\lambda})$. 根據這樣的定義我們將 $\nabla L=0$ 方程式列出來會得到跟上面一模一樣的兩個方程組.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark 1:&lt;/strong&gt;  $\partial_{x} L = \partial_x f + \lambda \partial_x g$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark 2:&lt;/strong&gt;  $\partial_{\lambda} L = g(x)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;引進 Lagrangian function 比較好記是因為假設我有更多的 constraints, 例如我想解以下這個問題:
$$
\min_{x} f(x), \quad \text{subject to } \quad  g_1(x)=0, \quad g_2(x)=0.
$$
要找一個函數最小值不過有兩個限制條件.&lt;/p&gt;
&lt;p&gt;這樣的話我們照之前的步驟, 先引進 Lagrangian function
$$
L(x, \lambda_1, \lambda_2) = f(x) + \lambda_1 g_1(x) + \lambda_2 g_2(x)
$$
然後原問題的最佳解會發生在 $\nabla L=0$.&lt;/p&gt;
&lt;p&gt;要注意的是這次的 $L$ 是個三變數函數, 所以 $\nabla L = (\partial_x, \partial_{\lambda_1}, \partial_{\lambda_2})$. 然後將 $\nabla L=0$ 寫下來就是
$$
\partial_x f + \lambda_1 \partial_x g_1 + \lambda_2 \partial_x g_2 = 0, \quad  g_1(x)=0, \quad g_2(x)=0.
$$
就得到我們需要解的方程組了!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接著我們試著將以上寫的更廣義一點, 考慮一個 $n$ 維度的最佳化問題有 $m$ 個限制式, 我們引進一些符號: $\pmb{x}\in \mathbb{R}^n$,  $\pmb{g}(\pmb{x}):\mathbb{R}^n\to\mathbb{R}^m$, 這個有限制的最佳化問題即可寫成
$$
\min_{\pmb{x}\in\mathbb{R}^n}f(\pmb{x}), \quad \text{subject to } \quad  \pmb{g}(\pmb{x})=\pmb{0}.
$$&lt;/p&gt;
&lt;p&gt;我們接著引進 Lagrangian function
$$
L(\pmb{x}, \pmb{\lambda}) = f(\pmb{x}) + \pmb{\lambda}^T \pmb{g}(\pmb{x}), \quad \pmb{\lambda}\in\mathbb{R}^m
$$&lt;/p&gt;
&lt;p&gt;原問題的最佳解會發生在 $\nabla L=0$, 也就是 $(\nabla_{\pmb{x}} L, \nabla_{\pmb{\lambda}} L) = (0, 0)$, 也就是
$$
\nabla_{\pmb{x}} f(\pmb{x}) + \pmb{\lambda}^T \nabla_{\pmb{x}}\pmb{g}(\pmb{x}) = 0, \quad \pmb{g}(\pmb{x})=\pmb{0}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;所以為什麼要引進 Lagrange multiplier 或是 Lagrangian function?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引進 Lagrange multiplier 的好處是我們將一個&lt;strong&gt;最佳化問題&lt;/strong&gt;改寫成一個&lt;strong&gt;求根問題&lt;/strong&gt;. 理論上 $F(x)=0$ 這種問題不管線性或非線性我們都比較會解. 而最佳化問題就相對比較無從下手.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BUT&lt;/strong&gt;, 付出的代價是我們增加了維度! 原本 $n$ 維最小值問題變成 $n+m$ 維求根問題.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引進 Lagrangian function 最明顯的好處是&lt;strong&gt;比較好記&lt;/strong&gt;, 不管是&lt;code&gt;記&lt;/code&gt;在頭腦裡或是做筆&lt;code&gt;記&lt;/code&gt;寫下來. 整個問題很輕易的就記成 $\nabla L=0$.&lt;/p&gt;
&lt;p&gt;當然還有其他更重要的好處, 就是可以推導出所謂的 dual optimization problem: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_lagrange_multiplier_2&#34;&gt;Lagrange Multiplier - 02&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lagrange multiplier $\lambda$ 感覺起來很像一點用都沒有, 就是為了解出問題過程所引進的虛擬變數. 其實它還是有一點意義的, 可見: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_lagrange_multiplier_3&#34;&gt;Lagrange Multiplier - 03&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Lagrange Multiplier - 02</title>
      <link>https://teshenglin.github.io/post/2020_lagrange_multiplier_2/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_lagrange_multiplier_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們再多討論一點 Lagrangian function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們先看最簡單的一維問題, 求一個有限制式的函數最小值問題:
$$
\min_{x} f(x), \quad \text{subject to } \quad  g(x)=0.
$$&lt;/p&gt;
&lt;p&gt;我們引進 Lagrangian function
$$
L(x, \lambda) = f(x) + \lambda g(x)
$$
並且知道原問題的解發生在 $\nabla L=0$ 的地方.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 從微積分我們知道 $\nabla L=0$ 是 $L(x, \lambda)$ 這個函數 critical point發生的地方, 那這個 critical point 究竟是 local max/min 還是 saddle 呢?&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要回答這問題其實很簡單, 我們看這個二維函數的判別式就知道. 這函數的變數有兩個分別是 $x$ 以及 $\lambda$, 所以判別式是
$$
L_{xx}L_{\lambda\lambda} - L_{x\lambda}^2 = -(g_x)^2 \le 0
$$
所以我們知道原最佳化問題的解其實是這個 Lagragian function 的 saddle point (至少不是 local max/min)!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Constraint optimization problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我們事實上可以考慮更一般的問題
$$
\min_{x} f(x), \quad \text{subject to } \quad  g(x) \le 0.
$$
這樣的問題我們可以定義一樣的 Lagrangian function
$$
L(x, \lambda) = f(x) + \lambda g(x).
$$&lt;/p&gt;
&lt;p&gt;我們有以下這個定理:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem---saddle-point-sufficient-condition&#34;&gt;Theorem - Saddle point (Sufficient condition)&lt;/h2&gt;
&lt;p&gt;Let $P$ be a constraint optimization problem.
If $(x^+, \lambda^+)$ is a saddle point, that is,
$$\forall x\in\mathbb{R}, \forall\lambda\ge 0, \quad L(x^+, \lambda)\le L(x^+, \lambda^+)\le L(x, \lambda^+),$$
then it is a solution of $P$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個證明很簡單.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根據不等式第一個部分
$$\forall\lambda\ge 0, \quad L(x^+, \lambda)\le L(x^+, \lambda^+)$$
帶入 $L$ 我們得到 $\lambda g(x^+) \le \lambda^+ g(x^+)$.&lt;/p&gt;
&lt;p&gt;由於對所有 $\lambda\ge 0$ 都對, 我們讓 $\lambda\to\infty$ 得到 $g(x^+)\le 0$.
接著讓 $\lambda\to 0$ 我們得到 $0\le \lambda^+ g(x^+)\le 0$, 因此 $\lambda^+ g(x^+)=0$.&lt;/p&gt;
&lt;p&gt;有這件事後我們再看不等式第二部分, $L(x^+, \lambda^+)\le L(x, \lambda^+)$.
代入 $L$ 以及以上結果我們有 $f(x^+)\le f(x) + \lambda^+ g(x)$.&lt;/p&gt;
&lt;p&gt;因此, 若 $g(x)\le 0$, 我們必定有 $f(x^+)\le f(x)$.&lt;/p&gt;
&lt;p&gt;QED.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&#34;可以看到在上面有個隱藏的假設是-lambdage-0-可以被很輕易地看出來所以這裡就不記下了&#34;&gt;可以看到在上面有個隱藏的假設是 $\lambda\ge 0$. 可以被很輕易地看出來所以這裡就不記下了.&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;更進一步, 我們可以引進這個 Lagrange dual function:
$$
F(\lambda) = \inf_{x} L(x, \lambda)
$$
也就是固定一個 $\lambda$ 我去找 $L$ 這函數的最大下界(有點像最小值不過不一定要碰到). 據此我們可以引進以下的 dual problem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dual optimization problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
\max_{\lambda} F(\lambda), \quad \lambda \ge 0.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;舉個例子&#34;&gt;舉個例子&lt;/h4&gt;
&lt;p&gt;我們考慮這個特別的 constraint optimization 問題
$$
\min_{\pmb{x}\in\mathbb{R}^n}f(\pmb{x}), \quad \text{subject to } \quad  A\pmb{x}-\pmb{b}=\pmb{0},
$$
其中 $A$ 是個矩陣而 $\pmb{b}$ 是個向量. 也就是說限制式為 $g(\pmb{x}) = A\pmb{x}-\pmb{b}$.&lt;/p&gt;
&lt;p&gt;把 Lagrangian function 寫下來就是
$$
L(\pmb{x}, \pmb{\lambda}) = f(\pmb{x}) + \pmb{\lambda}^T(A\pmb{x}-\pmb{b}).
$$
對於 dual problem 我們可以構造一個迭代法來解這問題.&lt;/p&gt;
&lt;p&gt;由 Dual optimization problem 我們知道對於 $F$ 這個函數我們要求其最大值. 所以我們試著朝 gradient 方向走來往上走, 意即
$$
\lambda^{k+1} = \lambda_k + \alpha^k\nabla_{\lambda} F(\lambda^k),
$$
其中 $\alpha^k$ 是步長. 而且我們知道 $\nabla_{\lambda} F(\lambda^k) = A\pmb{\tilde{x}}-\pmb{b},$ 其中 $\pmb{\tilde{x}} = argmin \ L(\pmb{x}, \pmb{\lambda}^k)$. 因此我們有以下這方法:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dual ascent iteration method:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一步: 固定一個 $\pmb{\lambda}$ 我們解一個 optimization 問題
$$
\pmb{x}^{k+1} = argmin \ L(\pmb{x}, \pmb{\lambda}^k)
$$
&lt;strong&gt;Remark:&lt;/strong&gt; 這是一個沒有 constraint 的最小值問題, 可以用 gradient descent 或各式方法來解.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步: 接著我們用 gradient ascent 來更新 $\pmb{\lambda}$
$$
\lambda^{k+1} = \lambda^k + \alpha^k(A\pmb{x}^{k+1}-\pmb{b})
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;迭代下去我們可以得到原問題的解!&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;augmented-lagrangian&#34;&gt;Augmented Lagrangian&lt;/h2&gt;
&lt;p&gt;一個很有趣的更進一步推廣是將 Lagrangian 引入一個新的 penalty term:
$$
L_{\rho}(\pmb{x}, \pmb{\lambda}) = f(\pmb{x}) + \pmb{\lambda}^T(A\pmb{x}-\pmb{b}) + \frac{\rho}{2}\|A\pmb{x}-\pmb{b}\|^2_2,
$$
其中 $\rho$ 是個常數.&lt;/p&gt;
&lt;p&gt;我們可以反過來將這個 Lagrangian 所對應的限制最佳化問題寫下來:
$$
\min_{\pmb{x}\in\mathbb{R}^n}f(\pmb{x})+\frac{\rho}{2}\|A\pmb{x}-\pmb{b}\|^2_2, \quad \text{subject to } \quad  A\pmb{x}-\pmb{b}=\pmb{0}.
$$
我們可以輕易發現, 加了這新的一項對於這整個問題的最佳解完全沒有影響! 也就是說 $L_{\rho}$ 所得到的解就是原本 $L$ 的解.&lt;/p&gt;
&lt;p&gt;接著我們一樣用 dual ascent iteration method 來解這問題（給定 $\pmb{x}^{k}$ 以及 $\pmb{\lambda}^{k}$).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Method of multiplier:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一步: 我們解一個 optimization 問題
$$
\pmb{x}^{k+1} = argmin \ L_{\rho}(\pmb{x}, \pmb{\lambda}^k)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步: 接著我們用 gradient ascent 來更新 $\pmb{\lambda}$
$$
\pmb{\lambda}^{k+1} = \pmb{\lambda}^k + \rho(A\pmb{x}^{k+1}-\pmb{b})
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 這裡有個有趣的事, 原本的方法中步長是不知道的需要自己決定, 不過在這裡我們卻直接設定步常為 $\rho$. 接下來我們就是要解釋這部分.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一步中, 如果 $\pmb{x}^{k+1}$ 是個解那它要滿足 $\nabla_{\pmb{x}} L_{\rho}=0$, 其中整理一下發現
$$
\nabla_{\pmb{x}} L_{\rho}=\nabla_{\pmb{x}} f(\pmb{x}^{k+1}) + A^T\left(\pmb{\lambda}^k + \rho (A\pmb{x}^{k+1}-\pmb{b})\right)=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以, 如果第二步中的步長我們設定為 $\rho$, 那上式就可以改寫為
$$
\nabla_{\pmb{x}} f(\pmb{x}^{k+1}) + A^T\pmb{\lambda}^{k+1}=0.
$$
有趣的是, 對原本的 Lagrangian 而言我們有
$$
\nabla_{\pmb{x}} L=\nabla_{\pmb{x}} f(\pmb{x}) + A^T\pmb{\lambda},
$$
所以我們這樣設定步長, 剛好使得我們每次算出的 $\pmb{x}^{k+1}$ 以及 $\pmb{\lambda}^{k+1}$ 滿足
$$
\nabla_{\pmb{x}} L(\pmb{x}^{k+1}, \pmb{\lambda}^{k+1})=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;再把以上兩個方法 summarize 一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原本問題是
$$
\min_{\pmb{x}} f(\pmb{x}), \quad \text{subject to } \quad  A\pmb{x}-\pmb{b}=\pmb{0}.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引進 Lagrangian 後變成我們要解以下方程
$$
\nabla_{\pmb{x}} L =\nabla_{\pmb{x}} f(\pmb{x}) + A^T\pmb{\lambda}=0, \quad \nabla_{\pmb{\lambda}} L=A\pmb{x}-\pmb{b}=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我們使用迭代法來解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若用 &lt;strong&gt;dual ascent iteration method&lt;/strong&gt;, 則有
$$
\nabla_{\pmb{x}} L(\pmb{x}^{k+1}, \pmb{\lambda}^k)=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若用 &lt;strong&gt;method of multiplier&lt;/strong&gt;, 則有
$$
\nabla_{\pmb{x}} L(\pmb{x}^{k+1}, \pmb{\lambda}^{k+1})=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;對於兩種方法, 原問題的 Constraint 都在 $k\to\infty$ 滿足
$$
\lim_{k\to\infty} A\pmb{x}^k-\pmb{b}=0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Lagrange Multiplier - 03</title>
      <link>https://teshenglin.github.io/post/2020_lagrange_multiplier_3/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_lagrange_multiplier_3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們討論一下 Lagrange multiplier.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們知道, 如果想要解以下這個有限制式的最佳化問題
$$
\min_{x} f(x), \quad \text{subject to } \quad  g(x)=k,
$$
一個方式是引進 Lagrange multiplier, $\lambda$, 然後可以列出以下兩個式子
$$
\partial_x f + \lambda \partial_x g = 0, \quad  g(x)=k.
$$&lt;/p&gt;
&lt;h4 id=&#34;question&#34;&gt;Question:&lt;/h4&gt;
&lt;p&gt;解出聯立方程後我們得到 $x^+$, $\lambda^+$, 帶入原函數得到 $f^+=f(x^+)$.
我們知道 $f^+$ 是最佳值, 而 $x^+$ 是最佳解. 那 $\lambda^+$ 是做什麼用的?
看起來只是為了解出原問題所引進的虛擬變數. 它有什麼作用嗎?&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;先說結論, $\lambda^+ = -\frac{df^+}{dk}$. 也就是告訴我們如果稍微改變限制式中的 $k$ 值, 那原題的最佳值會有怎樣的變化.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;我們先引進 Lagrangian function
$$
L(x, \lambda) = f(x) + \lambda (g(x) - k)
$$
並且知道原問題的解發生在 $\nabla L=0$ 的地方, 意即, $\nabla L(x^+, \lambda^+)=0$.
然後我們有
$$
L^+ = L(x^+, \lambda^+) = f(x^+) + \lambda^+(g(x^+)-k) = f^+.
$$&lt;/p&gt;
&lt;p&gt;在這裡我們要稍微小心一點. 固定一個 $k$ 值, 我們就有一個最佳化問題, 然後就可以解出 $x^+$ 跟 $\lambda^+$.
而當 $k$ 值改變時, $x^+$, $\lambda^+$, 甚至 $f^+$ 以及 $L^+$ 也都會跟著改變, 所以我們想像這四個值都是 $k$ 的函數:
$$
x^+ = x^+(k), \ \lambda^+ = \lambda^+(k), \ f^+ = f^+(k), \ L^+ = L^+(k).
$$
再寫清楚一點就是
$$
L^+(k) = \left.L(x, \lambda,k)\right|_{x=x^+(k), \lambda=\lambda^+(k),k=k}
$$&lt;/p&gt;
&lt;p&gt;其中
$$
L(x, \lambda,k) = f(x) + \lambda (g(x) - k).
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 讀到這邊也許會覺得有個奇怪的地方, 就是為什麼要把 $L$ 從雙變數變成三變數函數.
原因是當寫成 $L(x, \lambda)$ 時 $k$ 是個常數, 是不能變的. 想要改變 $k$ 值需要把它也當成一個變數比較合理.&lt;/p&gt;
&lt;p&gt;接著我們就可以微分
$$
\frac{d L^+}{dk} = \left.\frac{\partial L}{\partial x}\frac{d x}{dk} + \frac{\partial L}{\partial \lambda}\frac{d \lambda}{dk} + \frac{\partial L}{\partial k}\right|_{x=x^+(k), \lambda=\lambda^+(k),k=k} = -\lambda^+.
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;
$$
\left.\frac{\partial L}{\partial x}\right|_{x=x^+(k), \lambda=\lambda^+(k),k=k}=
\left.\frac{\partial L}{\partial \lambda}\right|_{x=x^+(k), \lambda=\lambda^+(k),k=k}=0.
$$&lt;/p&gt;
&lt;p&gt;由於 $f^+ =L^+$, 所以我們也可以得到 $\frac{d f^+}{dk} = -\lambda^+$.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;舉個例子&#34;&gt;舉個例子&lt;/h4&gt;
&lt;p&gt;以下單位皆為&lt;code&gt;元&lt;/code&gt; or &lt;code&gt;萬元&lt;/code&gt; or &lt;code&gt;千萬元&lt;/code&gt;, 請自行依喜好帶入!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假設我如果花費 $x$ 買進某一股票在一定時間後賣出可獲得 $2x$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假設我如果花費 $y$ 買進某一貴金屬在一定時間後賣出可獲得 $10y-y^2$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假設我總共可運用的財產只有 $10$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;那我應該花多少錢買股票花多少錢買貴金屬, 才能有最佳獲利呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們可以列出以下限制最佳化問題&lt;/p&gt;
&lt;p&gt;$$
\max_{x,y} f(x,y)=2x+(10y-y^2), \quad \text{subject to } \quad  x+y=10,
$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先引進 Lagrangian funtion
$$
L(x,y,\lambda) = 2x+(10y-y^2)+\lambda(x+y-10)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出方程式 $\nabla L=0$:
$$
\frac{\partial L}{\partial x} = 2 + \lambda =0, \quad
\frac{\partial L}{\partial y} = 10-2y + \lambda =0, \quad
\frac{\partial L}{\partial \lambda} = x+y-10 =0.
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解出得到
$$
x^+ = 6, \quad y^+=4, \quad \lambda^+=-2.
$$
也就是我們若以 $6$ 單位買進股票, $4$ 單位買進貴金屬, 一定時間賣出後可獲利 $f^+ = 36$ 單位.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以 $\lambda^+=-2$ 告訴我們 $\frac{d f^+}{dk}=-\lambda^+=2$, 意思就是如果我們增加一點 $k$ 值, 那獲利會是所增加數目的&lt;strong&gt;兩倍&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將原題改成我目前可運用的財產有 $11$ (也就是多增加了 $1$), 那會發現最佳解是 $x^+=7$, $y^+=4$, $f^+=38$, 獲利真的增加 $2$ 單位了!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果這是真實情形, 那就告訴我們說如果去借 $1$ 單位的錢, 可以賺到 $2$ 單位. 如果借的錢加上利息會小於 $2$ 單位, 那就是個很好的投資, 應該去借.&lt;/li&gt;
&lt;li&gt;這例子比較特殊 $\lambda^+$ 恆等於 $2$, 所以才會那麼巧資金增加一單位獲利就增加兩單位. 一般而言這應該只是 linear appxoimation, 只有 $k$ 增加一點點時才會大約兩倍. 增加太多就不知道了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;references&#34;&gt;References:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/m-G3K2GPmEQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Youtube: Meaning of the Lagrange multiplier&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/b9B2FZ5cqbM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Youtube: Proof for the meaning of Lagrange multipliers&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.15.8 - Roller Derby</title>
      <link>https://teshenglin.github.io/post/2020_cal_s15p8/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s15p8/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.15.8, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s15p8_ch&#34;&gt;滾動競賽&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Suppose that a solid ball(a marble), a hollow ball (a squash ball), a solid cylinder (a steel bar), and a hollow cylinder (a lead pipe) roll down a slope. Which of these objects reaches the bottom first?&lt;/p&gt;
&lt;p&gt;To answer this question, we consider a ball or cylinder with mass $m$, radius $r$, and moment of inertia $I$ (about the axis of rotation). If the vertical drop is $h$, then the potential energy at the top is $mgh$. Suppose the object reaches the bottom with velocity $v$ and angular velocity $\omega$, so $v=\omega r$. The kinetic energy at the bottom consists of two parts: $\frac{1}{2}mv^2$ from translation (moving down the slope) and $\frac{1}{2}I\omega ^2$ from rotation. If we assume that energy loss from rolling friction is negligible, the conservation of energy gives
$$
mgh=\frac{1}{2}mv^2+\frac{1}{2}I\omega ^2
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that
$$
v^2=\frac{2gh}{1+I^&lt;em&gt;},\quad \text{where  } I^&lt;/em&gt;=\frac{I}{mr^2}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If $y(t)$ is the vertical distance traveled at time $t$, then the same reasoning as used in Problem 1 shows that $v^2=2gy/(1+I^&lt;em&gt;)$ at any time t. Use this result to show that $y$ satisfies the differential equation
$$
\frac{dy}{dt}= \sqrt{\frac{2g}{1+I^&lt;/em&gt;}}(\sin{\alpha})\sqrt{y}
$$
where $\alpha$ is the angle of inclination of the plane.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;By solving the equation in Problem 2, show that the total travel time is
$$
T=\sqrt{\frac{2h(1+I^&lt;em&gt;)}{g\sin^2\alpha}}
$$
This shows that the object with the smallest value of $I^&lt;/em&gt;$ wins the race.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that $I^*=1/2$ for a solid cylinder and $I^*=1$ for a hollow cylinder&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Calculate $I^*$ for a partly hollow ball with inner radius $a$ and outer radius $r$. Express your answer in terms of $b=a/r$. What happened when as $a\to 0$ and as $a\to r$?&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Problem 6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that $I^*=2/5$ for a solid ball and $I^*=2/3$ for a hollow ball. Thus the objects finish in following order: solid ball, solid cylinder, hollow ball, hollow cylinder.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Solid ball is the situation $a \to 0$ in Problem 5, thus $I^*=2/5$&lt;/p&gt;
&lt;p&gt;Hollow ball is the situation $a \to r$ in Problem 5, thus $I^*=2/3$&lt;/p&gt;
&lt;p&gt;According to Problem 3, the object having smaller $I^*$ will arrive sooner.&lt;/p&gt;
&lt;p&gt;Since $2/5 &amp;lt; 1/2 &amp;lt; 2/3 &amp;lt; 1$, the objects arrive in following order: solid ball, solid cylinder, hollow ball, hollow cylinder.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.15.8 - 滾動競賽</title>
      <link>https://teshenglin.github.io/post/2020_cal_s15p8_ch/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s15p8_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.15.8, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s15p8&#34;&gt;Roller Derby&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設有一實心圓球(如一顆彈珠)、一空心圓球 (如一顆壁球)、一實心圓柱(如一根鋼條)、與一空心圓柱(如一根鉛管)同時由一斜面滾下，何者會最先到達斜面底端?&lt;/p&gt;
&lt;p&gt;為了回答此問題，我們考慮一質量為 $m$，半徑為 $r$ 的圓柱體或球體，其對轉軸之轉動慣量為 $I$。設滾落過程的鉛直高度變化為 $h$，故其位能之變化量為 $mgh$。再設其到達斜面底端時速度為 $v$，角速度為 $\omega$，有關係式 $v=\omega r$。其在斜面底部的動能由兩部分組成：移動動能 $\frac{1}{2}mv^2$ 與轉動動能 $\frac{1}{2}I\omega ^2$。假設在滾落過程中的能量損失可忽略，根據能量守恆定律可得：
$$
mgh=\frac{1}{2}mv^2+\frac{1}{2}I\omega ^2
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;說明
$$
v^2=\frac{2gh}{1+I^&lt;em&gt;},\quad \text{其中  } I^&lt;/em&gt;=\frac{I}{mr^2}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$y(t)$ 為時間 $t$ 時的鉛直下落量。而由問題一可知在不論時間 $t$ 為何，皆有關係式： $v^2=2gy/(1+I^&lt;em&gt;)$。以此結果證明 $y$ 符合以下微分方程：
$$
\frac{dy}{dt}= \sqrt{\frac{2g}{1+I^&lt;/em&gt;}}(\sin{\alpha})\sqrt{y}
$$
其中 $\alpha$ 為斜面傾角。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;藉由求解問題2之方程式，得出自斜面頂端滾至底端之時長 $T$ 為：
$$
T=\sqrt{\frac{2h(1+I^&lt;em&gt;)}{g\sin^2\alpha}}
$$
亦即 $I^&lt;/em&gt;$ 最小之物品將最先滾至底端。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;證明實心圓柱之 $I^*=1/2$，空心圓柱之 $I^*=1$。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;計算內徑 $a$，外徑 $r$ 之部分空心球體之 $I^&lt;em&gt;$。答案以 $b$ 表示，其中 $b=a/r$。求當 $a\to 0$ 或當 $a\to r$ 時的 $I^&lt;/em&gt;$。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;說明實心球體的 $I^*=2/5$，而空心球體的 $I^*=2/3$。因此滾至斜面底部的順序為實心球體、實心柱體、空心球體、空心柱體。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;實心球體即問題5中 $a \to 0$ 的情況，因此其 $I^*=2/5$&lt;/p&gt;
&lt;p&gt;空心球體即問題5中 $a \to r$ 的情況，因此其 $I^*=2/3$&lt;/p&gt;
&lt;p&gt;由問題3之結果可知 $I^*$ 最小者最先到達。&lt;/p&gt;
&lt;p&gt;因此由於 $2/5 &amp;lt; 1/2 &amp;lt; 2/3 &amp;lt; 1$，可知滾至斜面底部的順序為實心球體、實心柱體、空心球體、空心柱體。&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.5.2 - Area functions</title>
      <link>https://teshenglin.github.io/post/2020_cal_s5p2/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s5p2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Discovery Project in Sec.5.2, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s5p2_ch&#34;&gt;面積函數&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Draw the line $y = 2t+1$ and use geometry to find the area under this line, above the t-axis, and between the vertical lines $t=1$ and $t = 3$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;let $f(x)=y=2t+1$, then $f(1)=3$ and $f(3)=7$.&lt;/p&gt;
&lt;p&gt;So, Area$= \frac{1}{2}(3+7)(3-1) = 10$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If $x&amp;gt;1$, let $A(x)$ be the area of the region that lies under the line $y = 2t + 1$ between $t =1$ and $t = x$. Sketch this region and use geometry to find expression for $A(x)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$f(1)=3$ and $f(x)=2x+1$.&lt;/p&gt;
&lt;p&gt;Area$= A(x) = \frac{1}{2}(2x+1+3)(x-1) = x^2 +x -2 $&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Differentiate the area function $A(x)$. What do you notice?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Because $A(x) = x^2+x-2$, then $A’(x) = 2x+1$.&lt;/p&gt;
&lt;p&gt;We can found that $A’(x)$ have the same form with $f(x) = y = 2t+1$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If $x \geq  -1$, let
$$
A(x) = \int_{-1}^{x} (1+t^2)dt
$$
$A(x)$ represents the area of a region. Sketch that region.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use the result of Exercise 5.2.28 to find an expression for $A(x)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
A(x) = \int_{-1}^{x} (1+t^2)dt =\frac{t^3-(-1)^3}{3}+x+1
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Find $A&#39;(x)$. What do you notice?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$A’(x) = 1+t^2$, we can found that $A’(x)$ is the upper bound of the area of a region.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(d):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If $x \geq  -1$ and &lt;em&gt;h&lt;/em&gt; is a small positive number, then $A(x+h) - A(x)$ represents the area of a region. Describe and sketch the region.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The area is trapezoid, the length of base is $h$ ,and the length of parallel sides is $A(x+h)$  and $A(x)$ ,respectively.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_3.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_3.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(e):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Draw a rectangle that approximates the region in part (d). By comparing the areas of these two regions, show that
$$
\frac{A(x+h)-A(x)}{h} \approx 1+x^2
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_4.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_4.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(f):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use part (e) to give an intuitive explanation for the result of part (c).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the result of part (c) is equal to the result of part (e) ,which means when we cut the area into infinite areas, the result will equal to the differentiate of the formula.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Draw the graph of the function $f(x)=cos(x^2)$ in the viewing rectangle $[0,2]$ by $[-1.25,1.25]$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_5.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_5.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If we define a new function $g$ by
$$
g(x) = \int_{0}^{x}\cos(t^2) dt
$$
then $g(x)$ is the area under the graph of $f$ from $0$ to $x$ [until $f(x)$ becomes negative, at which point $g(x)$ becomes a difference of areas.] Use part (a) to determine the value of $x$ at which $g(x)$ starts to decrease. [Unlike the integral in Problem 2, it is impossible to evaluate the intergral defining $g$ to obtain an explicit expression for $g(x)$]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;According to part (a), we can found that $g(x)$ starts to decrease when the line goes under x-axis. Thus, $x^2 = \pi \to x\approx1.77245$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use the integration command on your calculator or computer to estimate $g(0.2)$, $g(0.4),g(0.6),\cdots,g(1.8),g(2)$. Then use these values to sketch a graph of $g$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$g(x)$ is the blue line in the graph.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;g(x)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.399&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.5923&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.7678&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9045&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9739&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9498&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6354&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.4615&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_6.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_6.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(d):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use your graph of $g$ from part (c) to sketch the graph of $g’$ using the interpretation of $g’(x)$ as the slope of a tangent line. How does the graph of $g’$ compare with the graph of $f$ ?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can found that $g’(x)$ is almost the same with the graph of $f$.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;g’(x)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.995&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9665&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8775&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6835&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.347&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.1205&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.6215&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.9505&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.8695&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_7.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_7.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose $f$ is a continuous function on the interval $[a,b]$ and we define a new function $g$ by the equation
$$
g(x) = \int_{a}^{x} f(x)dt
$$
Based on your result in Problem 1-3, conjecture an expression for $g’(x)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Based on the result in Problem 1-3, we can conjecture that $g’(x) = f(x)$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.5.2 - 面積函數</title>
      <link>https://teshenglin.github.io/post/2020_cal_s5p2_ch/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s5p2_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Discovery Project in Sec.5.2, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s5p2&#34;&gt;Area functions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;畫出 $y = 2t+1$ 且用幾何方法找出在此線下方、$t$軸上方、與$t＝1$和$ｔ＝３$兩條垂直線所圍出的面積.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 $f(x)=y=2t+1$, 則 $f(1)=3$ 且 $f(3)=7$. 所以其面積為$\frac{1}{2}(3+7)(3-1) = 10$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 $x  &amp;gt; 1$, 令 $A(x)$ 是由 $y = 2t + 1$、$t$軸與 $t =1$ 和 $t = x$ 所圍出的面積 。畫出這個區域並用幾何方法表達 $A(x)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$f(1)=3$ and $f(x)=2x+1$.&lt;/p&gt;
&lt;p&gt;Area$= A(x) = \frac{1}{2}(2x+1+3)(x-1) = x^2 +x -2 $&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;將 $A(x)$ 微分，你注意到了什麼？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為 $A(x) = x^2+x-2$, 所以 $A’(x) = 2x+1$. 我們可以得知 $A’(x)$ 和 $f(x) = y = 2t+1$ 形式相同.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 $x \geq  -1$ ， 令
$$
A(x) = \int_{-1}^{x} (1+t^2)dt
$$
$A(x)$ 代表所圍成的面積， 畫出此區域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用練習題 5.2.28的結果來找出一種方法表示 $A(x)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
A(x) = \int_{-1}^{x} (1+t^2)dt =\frac{t^3-(-1)^3}{3}+x+1
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出 $A&#39;(x)$ ，你察覺到了什麼？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 $A’(x) = 1+t^2$ ，我們可以得知 $A’(x)$ 是所圍成區域的拋物線&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(d):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果  $x \geq  -1$ 且 &lt;em&gt;h&lt;/em&gt; 為極小正實數，則 $A(x+h) - A(x)$ 代表此區域的面積。 敘述且畫出此區域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此區域為梯形， 其底為 $h$ 且其兩條平行線的長度分別為  $A(x+h)$  和 $A(x)$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_3.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_3.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(e):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;畫出一個長方形來估計 (d)部分的區域面積。 藉由比較這兩個區域的面積來顯示
$$
\frac{A(x+h)-A(x)}{h} \approx 1+x^2
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_4.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_4.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2(f):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用 (e)部分來給予 (c)部分的結果直觀的解釋。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如我們所見(c)部分的結果和 (e)部份相同 ，而這代表當我們將一個區域劃分為無限個區域時其結果會等同於此函式的微分 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(a):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;畫出此方程式 $f(x)=cos(x^2)$ 在[0,2]$ 及 $[-1.25,1.25]​的視窗內&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_5.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_5.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(b):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我們定義 $g$ 為
$$
g(x) = \int_{0}^{x}\cos(t^2) dt
$$
則 $g(x)$ 是 $f$ 函式 從 $0$ 到 $x$ 下的面積 [直到 $f(x)$ 小於 $0$, 當 $g(x)$ 和所圍出的面積不同時] 用 (a)部分來決定當 $g(x)$ 開始減少時的 $x$ 值。[不同於問題2 的積分,，我們不可能得到一個清楚的積分表達式來定義 $g(x)$]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由(a)部分，我們可以得到當此線在x軸之下 $g(x)$ 開始減少。因此, $x^2 = \pi \to x\approx1.77245$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(c):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用積分計算機來計算 $g(0.2),$ $g(0.4),g(0.6),\cdots,g(1.8),g(2)$. 然後用這些直來畫出 $g$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$g(x)$ 為圖中的藍線&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;g(x)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.399&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.5923&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.7678&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9045&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9739&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9498&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6354&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.4615&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_6.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_6.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3(d):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用(c)部分 $g$ 的圖把$$g’(x)$$作為切線的斜率來畫出 $g’$ ，且將  $g’$ 和 $f$ 比較&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我們可以看出 $g’(x)$ 幾乎和  $f$ 相同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;g’(x)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.995&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9665&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.8775&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.6835&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.347&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.1205&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.6215&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.9505&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-0.8695&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/cals5p2_7.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/cals5p2_7.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;設想 $f$ 在區間 $[a,b]$ 為連續函數，並將函式 $g$ 由方程式定義為
$$
g(x) = \int_{a}^{x} f(x)dt
$$
由練習 1-3的結論， 推測 $g’(x)$ 的表達式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由練習 1-3的結論，我們可以推測 $g’(x) = f(x)$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>以內插多項式來做數值積分</title>
      <link>https://teshenglin.github.io/post/2020_numerical_integration_2/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_numerical_integration_2/</guid>
      <description>&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_numerical_integration&#34;&gt;數值積分初探&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;連續函數可以用多項式來逼近它, 因此直覺來講, 既然我們已經找到一個離給定函數&amp;quot;很近&amp;quot;的多項式了, 何不就以這個多項式的積分值來當成原函數積分值的一個逼近呢.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;goal-任意給定一可積分函數-fx-xin-1-1-我們想要算-int1_-1-fx-dx&#34;&gt;Goal: 任意給定一可積分函數 $f(x)$, $x\in[-1, 1]$, 我們想要算 $\int^1_{-1} f(x) dx$.&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我們先講內插多項式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定任意 $n+1$ 個不重複的點在 $[-1, 1]$ 區間, 我們把他們記為 $x_0, x_1, \cdots, x_n.$
接著我們計算函數 $f(x)$ 在這些點上的值, 記為 $f_i = f(x_i)$, 這樣我們就有平面上的 $n+1$ 個點座標 $(x_i, f_i)$.&lt;/p&gt;
&lt;p&gt;有這些點我們就一定能找到一個 $n$ 次多項式 $p_n(x)$ 使得說這個多項式會通過這些所有的點, 也就是 $p_n(x_i) = f_i$. 這就叫做內插多項式.&lt;/p&gt;
&lt;p&gt;內插多項式一個很簡潔的表示法是把它寫成 Lagrange polynomial 的樣子. 我們先引進 Lagrange basis function
$$
\ell_i(x) = \prod^n_{k=0, k\ne i} \frac{x-x_k}{x_i-x_k}.
$$
很明顯可以看出這是一個 $n$ 次多項式, 而且有很特殊的性質, 也就是 $\ell_i(x_j)=\delta_{ij}$.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\delta_{ij}$ 是所謂的 Kronecker delta function, 如果 $i=j$ 則 $\delta_{ij}=1$, 反之如果 $i\ne j$ 則 $\delta_{ij}=0$. 舉例來說, $\delta_{11}=1$, 而 $\delta_{12}=0$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我們可以將內插多項式 $p_n(x)$ 改寫成
$$
p_n(x) = \sum^n_{i=0} f_i \ell_i(x).
$$
這就是內插多項式的 Lagrange 表示法.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;接著我們就可以來做積分了!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們直接以內插多項式來逼近函數並做積分,
$$
\int^1_{-1} f(x)dx \approx \int^1_{-1} p_n(x)dx = \int^1_{-1} \sum^n_{i=0} f_i \ell_i(x)dx = \sum^n_{i=0} f_i \left(\int^1_{-1} \ell_i(x)dx\right).
$$
理論上, 如果插值點 $x_i$ 是一開始就給定並且固定的, 那我們就可以把 Lagrange basis function $\ell_i(x)$ 算出來, 並且把他的積分也算出來. 我們把積分出來的值記為 $w_i$, 也就是
$$
w_i = \int^1_{-1} \ell_i(x)dx.
$$
如此我們就可以把積分改寫成
$$
\int^1_{-1} f(x)dx \approx \sum^n_{i=0} w_i f_i.
$$
這就是以內插多項式來做積分.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 如果 $f(x)$ 本身就是個 $n$ 次或以下的多項式, 那我們做出來的內插多項式就不是 approximation 而是等號了. 那這樣我們做出來的積分事實上應該就是等號! 也就是說
$$
\int^1_{-1} p(x)dx = \sum^n_{i=0} w_i f_i,
$$
where $p(x)$ is a polynomial with degree less than or equals to $n$.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;舉個簡單的例子來試試&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設我們只想要用兩個端點來估算積分, 那我們有 $x_0=-1, x_1=1$. 因此得到 Lagrange basis polynomials
$$
\ell_0(x) = \frac{x+1}{2}, \quad \ell_1(x)=\frac{x-1}{-2}.
$$
接著可以算出
$$
w_0 = \int^1_{-1} \ell_0(x)dx = 1, \quad w_1=\int^1_{-1}\ell_1(x)dx=1.
$$
也就是說
$$
\int^1_{-1} f(x)dx \approx f(-1) + f(1),
$$
得到所謂的梯形法!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;延伸閱讀: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_3&#34;&gt;高斯積分&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>高斯積分</title>
      <link>https://teshenglin.github.io/post/2020_numerical_integration_3/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_numerical_integration_3/</guid>
      <description>&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_numerical_integration&#34;&gt;數值積分初探&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_2&#34;&gt;以內插多項式來做數值積分&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我們想要找到一些插值點使得以內插多項式來做數值積分會最準. 這就是高斯積分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;goal-任意給定一可積分函數-fx-xin-1-1-我們想要算-int1_-1-fx-dx&#34;&gt;Goal: 任意給定一可積分函數 $f(x)$, $x\in[-1, 1]$, 我們想要算 $\int^1_{-1} f(x) dx$.&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;複習一下內插多項式的積分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定任意 $n+1$ 個不重複的點在 $[-1, 1]$ 區間, 記為 $x_0, x_1, \cdots, x_n.$ 我們可以逼近函數 $f(x)$ 的積分
$$
\int^1_{-1} f(x)dx \approx \sum^n_{i=0} w_i f_i,
$$
其中 $f_i = f(x_i)$, 並且
$$
w_i = \int^1_{-1} \ell_i(x)dx = \int^1_{-1} \left(\prod^n_{k=0, k\ne i} \frac{x-x_k}{x_i-x_k}\right) dx.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一個重要的 remark: 如果 $p(x)$ 是個 $n$ 次或以下的多項式, 那這個積分是等號!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是說
$$
\int^1_{-1} p(x)dx = \sum^n_{i=0} w_i f_i,
$$
where $p(x)$ is a polynomial with degree less than or equals to $n$.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;idea&#34;&gt;Idea:&lt;/h4&gt;
&lt;p&gt;高斯積分的想法就是, 我想要找到特別的點 $x_i$ 以及特別的權重 $w_i$ 使得我能算準的多項式次數最高.&lt;/p&gt;
&lt;p&gt;如果我們回想一下內插多項式, 給定點然後求 $n+1$ 個權重, 也就是有 $n+1$ 個未知數, 那顯然它所能滿足的方程式就是 $n+1$ 個. 如果要把多項式算準的話從常數($0$次)到 $n$次共可以列出剛好 $n+1$個方程式. 所以最多能把 $n$ 次多項式算準.&lt;/p&gt;
&lt;p&gt;現在假設點($x_i$)跟權重($w_i$)都是待決定的, 那我就有 $2(n+1)$ 個未知數, 能夠把多項式從常數($0$次)到 $2n+1$次都算準. 所以理論上, $n+1$ 個點的高斯積分可以將 $2n+1$次的多項式算準, 完全沒有誤差.&lt;/p&gt;
&lt;p&gt;那如果這這樣的想法直接列式的話就會得到以下 $2n+1$ 個方程式
$$
\int^1_{-1} x^m dx=\frac{1 - (-1)^{m+1}}{m+1} =  \sum^n_{i=0} w_i x^m_i, \quad 0\le m\le 2n+1.
$$
然後解以上的非線性聯立方程式就可以得到所有的點 $x_i$ 及權重 $w_i$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看起來有點困難&lt;/strong&gt;, 不過好消息是其實不難解.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我們需要引進正交多項式 (orthogonal polynomials)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在線性代數裡我們知道兩個向量如果正交則其內積等於零. 函數空間裡我們也可以做一樣的定義, 我們定義兩個函數的內積
$$
(f, g) = \int^1_{-1} f(x)g(x) dx.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition&lt;/h2&gt;
&lt;p&gt;$f(x)$ and $g(x)$ are orthogonal if $(f,g)=0$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們知道 $n$ 次多項式有一組最基本的基底 ${1, x, x^2, \cdots, x^n}$, 將這組基底以 Gram-Schimidt 做正交化就可以得到一組正交基底. 這組正交基底就是所謂的 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Legendre_polynomials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Legendre polynomials&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我們將 Legendre polynomials 這組正交基底記為 $P_i(x)$, 其前三個如下:
$$
P_0(x) = 1, \quad P_1(x) = x, \quad P_2(x)=\frac{1}{2}(3x^2-1).
$$&lt;/p&gt;
&lt;p&gt;Legendre polynomials 有以下兩個性質:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$P_i(x)$ 是一個 $i$次多項式&lt;/li&gt;
&lt;li&gt;$(P_i(x), P_j(x)) = \delta_{ij} = \begin{cases}
0, \quad i\ne j, \\&lt;br&gt;
1, \quad i=j.
\end{cases}$
&lt;ul&gt;
&lt;li&gt;對任何多項式 $Q(x)$ 如果其次數小於 $i$, 則有 $(P_i(x), Q(x))=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;高斯積分的點與權重&#34;&gt;高斯積分的點與權重:&lt;/h4&gt;
&lt;p&gt;任意給定一個 $2n+1$ 次多項式 $p(x)$, 我們可以透過多項式的除法把它分解成以下這種樣子
$$
p(x) = P_{n+1}(x)Q(x) + R(x),
$$
其中 $Q(x)$ 以及 $R(x)$ 都是至多 $n$ 次的多項式. 透過這樣的分解我們發現
$$
\int^1_{-1} p(x)dx = \int^1_{-1} P_{n+1}(x)Q(x) + R(x)dx = \int^1_{-1} R(x)dx,
$$
其中 $P_{n+1}$ 與 $Q$ 相乘後的積分等於零是用到上面正交多項式的性質.&lt;/p&gt;
&lt;p&gt;以上這積分如果以數值積分來表示的話就是
$$
\int^1_{-1} p(x)dx \approx \sum^n_{i=0} w_i p(x_i) = \sum^n_{i=0} w_i \left(P_{n+1}(x_i)Q(x_i) + R(x_i)\right).
$$
我們希望數值積分也會有 &amp;ldquo;$P_{n+1}$ 與 $Q$ 相乘的積分等於零&amp;rdquo; 這件事. 那一個最簡單的取法就是我們取 $x_i$ 是 $P_{n+1}(x)$ 這個 $n+1$ 次多項式所有的根. 由於 $P_{n+1}$ 剛好有 $n+1$ 個不重複的根, 這樣我們就有 $x_i$ 這些點了, 而且 $P_{n+1}(x_i)=0$ 表示
$$
\sum^n_{i=0} w_i P_{n+1}(x_i)Q(x_i)=0,
$$
所以
$$
\int^1_{-1} p(x)dx \approx \sum^n_{i=0} w_i R(x_i),
$$
也就是說我們只需要把 $R(x)$ 這個 $n$ 次多項式算準就好. 那我們就可以用內插多項式算權重的方法把權重都寫下來
$$
w_i = \int^1_{-1} \left(\prod^n_{k=0, k\ne i} \frac{x-x_k}{x_i-x_k}\right) dx.
$$&lt;/p&gt;
&lt;p&gt;如此, 我們就把&lt;code&gt;點&lt;/code&gt;跟&lt;code&gt;權重&lt;/code&gt;都求出來了.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;最後總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$n+1$ 個點的高斯積分可以將 $2n+1$ 次多項式算準無誤差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高斯點是正交多項式 $P_{n+1}(x)$ 的 $n+1$ 個根&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求出高斯點後我們以內插多項式的做法來求出權重&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;舉個簡單的例子來試試&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設我們只想要用兩個點來估算積分, 那 Legendre polynomial 的 $P_2(x)=\frac{1}{2}(3x^2-1)$.&lt;/p&gt;
&lt;p&gt;由此可算出兩個高斯點, 也就是 $P_2$ 的兩個根是
$$
x_0 = -\frac{1}{\sqrt{3}}, \quad x_1 = \frac{1}{\sqrt{3}}.
$$
接著權重也可以簡單的算出來, 我們得到.
$$
w_0 = w_1 = 1.
$$
因此, 兩個點的高斯積分公式是
$$
\int^1_{-1} f(x)dx = f\left(-\frac{1}{\sqrt{3}}\right) + f\left(\frac{1}{\sqrt{3}}\right),
$$
可以將 3次(含)以下的多項式算準無誤差.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;再延伸一下&#34;&gt;再延伸一下&lt;/h4&gt;
&lt;p&gt;對於更廣義有權重的積分
$$
\int^1_{-1} w(x)f(x)dx,
$$
我們只要找出相對應的正交多項式, 我們一樣可以求出其高斯積分點以及權重.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;舉例來說, $w(x)=\frac{1}{1+x^2}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其相對應的內積以及積分為
$$
(f,g) = \int^1_{-1} \frac{1}{1+x^2}f(x)g(x)dx, \quad \int^1_{-1} \frac{1}{1+x^2}f(x)dx.
$$
其正交多項式為 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Chebyshev_polynomials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chebyshev polynomials&lt;/a&gt;, $T_i(x)$, 前三項為:
$$
T_0(x) = 1, \quad T_1(x) =x, \quad T_2(x) = 2x^2-1.
$$
比較特別的是其高斯點, 稱為 Gauss-Chebyshev points, 可以直接求出來:
$$
x_i = \cos\left(\frac{(i+\frac{1}{2})\pi}{n+1}\right), \quad 0\le i\le n.
$$
而且權重也可以直接求出來:
$$
w_i = \frac{\pi}{n+1}.
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.13.4 - Kepler’s Laws</title>
      <link>https://teshenglin.github.io/post/2020_cal_s13p4/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s13p4/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.13.4, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s13p4_ch&#34;&gt;克卜勒定律&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Johannes Kepler stated the following three laws of planetary motion on the basis of massive amounts of data on the positions of the planets at various times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kepler’s Laws&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A planet revolves around the sun in an elliptical orbit with the sun at one focus.&lt;/li&gt;
&lt;li&gt;The line joining the sun to a planet sweeps out equal areas in equal times.&lt;/li&gt;
&lt;li&gt;The square of the period of revolution of a planet is proportional to the cube of the length of the major axis of its orbit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kepler formulated these laws because they fitted the astronomical data. He wasn’t able to see why they were true or how they related to each other. But Sir Isaac Newton, in his &lt;em&gt;Principia Mathematica&lt;/em&gt; of 1687, showed how to deduce Kepler’s three laws from two of Newton’s own laws, the Second Law of Motion and the Law of Universal Gravitation. In Section 13.4 we proved Kepler’s First Law using the calculus of vector functions. In this project we guide you through the proofs of Kepler’s Second and Third Laws and explore some of their consequences.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question 1&lt;/strong&gt;：  Use the following steps to prove Kepler’s Second Law. The notation is the same as in  the proof of the First Law in Section 13.4. In particular, use polar coordinates so that $\vec{r} = r\cos{\theta} \vec{i} + r\sin{\theta} \vec{j}$.&lt;/p&gt;
&lt;p&gt;(a) Show that $\vec{h}=r^2 \frac{d\theta}{dt} \vec{k}$.&lt;/p&gt;
&lt;p&gt;(b) Deduce that $r^2 \frac{d\theta}{dt}=h$.&lt;/p&gt;
&lt;p&gt;(c) If $A=A(t)$ is the area swept out by the radius vector $r=r(t)$ in the time interval $[t_0, t]$. Show that
$$
\frac{dA}{dt}=\frac{1}{2}r^2\frac{d\theta}{dt}
$$&lt;/p&gt;
&lt;p&gt;(d) Deduce that
$$
\frac{dA}{dt}=\frac{1}{2}h= c,
$$
where $c$ is a constant. This says that the rate at which $A$ is swept out is constant and proves Kepler’s Second Law.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2&lt;/strong&gt;： Let $T$ be the period of a planet about the sun; that is, $T$ is the time required for it to travel once around its elliptical orbit. Suppose that the lengths of the major and minor axes of the ellipse are $2a$ and $2b$.&lt;/p&gt;
&lt;p&gt;(a) Use part (d) of Problem 1 to show that $T =2\pi ab h$.&lt;/p&gt;
&lt;p&gt;(b) Show that
$$
\frac{h^2}{GM}=ed=\frac{b^2}{a}
$$&lt;/p&gt;
&lt;p&gt;(c) Use parts (a) and (b) to show that
$$
T^2=\frac{4\pi^2}{GM}a^3
$$&lt;/p&gt;
&lt;p&gt;This proves Kepler’s Third Law. [Notice that the proportionality constant $\frac{4\pi^2}{GM}$ is independent of the planet.]&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Quesion 3&lt;/strong&gt;： The period of the earth’s orbit is approximately 365.25 days. Use this fact and Kepler’s Third Law to find the length of the major axis of the earth’s orbit. You will need the mass of the sun, $M=1.99\times 10^{30}kg$, and the gravitational constant, $G=6.67\times10^{-11}N-m^2/kg^2$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;$$
a^3=\frac{GMT^2}{4\pi^2}
$$&lt;/p&gt;
&lt;p&gt;$$
a=(\frac{GMT^2}{4\pi^2})^{\frac{1}{3}}\approx149600000km
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4&lt;/strong&gt;：  It’s possible to place a satellite into orbit about the earth so that it remains fixed above a given location on the equator. Compute the altitude that is needed for such a satellite.  The earth’s mass is $5.98\times 10^{24}kg$; its radius is $6.37\times 10^{6}m$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;：
$$
h=(\frac{GM_eT^2}{4\pi^2})^{\frac{1}{3}}-R\approx42.25\times10^6-6.37\times10^6=35880km
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.13.4 - 克卜勒定律</title>
      <link>https://teshenglin.github.io/post/2020_cal_s13p4_ch/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s13p4_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.13.4, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s13p4&#34;&gt;Kepler’s Laws&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;約翰尼斯‧克卜勒在有關不同時間行星位置的大量數據基礎上，提出了以下三個行星運動定律。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;克卜勒定律&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一個行星都沿各自的橢圓軌道環繞太陽，而太陽則處在橢圓的一個焦點中。&lt;/li&gt;
&lt;li&gt;在相等時間內，太陽和行星連線所掃過的面積都是相等的。&lt;/li&gt;
&lt;li&gt;各個行星繞太陽公轉週期的平方和它們的橢圓軌道的半長軸的立方成正比。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;克卜勒制定這些定律是因為它們符合天文數據。 他看不出它們為什麼是對的或它們之間如何相互聯繫。 但是，艾薩克·牛頓爵士在1687年的《數學原理》一書中展示如何從牛頓自己的兩個定律，第二運動定律和萬有引力定律中推論克卜勒的三個定律。 在第13.4節中，我們使用向量函數演算證明了克卜勒第一定律。 在本專題中，我們將指導你了解克卜勒第二定律和第三定律的證明，並探討其中的一些結果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;問題 1&lt;/strong&gt;：  使用以下步驟來證明克卜勒第二定律，其記號與第13.4節中的第一定律證明相同。特別的是要使用極座標，意即 $\vec{r} = r\cos{\theta} \vec{i} + r\sin{\theta} \vec{j}$.&lt;/p&gt;
&lt;p&gt;(a) 證明 $\vec{h}=r^2 \frac{d\theta}{dt} \vec{k}$.&lt;/p&gt;
&lt;p&gt;(b) 解釋 $r^2 \frac{d\theta}{dt}=h$.&lt;/p&gt;
&lt;p&gt;(c) 若 $A=A(t)$ 是向量 $r=r(t)$ 在時間間隔 $[t_0, t]$ 內掃過的面積, 證明
$$
\frac{dA}{dt}=\frac{1}{2}r^2\frac{d\theta}{dt}
$$&lt;/p&gt;
&lt;p&gt;(d) 解釋
$$
\frac{dA}{dt}=\frac{1}{2}h=c,
$$
其中 $c$ 是常數. 如此證明了克卜勒第二定律，即面積速率為定值。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2&lt;/strong&gt;： 令 $T$ 是行星繞日之週期，$2a$ 為橢圓軌道長軸，$2b$ 為短軸。&lt;/p&gt;
&lt;p&gt;(a)利用上題(d)小題證明 $T =2\pi ab /h$.&lt;/p&gt;
&lt;p&gt;(b) 證明
$$
\frac{h^2}{GM}=ed=\frac{b^2}{a}
$$&lt;/p&gt;
&lt;p&gt;(c) 利用 (a) 和 (b) 小題證明
$$
T^2=\frac{4\pi^2}{GM}a^3
$$&lt;/p&gt;
&lt;p&gt;這證明了克卜勒第三定律. [注意比例常數 $\frac{4\pi^2}{GM}$ 與行星無關.]&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3&lt;/strong&gt;： 地球公轉周期約為 365.25 天.利用克卜勒第三定律找出半長軸. 其中太陽質量為 $M=1.99\times 10^{30}kg$, 重力常數為 $G=6.67\times10^{-11}N-m^2/kg^2$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$
a^3=\frac{GMT^2}{4\pi^2}
$$&lt;/p&gt;
&lt;p&gt;$$
a=(\frac{GMT^2}{4\pi^2})^{\frac{1}{3}}\approx149600000km
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4&lt;/strong&gt;：  計算赤道上同步衛星之高度. 其中地球質量為 $5.98\times 10^{24}kg$; 地球半徑為 $6.37\times 10^{6}m$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法&lt;/strong&gt;：
$$
h=(\frac{GM_eT^2}{4\pi^2})^{\frac{1}{3}}-R\approx42.25\times10^6-6.37\times10^6=35880km
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.14.4 - The speedo LZR razer</title>
      <link>https://teshenglin.github.io/post/2020_cal_s14p4/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s14p4/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.14.4, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s14p4_ch&#34;&gt;速比濤鯊魚皮系列第四代泳裝&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many technological advances have occurred in sports that have contributed to increased athletic performance. One of the best known is the introduction, in 2008, of the Speedo LZR racer. It was claimed that this full-body swimsuit reduced a swimmer’s drag in the water. Figure 1 shows the number of world records broken in men’s and women’s long-course freestyle swimming events from 1990 to 2011. The dramatic increase in 2008 when the suit was introduced led people to claim that such suits are a form of technological doping. As a result all full-body suits were banned from competition starting in 2010.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;It might be surprising that a simple reduction in drag could have such a big effect on performance. We can gain some insight into this using a simple mathematical model.&lt;/p&gt;
&lt;p&gt;The speed $v$ of an object being propelled through water is given by
$$
v(P,C)=\left(\frac{2P}{kC}\right)^{\frac{1}{3}},
$$
where $P$ is the power being used to propel the object, $C$ is the drag coefficient, and $k$ is a positive constant. Athletes can therefore increase their swimming speeds by increasing their power or reducing their drag coefficients. But how effective is each of these?&lt;/p&gt;
&lt;p&gt;To compare the effect of increasing power versus reducing drag, we need to somehow compare the two in common units. The most common approach is to determine the percentage change in speed that results from a given percentage change in power and in drag.&lt;/p&gt;
&lt;p&gt;If we work with percentages as fractions, then when power is changed by a fraction $x$ (with $x$ corresponding to $100x$ percent), $P$ changes from $P$ to $P + xP$. Likewise, if the drag coefficient is changed by a fraction $y$, this means that it has changed from $C$ to $C + yC$. Finally, the fractional change in speed resulting from both effects is
$$
f(x,y)=\frac{v(P+xP,C+yC)-v(P,C)}{v(P,C)}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The function $f$  gives the fractional change in speed that results from a change $x$ in power and a change $y$ in drag. Show that this reduces to the function
$$
f(x,y)=\left(\frac{1+x}{1+y}\right)^{\frac{1}{3}}-1.
$$
Given the context, what is the domain of $f$?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The domain of $f$ is
$$
{(x,y)\mid x\geq-1,\quad y&amp;gt;-1}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose that the possible changes in power $x$ and drag $y$ are small. Find the linear approximation to the function $f(x, y)$. What does this approximation tell you about the effect of a small increase in power versus a small decrease in drag?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The effect of a small increase in power vs. a small decrease in drag&lt;/p&gt;
&lt;p&gt;According to the linear approximation to the function $f$ , the small increase in power $x$ and the small decrease in drag $y$ have the same impact on changes in speed $f$ with the proportion of one-third. Consequently, in terms of the fractional change in speed, there is no significant difference between the small increase in power and the small decrease in drag.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Calculate $f_{xx}(x, y)$ and $f_{yy}(x, y)$. Based on the signs of these derivatives, does the linear approximation in Problem 2 result in an overestimate or an underestimate for an increase in power? What about for a decrease in drag? Use your answer to explain why, for changes in power or drag that are not very small, a decrease in drag is more effective.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Graph the level curves of $f(x, y)$. Explain how the shapes of these curves relate to your answers to Problems 2 and 3.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Graph the level curve with h= -0.75, -0.5, -0.25, 0, 0.05, 0.25, 0.5, 0.75, 1&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;A little changes in power or drags&lt;/p&gt;
&lt;p&gt;Suppose that a little changes in power or drags at point $(0, 0)$ leads to a change in $h$ from $h=0$ to $h=0.05$. In order to reach $h=0.05$ from point $(0, 0)$, the power has to increase about $0.158$ (point A), or the drag has to decrease about $0.136$ (point B). These two value are closed to each other. The result correspond with the answer of Problem 2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A considerable changes in power or drags&lt;/p&gt;
&lt;p&gt;Suppose that a considerable changes in power or drags at point $(0, 0)$ leads to a change in $h$ from $h=0$ to $h=0.5$. In order to reach $h=0.5$ from point $(0, 0)$, the power has to increase about $2.38$ (point D), or the drag has to decrease $0.704$ (point C).  The decrease in drag is about 3.4 times more efficient than the increase in power. $(2.38/0.74=3.4)$ The result correspond with the answer of Problem 3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.14.4 - 速比濤鯊魚皮系列第四代泳裝</title>
      <link>https://teshenglin.github.io/post/2020_cal_s14p4_ch/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s14p4_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.14.4, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s14p4&#34;&gt;The speedo LZR razer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在體育運動中, 許多科技的進步讓運動員的表現更好. 最廣為人知的例子之一就是速比濤在2008年時推出鯊魚皮系列第四代泳裝, 宣稱這個連身泳衣可以減少泳者在水中的阻力. 圖1 顯示1990年到2011年男性和女性在長程自由式的賽事中打破世界紀錄的數量, 可以發現在2008年時數量大大的增加, 恰好是那款泳衣推出的時候, 這讓大家覺得這種泳衣根本就是一種科技的「禁藥」, 結果2010年以後所有的連身泳衣在競賽中都被禁止使用.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;可能會讓人驚訝的是純粹減少阻力竟然可以在表現上有這麼大的影響力! 我們可以藉由簡單的數學模型更深入的探討這個現象.&lt;/p&gt;
&lt;p&gt;在水中物體被驅動的速率 $v$ 公式如下
$$
v(P,C)=\left( \frac{2P}{kC}\right)^{\frac{1}{3}},
$$
其中 $P$ 代表驅動物體所使用的功率, $C$ 是阻力係數, $k$ 是一個大於零的定值. 因此, 運動員可以藉由增加功率或是減少阻力係數來增加游泳速率, 但是這兩個因素影響速率的效果如何呢?&lt;/p&gt;
&lt;p&gt;為了比較「增加功率」和「減少阻力」的影響, 我們需要以某種方式在共同的單位下比較兩者的差異. 最常見的方法就是給定一個功率或是阻力的百分比變化率, 測定速率隨之改變多少百分比.&lt;/p&gt;
&lt;p&gt;若我們以分數的形式代表百分比, 則當功率被改變 $x$ 的比例後($x$對應到 $100x$), $P$ 會變化成 $P + xP$. 同理, 若阻力係數被改變 $y$ 的比例, $C$ 會變化成 $C + yC$. 最後, 這兩個因素造成的速率比例的改變為:
$$
f(x,y)=\frac{v(P+xP,C+yC)-v(P,C)}{v(P,C)}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函數 $f$ 代表功率的改變比例 $x$ 和阻力的改變比例 $y$ 所造成的速率改變比例, 請說明這個函數可以簡化成
$$
f(x,y)=\left(\frac{1+x}{1+y}\right)^{\frac{1}{3}}-1
$$
由文字給定的敘述中, 請問函數 $f$ 的定義域為何?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$f$ 的定義域為
$$
\{ (x,y)\mid x\geq-1,\quad y&amp;gt;-1 \}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假設功率的改變比例 $x$ 和阻力的改變比例 $y$ 很小, 找出 $f(x, y)$ 的線性近似. 請問這個近似告訴你關於「增加功率」和「減少阻力」的影響存在哪些差異?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;比較「增加功率」和「減少阻力」的影響&lt;/p&gt;
&lt;p&gt;根據函數 $f$ 線性逼近的結果, 增加功率 $x$ 或減少阻力 $y$ 所造成速率的增加比例都是三分之一. 因此, 對於速率的增加比例而言, 少量增加功率抑或是少量減少阻力所造成的影響並沒有差異.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;計算 $f_{xx}(x, y)$ 和 $f_{yy}(x, y)$. 根據這些導數的正負號, 請問題目2的線性近似對於「增加功率」是低估還是高估呢? 那麼對於「減少阻力」呢? 利用你的答案解釋為什麼在功率或阻力的變化量不小的情況下, 「減少阻力」比較有效率?&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;畫出 $f(x, y)$ 的等高線圖, 解釋這些等高線的形狀和問題 2 和 3 有哪些關聯性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;畫出在 h= -0.75, -0.5, -0.25, 0, 0.05, 0.25, 0.5, 0.75, 1的等高線&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s14p4_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;當功率和阻力變化量很小&lt;/p&gt;
&lt;p&gt;假設在點 $(0, 0)$ 時很小的功率和阻力變化量導致 $h$ 從 $h=0$ 變化成 $h=0.05$. 為了從點 $(0,0)$ 達到 $h=0.05$, 功率需要增加大約 $0.158$ (點 A) 或者是阻力需要增加大概 $0.136$ (點 B), 這兩個值相當接近, 這個結果呼應了問題 2 的答案.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;當功率和阻力變化量較大&lt;/p&gt;
&lt;p&gt;假設在點 $(0, 0)$ 時較大的功率和阻力變化量導致 $h$ 從 $h=0$ 變化成 $h=0.5$. 為了從點 $(0, 0)$ 達到 $h=0.5$, 功率需要增加大約 $2.38$ (點 D) 或者是阻力需要增加大概 $0.704$ (點 C), 可見「減少阻力」比「增加功率」的效率還要高出約 $3.4$倍 ($2.38/0.74=3.4$), 這個結果呼應了問題 3 的答案.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.12.4 - The Geometry of a Tetrahedron</title>
      <link>https://teshenglin.github.io/post/2020_cal_s12p4/</link>
      <pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s12p4/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Discovery Project in Sec.12.4, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s12p4_ch&#34;&gt;四面體的幾何學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A tetrahedron is a solid with four vertices, &lt;em&gt;P&lt;/em&gt; ,&lt;em&gt;Q&lt;/em&gt; , &lt;em&gt;R&lt;/em&gt; and &lt;em&gt;S&lt;/em&gt; ,and four triangular faces, as shown in the figure.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s12p4_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s12p4_1.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let  $v_1, v_2, v_3$ and $v_4$ be vectors with lengths equal to the areas of the faces opposite the vertices &lt;em&gt;P&lt;/em&gt;, &lt;em&gt;Q&lt;/em&gt;, &lt;em&gt;R&lt;/em&gt; and &lt;em&gt;S&lt;/em&gt;, respectively, and directions perpendicular to the respective faces and pointing outward. Show that
$$
v_1+v_2+v_3+v_4=0
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The volume &lt;em&gt;V&lt;/em&gt; of a tetrahedron is one-third the distance from a vertex to the opposite face, times the area of the face.&lt;/p&gt;
&lt;p&gt;(a)Find a formula for the volume of a tetrahedron in terms of the coordination of its vertices &lt;em&gt;P&lt;/em&gt; ,&lt;em&gt;Q&lt;/em&gt; , &lt;em&gt;R&lt;/em&gt; and &lt;em&gt;S&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;(b)Find the volume of the tetrahedron whose vertices are &lt;em&gt;P&lt;/em&gt;(1,1,1), &lt;em&gt;Q&lt;/em&gt;(1,2,3), &lt;em&gt;R&lt;/em&gt;(1,1,2), and &lt;em&gt;S&lt;/em&gt;(3,-1,2).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;By (a),  a=(0,1,2), b=(0,0,1), c=(2,-2,1).&lt;/p&gt;
&lt;p&gt;So
$$
V=\frac{\left |
\begin{array}{ccc}
0 &amp;amp; 1 &amp;amp;  2 \\&lt;br&gt;
0 &amp;amp; 0 &amp;amp; 1 \\&lt;br&gt;
2 &amp;amp; -2 &amp;amp; 1 \\&lt;br&gt;
\end{array}\right |}{6}=\frac{1}{3}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose the tetrahedron in the figure has a trirectangular vertex &lt;em&gt;S&lt;/em&gt;. (This means that the three angles at &lt;em&gt;S&lt;/em&gt; are all right angles.) Let &lt;em&gt;A&lt;/em&gt;,&lt;em&gt;B&lt;/em&gt;,and &lt;em&gt;C&lt;/em&gt; be the areas of the three faces that meet at &lt;em&gt;S&lt;/em&gt;,and let &lt;em&gt;D&lt;/em&gt; be the area of the opposite face &lt;em&gt;PQR&lt;/em&gt;. Using the result Question 1, or otherwise, show that
$$
D^{2}=A^{2}+B^{2}+C^{2}
$$
(This is a three-dimensional version of the Pythagorean Theorem.)&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.12.4 - 四面體的幾何學</title>
      <link>https://teshenglin.github.io/post/2020_cal_s12p4_ch/</link>
      <pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s12p4_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Discovery Project in Sec.12.4, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s12p4&#34;&gt;The Geometry of a Tetrahedron&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如圖所示，四面體是一個擁有4個頂點(P,Q,R,S)和四個三角面的固體。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s12p4_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s12p4_1.png&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 $v_1, v_2, v_3$ 和 $v_4$ 為向量, 其長度分別和頂點 &lt;em&gt;P$, $Q$, $R$, $S&lt;/em&gt; 所對應到的面的面積相等，並且其方向與對應到的面垂直且向外。證明
$$
v_1+v_2+v_3+v_4=0
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四面體的體積&lt;em&gt;V&lt;/em&gt;是其一頂點到其對面的距離乘以該面的面積，再乘以三分之一倍。&lt;/p&gt;
&lt;p&gt;(a)找出一個計算四面體體積的公式，以頂點 &lt;em&gt;P&lt;/em&gt;，&lt;em&gt;Q&lt;/em&gt;，&lt;em&gt;R&lt;/em&gt;，&lt;em&gt;S&lt;/em&gt; 的座標表達。&lt;/p&gt;
&lt;p&gt;(b)算出四頂點分別為 &lt;em&gt;P&lt;/em&gt;(1,1,1)，&lt;em&gt;Q&lt;/em&gt;(1,2,3)，&lt;em&gt;R&lt;/em&gt;(1,1,2)，&lt;em&gt;S&lt;/em&gt;(3,-1,2) 的四面體的體積。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;(b)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 (a),  a=(0,1,2), b=(0,0,1), c=(2,-2,1).&lt;/p&gt;
&lt;p&gt;所以
$$
V=\frac{\left |
\begin{array}{ccc}
0 &amp;amp; 1 &amp;amp;  2 \\&lt;br&gt;
0 &amp;amp; 0 &amp;amp; 1 \\&lt;br&gt;
2 &amp;amp; -2 &amp;amp; 1 \\&lt;br&gt;
\end{array}\right |}{6}=\frac{1}{3}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假設如圖所示的四面體有一個三直角的頂點&lt;em&gt;S&lt;/em&gt;。(這表示三個在&lt;em&gt;S&lt;/em&gt;的角是直角。) 令&lt;em&gt;A&lt;/em&gt;，&lt;em&gt;B&lt;/em&gt;，&lt;em&gt;C&lt;/em&gt;為三個在&lt;em&gt;S&lt;/em&gt;相遇的面，且令&lt;em&gt;D&lt;/em&gt;為相對的面&lt;em&gt;PQR&lt;/em&gt;。用問題1的結論，或其他方法證明
$$
D^{2}=A^{2}+B^{2}+C^{2}
$$
(這是一個三維版本的勾股定理。)&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.1 - 建造較佳的雲霄飛車</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p1_ch/</link>
      <pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p1_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.1, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p1&#34;&gt;Building a better roller coaster&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設你被要求設計一架新的雲霄飛車的第一個上升與下降。在研究你最喜歡的雲霄飛車的圖片後，你決定新的雲霄飛車先以 0.8 的斜率上升然後再以 -1.6 的斜率下降。你決定以二次曲線 $y=f(x)=ax^2+bx+c$ 的一部份去連接上升與下降的直線 $y=L_1(x)$、$y=L_2(x)$，$x$和$f(x)$的單位為公尺。為了維持軌道的平滑性，因此軌道的方向上不能有明顯的變化，所以你要求兩條直線 $L_1$ 和 $L_2$ 應在交接點 $P$ 和 $Q$ 與二次曲線 $y=f(x)$ 相切（如圖）。你將起點定在 $P$ 以簡化方程式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/media%2Fa1a%2Fa1a173e3-a2b4-46ea-835c-dc7ca2977f57%2FphpNfXwqZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a) 假設 $P$ 和 $Q$ 之間的水平距離是 30 公尺。請寫出以$a$、$b$、和$c$構成的等式使得軌道與軌道之間的接點是平滑的。&lt;/p&gt;
&lt;p&gt;(b) 解出第(a)小題的 $a$、$b$、和 $c$，以找到$f(x)$的方程式。&lt;/p&gt;
&lt;p&gt;(c) 畫出$L_1$、$f$和 $L_2$，以圖形證實軌道之間的接點是平滑的。&lt;/p&gt;
&lt;p&gt;(d) 找出$P$和$Q$之間的垂直距離。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;下圖是這些函數的圖形：&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_1.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_1.jpg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;如上圖，$L_1$、$f$和$L_2$之間的接點是平滑的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;問題一的解答看似平滑，但坐起來感覺卻不怎麼平滑，因為分段定義的函數（$L_1(x)$ 當 $x&amp;lt;0$，$f(x)$ 當 $0\leq x\leq 30$，$L_2(x)$ 當 $x&amp;gt;30$）的二次微分並不連續。所以你決定將二次曲線 $q(x)=ax^2+bx+c$ 的使用範圍減少為 $3\leq x\leq 27$，並且將二次曲線和直線以兩條三次曲線相連接:&lt;/p&gt;
&lt;p&gt;$$
g(x)=kx^3+lx^2+mx+n \quad 0 \leq x&amp;lt;3
$$&lt;/p&gt;
&lt;p&gt;$$
h(x)=px^3+qx^2+rx+s \quad 27&amp;lt;x\leq 30
$$&lt;/p&gt;
&lt;p&gt;(a) 列出含有11個未知數的一系列的方程式，使得接點與接點之間的一次微分及二次微分皆是相同的。&lt;/p&gt;
&lt;p&gt;(b) 利用電腦計算系統解出第(a)小題的等式，以找出$q(x)$、$g(x)$和$h(x)$的方程式。&lt;/p&gt;
&lt;p&gt;(c) 畫出 $L_1$、 $g$、 $q$、 $h$和 $L_2$，並與問題一的第(c)小題的圖形相互比較。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;以下為更加平滑的軌道的圖形：















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

紅線是$g(x)$的圖形，藍線是$q(x)$的圖形，綠線是$h(x)$的圖形。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.6.5 - Where to Sit at the Movies</title>
      <link>https://teshenglin.github.io/post/2020_cal_s6p5/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s6p5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.6.5, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s6p5_ch&#34;&gt;電影院要坐哪?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A movie theater has a screen that is positioned $3$m off the floor and is $10$m high. The first row of seats is placed $3$m from the screen and the rows are set $1$m apart. The floor of the seating area is inclined at an angle of $\alpha=20^{\circ}$ above the horizontal and the distance up the incline that you sit is $x$. The theater has $21$ rows of seats, so $0 \leq x \leq 20$. Suppose you decide that the best place to sit is in the row where the angle $\theta$ subtended by the screen at your eyes is a maximum. Let&amp;rsquo;s also suppose that your eye are $1.2$m above the floor.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that $\theta = \cos^{-1}\left(\frac{a^2+b^2-100}{2ab}\right)$, where
$$
a^2 = (3+x\cos{\alpha})^2+(11.8-x\sin{\alpha})^2
$$
and
$$
b^2 = (3+x\cos{\alpha})^2+(x\sin{\alpha} - 1.8)^2
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use a graph of $\theta$ as a function of $x$ to estimate the value of $x$ that maximizes $\theta$. In which row should you sit? What is the viewing angle $\theta$ in this row? What is the angle $\theta$ subtended by the screen at your eyes?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/a0cuq0e.jpg&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/a0cuq0e.jpg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$\theta$&lt;/th&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$\theta$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0.781414&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;0.688473&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0.885175&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;0.654426&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0.932324&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;0.622381&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0.943356&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;0.592377&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0.932085&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;0.564380&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.907358&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0.538310&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0.874860&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;0.514061&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0.838292&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;0.491514&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;0.800070&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;0.470546&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0.761763&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;0.451038&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;0.724364&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The maximum of $\theta$ is 0.943356, you should sit at third row.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use your 
&lt;a href=&#34;https://www.derivative-calculator.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;computer algebra system&lt;/a&gt; to differentiate $\theta$ and find a numerical value for the root of the equation $\frac{d\theta}{dx} = 0$. Does this value confirm your result in Problem 2?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;According to the graph of $y = \frac{d\theta}{dx}$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/qet2iFc.png&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/qet2iFc.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;we found that there is a root at $\approx 2.84556$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use the graph of $\theta$ to estimate the average value of $\theta$ on the interval $0 \leq x \leq 20$. Then use your CAS to compute the average value. Compare with the maximum and minimum values of $\theta$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;average value:&lt;/p&gt;
&lt;p&gt;$$
avg = \frac{1}{20}\int_{0}^{20} \theta(x) dx \approx 0.71941
$$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/kSB09Fk.png&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/kSB09Fk.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;There exists three critical points at $x=0$, 2.84556 and 20, the maximum value is approximately 0.94336, the minimum value is approximately 0.45594&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.6.5 - 電影院要坐哪?</title>
      <link>https://teshenglin.github.io/post/2020_cal_s6p5_ch/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s6p5_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.6.5, Calculus by Stewart&lt;br&gt;
English version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s6p5&#34;&gt;Where to Sit at the Movies?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有家電影院的螢幕高10米且離地3公尺，第一排的位子距離螢幕3公尺且每排間隔1公尺，座位區的地板以與水平20度夾角向上傾斜，而你的座位在斜坡上的距離是 $x$。電影院有21排位子，因此 $0 \leq x \leq 20$。假設你認為最好的位子是眼睛與螢幕上下緣連線的夾角 $\theta$ 為最大值時，同時假設你的眼睛距離地面1.2公尺。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;試證明: $\theta = \cos^{-1}\left(\frac{a^2+b^2-100}{2ab}\right)$, 其中
$$
a^2 = (3+x\cos{\alpha})^2+(11.8-x\sin{\alpha})^2
$$
並且
$$
b^2 = (3+x\cos{\alpha})^2+(x\sin{\alpha} - 1.8)^2
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用 $\theta$ 與 $x$ 的函數圖形找出 $\theta$ 的最大值。你該坐在哪一排? 你在那一排的視角 $\theta$ 是幾度?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答:&lt;/strong&gt;&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/a0cuq0e.jpg&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/a0cuq0e.jpg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$\theta$&lt;/th&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$\theta$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0.781414&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;0.688473&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0.885175&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;0.654426&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0.932324&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;0.622381&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0.943356&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;0.592377&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0.932085&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;0.564380&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.907358&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0.538310&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0.874860&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;0.514061&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0.838292&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;0.491514&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;0.800070&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;0.470546&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0.761763&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;0.451038&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;0.724364&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$\theta$ 的最大值為 $0.943356$，你應該坐在第3排的位置。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用 
&lt;a href=&#34;https://www.derivative-calculator.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;computer algebra system&lt;/a&gt; 對 $\theta$ 微分，並嘗試找出 $\frac{d\theta}{dx} = 0$ 的解。答案是否和第二小題的答案吻合?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根據 $y = \frac{d\theta}{dx}$ 的圖形&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/qet2iFc.png&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/qet2iFc.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;我們發現在 $x\approx 2.84556$ 時有根。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use the graph of $\theta$ to estimate the average value of $\theta$ on the interval $0 \leq x \leq 20$. Then use your CAS to compute the average value. Compare with the maximum and minimum values of $\theta$.&lt;/p&gt;
&lt;p&gt;利用 $\theta$ 的圖形找出$\theta$在$0 \leq x \leq 20$區間的平均值。利用CAS計算$\theta$的平均值並與$\theta$的最大值與最小值比較。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平均值:&lt;/p&gt;
&lt;p&gt;$$
avg = \frac{1}{20}\int_{0}^{20} \theta(x) dx \approx 0.71941
$$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://i.imgur.com/kSB09Fk.png&#34; &gt;


  &lt;img src=&#34;https://i.imgur.com/kSB09Fk.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;臨界點(critical point)有三個位在 $x=0$, 2.84556 以及 20。最大值約為 0.94336，最小值約為 0.45594。&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>2020 Summer Research Internship</title>
      <link>https://teshenglin.github.io/courses/2020_summer_research/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0800</pubDate>
      <guid>https://teshenglin.github.io/courses/2020_summer_research/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;2020-暑期研究實習&#34;&gt;2020 暑期研究實習&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;海報















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/courses/figs/2020_summer.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/courses/figs/2020_summer.png&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;錄取名單&#34;&gt;錄取名單&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;林得勝老師
&lt;ul&gt;
&lt;li&gt;陳品翰, 張富婷, 李秉諺, 蔡柏毅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;游家牧老師
&lt;ul&gt;
&lt;li&gt;謝依玲, 何品萱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吳金典老師
&lt;ul&gt;
&lt;li&gt;胡嘉安, 周芷瑜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;鄧惠文老師
&lt;ul&gt;
&lt;li&gt;陳彥廷, 黃麒軒, 宋佩芩, 黃俞翎&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;康明軒老師
&lt;ul&gt;
&lt;li&gt;林彥廷, 林恩衍, 張育浚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;黃信元老師
&lt;ul&gt;
&lt;li&gt;許哲瑋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吳昌鴻老師
&lt;ul&gt;
&lt;li&gt;張詠瑄, 劉孟竹, 陳芊卉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;薛名成老師
&lt;ul&gt;
&lt;li&gt;吳諒濬, 彭宇楨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.11.11 - Radiation From The Stars</title>
      <link>https://teshenglin.github.io/post/2020_cal_s11p11/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s11p11/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.11.11, Calculus by Stewart&lt;br&gt;
Chinese version 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s11p11_ch&#34;&gt;恆星的輻射&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Any object emits radiation when heated. A &lt;strong&gt;blackbody&lt;/strong&gt; is a system that absorbs all the radiation that falls on it. For instance, a matte black surface or a large cavity with a small hole in its wall (like a blastfurnace) is a blackbody and emits blackbody radiation. Even the radiation from the sun is close to being a blackbody radiation.&lt;/p&gt;
&lt;p&gt;Proposed in the late 19th century, the Rayleigh-Jeans Law expresses the energy density of blackbody radiation of wavelength $\lambda$ as
$$
f(\lambda)=\frac{8 \pi kT}{\lambda^4}
$$
where $\lambda$ is measured in meters, $T$ is the temperature in kelvins (K) and $k=$ Boltzmann&amp;rsquo;s constant $=1.3807\times 10^{-23}$J/K.&lt;/p&gt;
&lt;p&gt;The Rayleigh-Jeans Law agrees with experimental measurements for long wavelengths but disagrees drastically for short wavelengths. [The law predicts that $f(\lambda)\rightarrow \infty$as $\lambda \to 0^+$ but experiments have shown that $f(\lambda)\to0$.] This fact is known as the &lt;em&gt;ultraviolet catastrophe&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In 1990 Max Planck found a better model (known now as Planck&amp;rsquo;s Law) for blackbody radiation:
$$
f(\lambda)= \frac{8 \pi hc \lambda^{-5}}{e^{hc/(\lambda kT)}-1}
$$
and&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$h=$ Planck&amp;rsquo;s constant $=6.6262\times 10^{-34}$ J$\cdot$s&lt;/li&gt;
&lt;li&gt;$c=$ speed of light $=2.997925\times10^8$m/s&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use l&amp;rsquo;Hospital&amp;rsquo;s Rule to show that&lt;/p&gt;
&lt;p&gt;$$
\lim_{\lambda\to0^+}f(\lambda)=0
$$
and
$$
\lim_{\lambda\to\infty} f(\lambda) = 0
$$&lt;/p&gt;
&lt;p&gt;for Planck&amp;rsquo;s Law. So this law models blackbody radiation better than the Rayleigh-Jeans Law for short wavelengths.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use a Taylor polynomial to show that, for large wavelengths, Planck&amp;rsquo;s Law gives approximately the same values as the Rayleigh-Jeans Law.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Graph $f$ as given by both laws on the same screen and comment on the similarities and differences. Use $T=5700$K (the temperature of the Sun ). (You may want to change from meters to the more convenient unit of micrometers: $1\mu$m $=10^{-6}$m.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To convert to $\mu$m, we substitute $\lambda/10^6$ for $\lambda$ in both laws. For large $\lambda$ (left), the graphs of two laws are similar. For small $\lambda$ (right), the graphs of two laws are very different.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use your graph in Problem 3 to estimate the value of $\lambda$ for which $f(\lambda)$ is a maximum under Planck&amp;rsquo;s Law.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;From the graph in Problem 3, $f(\lambda)$ has a maximum under Planck&amp;rsquo;s Law at $\lambda\approx0.51 \mu$m.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 5:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Investigate how the graph of $f$ changes as $T$ varies. (Use Planck&amp;rsquo;s Law.) In particular, graph $f$ for the stars&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Betelgeuse ($T=3400$K)&lt;/li&gt;
&lt;li&gt;Procyon ($T=6400$K)&lt;/li&gt;
&lt;li&gt;Sirius ($T=9200$K)&lt;/li&gt;
&lt;li&gt;Sun&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How does the total radiation emitted (the area under the curve) vary with $T$ ? Use the graph to comment on why Sirius is known as a blue star and Betelgeuse as a red star.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As $T$ gets larger, the total area under the curve increase, so we can consider that the hotter the star is, the more energy it emits. Also as $T$ increases, the maximum $\lambda$-value decreases, so the higher the temperature, the shorter the peak wavelength and the average wavelength of light emitted. This is why Sirius is a blue star and Betelgeuse is a red star. And most of its light is of a short wavelength. That is, a higher frequency, toward the blue end of the spectrum, whereas most of Betelgeuse&amp;rsquo;s light is of a lower frequency, toward the red end of the spectrum.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.11.11 - 恆星的輻射</title>
      <link>https://teshenglin.github.io/post/2020_cal_s11p11_ch/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s11p11_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.11.11, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s11p11&#34;&gt;Radiation From The Stars&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何物件在被加熱時會散發輻射. 而 &lt;strong&gt;黑體&lt;/strong&gt; 則是一個會吸收所有經過他的輻射的一個系統. 舉例來說, 一個表面黑色且沒有光澤或著有一個大的空腔但只有一個小孔洞在牆壁上(像是煉鐵的高爐)可以視為一個黑體, 而他們會散發黑體輻射. 甚至從太陽散發出來的輻射也可以視作為一種黑體輻射.&lt;/p&gt;
&lt;p&gt;19世紀時, 瑞立-金斯定律(Rayleigh-Jeans Law)被提出來, 用來描述黑體輻射的能量密度和波長 $\lambda$ 的關系:
$$
f(\lambda)=\frac{8 \pi kT}{\lambda^4}
$$
其中 $\lambda$ 的單位是公尺, $T$ 是溫度單位是 $K$(克氏溫標), $k$ 是波茲曼常數(Boltzmann&amp;rsquo;s constant) $= 1.3807\times 10^{-34} (J/K)$.&lt;/p&gt;
&lt;p&gt;瑞立-金斯定律與實驗測量結果相比, 在長波長是吻合的, 但在短波長時卻相差甚遠. (這個定理預測 $f(\lambda)\rightarrow \infty$ as $\lambda \to 0^+$ 但實驗結果卻顯示 $f(\lambda)\to 0$.) 這個結果後來被稱為 &lt;em&gt;紫外災變&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;馬克思.普朗克 (Max Planck) 在 1990 時為黑體輻射找到一個更好的模型(現在被稱為普朗克定律):
$$
f(\lambda)= \frac{8 \pi hc \lambda^{-5}}{e^{hc/(\lambda kT)}-1}
$$
其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$h$ 是普朗克常數(Plancks&amp;rsquo;s constant) = $6.626\times 10^{-34} (J\cdot s)$&lt;/li&gt;
&lt;li&gt;$c$ 是光速 $= 2.997925\times 10^8 (m/s)$&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用羅畢達法則 (l&amp;rsquo;Hospital&amp;rsquo;s Rule) 說明普朗克定律&lt;/p&gt;
&lt;p&gt;$$
\lim_{\lambda\to 0^+}f(\lambda) = 0
$$
and
$$
\lim_{\lambda\to\infty} f(\lambda) = 0
$$
此結果說明為何對短波長的黑體輻射普朗克的模型比瑞立-金斯的定理更好.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用泰勒展開式(Taylor polynomial) 說明在長波長時,普朗克定律 和 瑞立-金斯定理的結果會大致相同.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分別用兩個函式在同一個座標平面上劃出圖形, 並且說明相同和相異之處. $T$  用 5700K (太陽表面溫度) 帶入. (為了更方便計算 可以把長度單位從公尺換成微米: $1\mu$m = $10^{-6}$ m.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;為了轉換成微米,我們把 $\lambda$ 用 $\frac{\lambda}{10^6}$ 帶入兩個函式. 在 $\lambda$ 很大時(圖左),兩個定理的結果很類似,然而在 $\lambda$ 很小時(圖右),結果差異甚大.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用第三題畫出來的圖去估算普朗克定律中 $f(\lambda)$ 為最大值時  $\lambda$ 的長度.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從第三題的圖表得知, 普朗克定律中$f(\lambda)$ 在 $\lambda$ $\approx$ $0.51\mu$m 有最大值.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 5：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;觀察下列四個恆星在普朗克定律的圖形 $f$ 如何隨著 $T$ 的變動&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;參宿四 (Betelgeuse) T = 3400K&lt;/li&gt;
&lt;li&gt;南河三 (Procyon) T = 6400K&lt;/li&gt;
&lt;li&gt;天狼星 (Sirius) T = 9200K&lt;/li&gt;
&lt;li&gt;太陽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;發散的總輻射量(曲線下的面積)式怎麼隨著溫度變化的? 用圖來說明為何天狼星是藍色而參宿四是紅色.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隨著溫度升高，曲線下的面積也隨之增加，所以可以推斷出當恆星溫度越高，發散的能量越多。且當溫度升高時，曲線最大值的$\lambda$值會減少。因此溫度越高，恆星散發的光的峰值與平均波長越短。當光的波長越短，頻率越高。當頻率高時，光在光譜上會接近藍端。而參宿四的頻率較低，較接近紅端。這就是為什麼天狼星是藍星而參宿是紅星。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_1.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s11p11_1.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.8.3 - Complementary Coffee Cups</title>
      <link>https://teshenglin.github.io/post/2020_cal_s8p3_ch/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s8p3_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.8.3, Calculus by Stewart
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s8p3&#34;&gt;Complementary Coffee Cups&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設你選擇了兩種形狀的咖啡杯，一種向外彎曲，另一種向內彎曲，你會注意到它們具有相同的高度，並且形狀可以緊密地貼合在一起。你想知道哪個杯子可以容納更多咖啡。當然，你可以將一個杯子裝滿水，然後倒入另一個杯子中來測量容量。但是，作為一名微積分學生，你決定採用一種更數學的方法：忽略手柄，會發現兩個杯子的表面可由旋轉而得，因此可以旋轉體計算咖啡杯之體積。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/media%2Ff10%2Ff10af759-2600-468a-af6c-20a3854ee028%2FphpbqXd4u.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假定杯子的高度為 $h$，杯子A的形狀可由 $x=f(y)$ 對 $y$ 軸旋轉而得， 而杯子B則是由同一個曲線對 $x=k$ 旋轉而得。 求$k$使得兩個杯子可裝的咖啡量一樣多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
k=\frac{2\int_0^{h}f(y)dy}{h}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;請問問題1的結果與圖中的 $A_1$ and $A_2$ 有何關聯?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;當杯子A之容積與杯子B相等時，$A_1$ 的面積與 $A_2$相等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Pappus&amp;rsquo;s 定理解釋問題1和問題2之結果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pappus&amp;rsquo;s Theorem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使$R$為一個平面區域，在這個區域外有同一平面上的一條直線$I$。若$R$以$I$為軸旋轉時，產生的旋轉體體積為$R$的面積$A$和區域重心的所經過的路徑長$d$的乘積。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.9.3.2 - Which is faster, going up or going down?</title>
      <link>https://teshenglin.github.io/post/2020_cal_s9p3_2/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s9p3_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.9.3, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s9p3_2_ch&#34;&gt;上升快，還是下降快?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Suppose you throw a ball into the air. Do you think it takes longer to reach its maximum height or to fall back to earth from its maximum height? We will solve the problem in this project, but before getting started, think about that situation and make a guess based on your physical intuition.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A ball with mass $m$ is projected vertically upward from the earth’s surface with a positive initial velocity $v_0$. We assume the forces acting on the ball are the force of gravity and a retarding force of air resistance with direction opposite to the direction of motion and with magnitude $p|v(t)|$, where $p$ is a positive constant and $v(t)$ is the velocity of the ball at time $t$. In both the ascent and the descent, the total force acting on the ball is $-pv-mg$. [During ascent, $v(t)$ is positive and the resistance acts downward; during descent, $v(t)$ is negative and the resistance acts upward.] So, by Newton’s Second Law, the equation of motion is
$$
mv&#39;=-pv-mg
$$
Solve this differential equation to show that the velocity is
$$
v(t)=(v_0+\frac{mg}{p})e^{-pt/m}-\frac{mg}{p}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that the height of the ball, until it hits the ground, is
$$
y(t)=(v_0+\frac{mg}{p})\frac{m}{p}(1-e^{-pt/m})-\frac{mgt}{p}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Let $t_1$ be the time that the ball takes to reach its maximum height. Show that
$$
t_1=\frac{m}{p}ln(\frac{mg+pv_0}{mg})
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find this time for a ball with mass 1 kg and initial velocity 20 m/s. Assume the air resistance is $\frac{1}{10}$ of the speed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Answer：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;with the ball with mass $m=1kg$, initial velocity $v_0=20m/s$, gravity $g=9.8m/s$, and air resistance $p=\frac{1}{10}$.
$$
t_1=\frac{1}{\frac{1}{10}}ln\left({\frac{1\times9.8+\frac{1}{10}\times20}{1\times9.8}}\right)=‭1.85717‬s
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let $t_2$ be the time at which the ball falls back to earth. For the particular ball in Problem 3, estimate $t_2$ by using a graph of the height function $y(t)$. Which is faster, going up or coming down?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/C4svFLG.png&#34; alt=&#34;Imgur&#34;&gt;&lt;/p&gt;
&lt;p&gt;because the time of the ball going up is shorter than the ball coming down, the speed of the ball going up is faster than the coming down.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 5：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In general, it’s not easy to find $t_2$ because it’s impossible to solve the equation $y(t)=0$ explicitly. We can, however, use an indirect method to determine whether ascent or descent is faster: we determine whether $y(2t_1)$ is positive or negative.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Show that
$$
y(2t_1)=\frac{m^2g}{p^2}(x-\frac{1}{x}-2\ln{x})
$$
where $x=e^{pt_1/m}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then show that $x &amp;gt; 1$ and the function
$$
f(x)=x-\frac{1}{x}-2\ln{x}
$$
is increasing for $x &amp;gt; 1$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use this result to decide whether $y(2t_1)$ is positive or negative. What can you conclude? Is ascent or descent faster?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Answer：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.9.3.2 - 上升快，還是下降快?</title>
      <link>https://teshenglin.github.io/post/2020_cal_s9p3_2_ch/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s9p3_2_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.9.3, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s9p3_2&#34;&gt;Which is faster, going up or going down?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設你在空氣中將一顆球向上拋。你認為球從地表到最高高度和從最高處落回地面哪一個所耗的時間較長? 我們將在這個研究中探討這個問題，但，在我們開始前，先思考整個情況，接著根據你的物理直覺做出猜想。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一顆質量為 $m$ 的球以初速為 $v_0$ 的速度鉛直上拋，我們假設作用在球上的力為地球給球的重力和相反於運動方向的空氣阻力 $p|v(t)|$ ， $p$ 為一個正的常數， $v(t)$ 為球在時間為 $t$ 時的速度。綜合正向和負向的力，球所受到的總合力為 $-pv-mg$，(在球上升階段，$v(t)$ 為正而阻力為向下；在球下降時， $v(t)$ 為負且阻力向上)。因此，根據牛頓第二運動定律，我們可得知移動的等式為
$$
mv&#39;=-pv-mg
$$&lt;/p&gt;
&lt;p&gt;解出此微分方程來說明速度為
$$
v(t)=(v_0+\frac{mg}{p})e^{-pt/m}-\frac{mg}{p}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解出直到球落地之前的高度為
$$
y(t)=(v_0+\frac{mg}{p})\frac{m}{p}(1-e^{-pt/m})-\frac{mgt}{p}
$$&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;設 $t_1$ 為球升至最高點所耗的時間。證明
$$
t_1=\frac{m}{p}\ln\left(\frac{mg+pv_0}{mg}\right)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一顆質量為1公斤的球，向上初速為 $20$(公尺/秒)。假設空氣阻力為速度的$\frac{1}{10}$。解出此狀況下的 $t_1$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;當球的質量 $m=1kg$，向上的速度 $v_0=20m/s$，重力 $g=9.8m/s$，空氣阻力 $p=\frac{1}{10}$
$$
t_1=\frac{1}{\frac{1}{10}}ln\left({\frac{1\times9.8+\frac{1}{10}\times20}{1\times9.8}}\right)=‭1.85717‬s
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;當 $t_2$ 為球落回最低點的時間。特別指在問題3中的情況中的球，使用高度函數 $y(t)$ 的圖形計算。哪一個情況的時間較短，上升還是落下?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/C4svFLG.png&#34; alt=&#34;Imgur&#34;&gt;&lt;/p&gt;
&lt;p&gt;因為上升所耗的時間比下降的時間短，因此上升比下降快。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 5：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般來說，找出 $t_2$ 是不容易的。因為要明確地解出等式 $y(t)=0$ 是不可能的。然而，我們可以使用一種非直接的方法來計算到底上升還是下降哪個較快。我們計算 $y(2t_1)$ 是正是負。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;證明
$$
y(2t_1)=\frac{m^2g}{p^2}(x-\frac{1}{x}-2\ln{x})
$$
其中 $x=e^{pt_1/m}$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再證明當 $x &amp;gt; 1$ 時 $f(x)$
$$
f(x)=x-\frac{1}{x}-2\ln{x}
$$
為遞增函數。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用這項結果來決定 $y(2t_1)$ 何時為正，何時為負。你能推斷出甚麼結果?上升還是下降比較快?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.4.1 - 彩虹的微積分學</title>
      <link>https://teshenglin.github.io/post/2020_cal_s4p1_ch/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s4p1_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.4.1, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s4p1&#34;&gt;The Calculus of ranbows&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當陽光照射到半空中的雨滴，光線被散射就會形成彩虹。彩虹自古以來就被人類著迷著，且早在亞里士多德時代以來激發許多人們進行科學的探討，並嘗試找到解釋。在這份專題裡，我們使用笛卡爾和牛頓的思想來解釋彩虹的形狀、位置和顏色。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面這張圖顯示了一道光束從 A 點進入球形雨滴。有一些光被反射，但線段AB 表示了一些沒有被反射，而穿入雨滴的光線軌跡。這裡要注意的是，這道光線是朝法線AO 折射的，而實際上，斯涅爾定律提及 $\sin\alpha = k\sin\beta$ ，其中 $\alpha$ 是入射角，$\beta$ 是折射角，而 $k\approx\frac{4}{3}$ 是水的折射率。在 B 點，有一些光線穿過水滴，然後折射進入空氣，但依然有部分被反射，如線段BC所示。 （入射角等於反射角）當光束到達 C 點時，它的一部份會被反射，但讓我們更感興趣的是從 C 點離開雨滴部分（要注意它是從法線折射出去的）。偏差角 $D(\alpha)$ 是光束在此三階段過程中經歷的順時針旋轉量。因此，
$$
D(\alpha ) = (\alpha - \beta ) + (\pi - 2\beta  ) + (\alpha - \beta) = \pi  + 2\alpha  - 4\beta.
$$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_01.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_01.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;證明偏差角在 $\alpha\approx 59.4^{\circ}$ 時會有最小值 $\alpha\approx 59.4^{\circ}$。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;最小偏差角的意義是當$\alpha\approx 59.4^{\circ}$ 時，我們知道 $D’(\alpha)\approx 0$，則 $\frac{\Delta D}{\Delta \alpha}\approx 0$ 。這代表當很多光束在 $\alpha\approx 59.4^{\circ}$ 時偏差大約相同，而正是因為接近最小偏差方向的光線集中產生主彩虹的亮度。下面這張圖顯示了從觀察者到彩虹最高點的仰角為 $180^{\circ}- 138^{\circ} = 42^{\circ}$（這個角度就叫做彩虹角）。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_02.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_02.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;問題二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;問題1解釋了主彩虹的位置，那我們要如何解釋顏色呢？陽光的波長範圍從紅色到橙色，黃色，綠色，藍色，靛藍和紫色。正如牛頓在1666年的棱鏡實驗中發現的那樣，每種顏色的折射率都不同（這種效果稱為色散）。紅光的折射率為 $k \approx 1.3318$，紫光的折射率為 $k\approx 1.3435$。透過對的這些值 $k$ 重複問題1的計算，證明紅色光道的彩虹角是 $42.3^{\circ}$ 而紫色光道的彩虹角是 $40.6^{\circ}$ 。因此，彩虹實際上是由對應於這七個顏色的七個單獨的光道組成的。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題三：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或許你曾經看過主彩虹上較暗的次彩虹。這是由於光線進入雨滴並在A處折射、反射兩次（在B和C處）以及在D處離開雨滴而折射的那部分光束所致（如下圖）。這次偏差角$D(\alpha)$是射線在此四階段過程中經歷的逆時針旋轉的總量。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_03.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_03.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;證明 $D(\alpha ) = 2\alpha  - 6\beta  + 2\pi$ 和 $D(\alpha)$ 在 $\cos\alpha = \sqrt\frac{k^2-1}{8}$ 時有最小值。&lt;/p&gt;
&lt;p&gt;用 $k=\frac{4}{3}$ ，表示最小偏差角大約等於 $129^{\circ}$ 且次彩虹的彩虹角大約等於$51^{\circ}$ ，如下圖所示。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_04.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_04.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題四：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;證明次彩虹中的顏色以與主要彩虹中的顏色相反的順序顯現。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.4.1 - The Calculus of ranbows</title>
      <link>https://teshenglin.github.io/post/2020_cal_s4p1/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s4p1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.4.1, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s4p1_ch&#34;&gt;彩虹的微積分學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rainbows are created when raindrops scatter sunlight. They have fascinated mankind since ancient times and have inspired attempts at scientific explanation since the time of Aristotle. In this project we use the ideas of Descartes and Newton to explain the shape, location, and colors of rainbows.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The figure shows a ray of sunlight entering spherical raindrop at A. Some of the light is reflected, but the line AB shows the path of the part that enters the drop. Notice that the light is refracted toward the normal line AO and in fact Snell&amp;quot;s Law says that $\sin\alpha=k \sin\beta$, where $\alpha$ is the angle of incidence, $\beta$ is the angle of refraction, and $k\approx\frac{4}{3}$ is the index of refraction for water. At B some of the light passes through the drop and is refracted into the air, but the line BC shows the part that is reflected. (The angle of incidence equals the angle of reflection.) When the ray reaches C, part of it is reflected, but for the time being we are more interested in the part that leaves the raindrop at C.(Notice that it is refracted away from the normal line.) The  &lt;em&gt;angle of deviation&lt;/em&gt; $D(\alpha )$ is the amount of clockwise rotation that the ray has undergone during this three-stage process. Thus
​$$
D(\alpha ) = (\alpha - \beta ) + (\pi - 2\beta  ) + (\alpha - \beta) = \pi  + 2\alpha  - 4\beta.
$$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_01.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_01.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;Show that the minimum value of deviation is $D(\alpha)\approx 138^{\circ}$; and occurs when $\alpha\approx 59.4^{\circ}$.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;The significance of the minimum deviation is that when $\alpha\approx 59.4^{\circ}$ we have $D&#39;(\alpha)\approx 0$, so $\frac{\Delta D}{\Delta \alpha}\approx 0.$ This means that many  rays with $\alpha\approx 59.4^{\circ}$ become deviated by approximately the same amount. It it the &lt;em&gt;concentration&lt;/em&gt; of rays coming from near the direction of minimum deviation that creates the brightness of the primary rainbow. The figure at the left shows that the angle of elevation from the observer up to the highest point on the rainbow is $180^{\circ}- 138^{\circ} = 42^{\circ}$. (This angle is called the &lt;em&gt;rainbow angle&lt;/em&gt; .)&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_02.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_02.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Problem 1 explains the location of the primary rainbow, but how do we explain the colors? Sunlight comprises a range of wavelengths, from the red range through orange, yellow, green, blue, indigo, and violet. As Newton discovered in his prism experiments of 1666, the index of refraction is different for each color, (The effect is called &lt;em&gt;dispersion&lt;/em&gt;.) For red light the refractive index $k \approx 1.3318$,  whereas for violet light it is $k\approx 1.3435$. By repeating the calculation of Problem 1 for these values of $k$, show that the rainbow angle is about $42.3^{\circ}$ for red bow and $40.6^{\circ}$ for the violet bow. So the rainbow really consists of seven individual bows corresponding to the seven colors.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Perhaps you have seen a fainter secondary rainbow above the primary bow. That results from the part of a ray that enters a raindrop and is refracted at A, reflected twice (at B and C), and refracted as it leaves the drop at D (see the figure at the left). This time the deviation angle $D(\alpha)$ is the total amount of counterclockwise rotation that the ray undergoes in this four-stage process.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_03.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_03.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;Show that $D(\alpha ) = 2\alpha  - 6\beta  + 2\pi$ and $D(\alpha)$ has a minimum value when $\cos\alpha = \sqrt\frac{k^2-1}{8}$.&lt;/p&gt;
&lt;p&gt;Taking $k=\frac{4}{3}$, show that the minimum deviation is about $129^{\circ}$ and so the rainbow angle for the secondary rainbow is about $51^{\circ}$, as shown in the figure below.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_04.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_04.jpg&#34; alt=&#34;&#34; width=&#34;300px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Show that the colors in the secondary rainbow appear in the opposite order from those in the primary rainbow.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.4.7 - 飛機和鳥：能量最小化</title>
      <link>https://teshenglin.github.io/post/2020_cal_s4p7_2_ch/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s4p7_2_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project 2 in Sec.4.7, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_cal_s4p7_2&#34;&gt;Planes and birds: Minimizing energy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像雀科這樣的小鳥滑翔時，會在拍打翅膀和保持翅膀折疊之間進行交替。在這裡，我們觀察這種現象並試著找出鳥類拍動翅膀的頻率。而其中的一些原理與固定翼飛機相同，因此我們先依照飛機的速度去考慮其所需的功率及能量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/study/ad0/ad0cd741-aa85-4256-a058-b49a8ef42198/715030-4.7-4IAP21.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt; 在速度為 $v$ 時，推動飛機前進所需的功率為
$$
P = Av^3 + \frac{BL^2}{v}
$$
其中 $A$ 和 $B$ 是特定飛機的參數，恆為正，$L$ 是升力，即為支撐飛機重量的向上力。 找出使其所需功率最小的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
v_P = \sqrt[4]{\frac{BL^2}{3A}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt;	在問題 1 中找到的速度可將功率降至最低，但較快的速度可能會消耗較少的燃料。推動飛機每單位距離所需的能量為 $E=P/v$， 在什麼速度下能使能量最小？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
v_E = \sqrt[4]{\frac{BL^2}{A}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt; 最小能量的速度比最小功率的速度快多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
\frac{v_E}{v_P} = \sqrt[4]{3}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4:&lt;/strong&gt;  在問題一的方程式應用於鳥類飛行時，我們將 $Av^3$ 分為兩部分：代表鳥類身體的 $A_bv^3$ 和代表翅膀的 $A_wv^3$。設 $x$ 為拍打模式佔飛行時間的部分，如果 $m$ 是鳥的質量且所有升力發生在拍打過程中，那麼升力即為 $mg/x$，因此在拍打過程中所需要的功率是&lt;/p&gt;
&lt;p&gt;$$
P_f = (A_b+A_w)v^3 + \frac{B(mg/x)^2}{v}
$$&lt;/p&gt;
&lt;p&gt;而折起翅膀時的力量為$P_o=A_bv^3$，試找出整個飛行週期的平均功率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
P_a = x P_f + (1-x) P_o = A_b v^3 + A_w v^3 x + \frac{B m^2 g^2}{xv}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 5:&lt;/strong&gt;  在最小平均功率下$x$的值是多少？ 如果鳥飛得慢，你能得出什麼結論？ 如果這隻鳥飛得越來越快，你能得出什麼結論？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
x = \frac{mg}{v^2}\sqrt{\frac{B}{A_w}}
$$&lt;/p&gt;
&lt;p&gt;可以看出$x$與$v^2$成反比，所以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鳥飛的慢,拍翅時間佔總體飛行時間上升&lt;/li&gt;
&lt;li&gt;鳥飛的快,滑翔時間佔總體飛行時間上升&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 6:&lt;/strong&gt;  一個週期的平均能量為 $E_a=P_a/v$. 試問 $x$ 的值為多少可以使$E_a$最小？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
x = \frac{mg}{v^2}\sqrt{\frac{B}{A_w}}
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.10 - Taylor polynomials</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p10/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p10/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Laboratory Project in Sec.3.10, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p10_ch&#34;&gt;泰勒級數&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The tangent line approximation $L(x)$ is the best first-degree (linear) approximation to $f(x)$ near $x=a$ because $f(x)$ and $L(x)$ have the same rate of change (derivative) at $x=a$. For a better approximation than a linear one, let&amp;rsquo;s try a second-degree (quadratic) approximation $P(x)$. In other words, we approximate a curve by a parabola instead of a straight line. To make sure that the approximation is a good one, we stipulate the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$P$ and $f$ should have the same value at $a$. ($P(a)=f(a)$)&lt;/li&gt;
&lt;li&gt;$P$ and $f$ should have the same rate of change at $a$. ($P&#39;(a)=f&#39;(a)$)&lt;/li&gt;
&lt;li&gt;The slopes of $P$ and $f$ should change at the same rate at $a$. ($P&#39;&#39;(a)=f&#39;&#39;(a)$)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1：&lt;/strong&gt; Find the quadratic approximation $P(x)=A+Bx+Cx^{2}$ to the function $f(x)=cosx$ that satisfies conditions (i), (ii),and (iii) with $a=0$ . Graph $P$, $f$ and the linear approximation $L(x)=1$ on a common screen. Comment on how well the functions $P$ and $L$ approximate $f$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$P(x)=1-\frac{1}{2}x^{2}$, and the graph shows:&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_01.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;According to the graph, when $x\rightarrow a$, $|P(x)-f(x)|$ &amp;laquo;$|L(x)-f(x)|$, therefore quadratic approximation $P(x)$ serves as a better approximation than linear approximation $L(x)$ to $f(x)$ near $x=0$ .&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2：&lt;/strong&gt; Determine the values of $x$ for which the quadratic approximation $f(x)\approx P(x)$ in Problem 1 is accurate to within $0.1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;We draw the graph of $g(x),P(x),h(x)$:&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_02.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;According to the graph, when $-1.26\leq x\leq 1.26$, it satisfies $|P(x)-f(x)|\leq 0.1$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3：&lt;/strong&gt; To approximate a function $f$ by a quadratic function $P$ near a number $a$, it is best to write $P$ in the form
$$
P(x)=A+B(x-a)+C(x-a)^{2}。
$$
Show that the quadratic function that satisfies conditions (i), (ii), and (iii) is
$$
P(x)=f(a)+f&#39;(a)(x-a)+\frac{1}{2} f&#39;&#39;(a)(x-a)^{2}。
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
P(x)=f(a)+f&#39;(a)(x-a)+\frac{1}{2} f&#39;&#39;(a)(x-a)^{2}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt; Find the quadratic approximation to $F(x)=\sqrt{x+3}\quad$ near $a=1$. Graph $f$, the quadratic approximation, and the linear approximation from Example 3.10.2 on a common screen. What do you conclude?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;We draw the graph of $f(x),P(x)$ and the linear approximation from Example 3.10.2：&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_03.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;According to the graph, when $x\rightarrow 1$, quadratic approximation $P(x)$ serves as a better approximation than linear approximation $L(x)$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 5:&lt;/strong&gt; Instead of being satisfied with a linear or quadratic approximation to $f(x)$ near $x=a$, let&amp;rsquo;s try to find better approximations with higher-degree polynomials. We look for an nth-degree polynomial
$$
T_{n}(x)=c_{0}+c_{1}(x-a)+c_{2}(x-a)^{2}+c_{3}(x-a)^{3}+&amp;hellip;+c_{n}(x-a)^{n}，
$$
which satisfies when $x=a$,
$$
T_{n}^{(k)}(a)=f^{(k)}(a), \quad k=1, \cdots, n。
$$
Show that these conditions are satisfied if $c_{k}=\frac{f^{(k)}(a)}{k!}$.&lt;/p&gt;
&lt;p&gt;The resulting polynomial:
$$
T_{n}(x)=f(a)+f&#39;(a)(x-a)+\frac{f&#39;&#39;(a)}{2!} (x-a)^{2}+&amp;hellip;+\frac{f^{(n)}(a)}{n!}(x-a)^{n}。
$$
is called the nth-degree Taylor polynomial of $f$ centered at $a$.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 6:&lt;/strong&gt; Find the 8th-degree Taylor polynomial centered at $a=0$ for the function $f(x)=\cos x$. Graph $f$ together with the Taylor polynomials $T_{2},T_{4},T_{6},T_{8}$ in the viewing rectangle $x=[-5,5]$ by $y=[-1.4,1.4]$  and comment how well they approximate $f$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;We draw the graph of$f$ and $T_{2},T_{4},T_{6},T_{8}$, and the rectangle $x=[-5,5]$ by $y=[-1.4,1.4]$&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_04.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_04.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;According to the graph, at $a=0$, when the degree of approximation $T$ goes higher,  the approximation is more similar to $f$ , and the interval for approximation becomes larger, that is, within four approximation $T$, function $T_{8}$  serves as the best approximation for $f$ at $a=0$.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.8.3 - Complementary Coffee Cups</title>
      <link>https://teshenglin.github.io/post/2020_cal_s8p3/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s8p3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.8.3, Calculus by Stewart
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s8p3_ch&#34;&gt;Complementary Coffee Cups&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Suppose you have a choice of two coffee cups of the type shown, one that bends outward and one inward, and you notice that they have the same height and their shapes fit together snugly. You wonder which cup holds more coffee. Of corse you could fill one cup with water and pour it into the other one but, being a calculus student, you decide on a more mathematical approach. Ignoring the handles, you observe that both cups are surfaces of revolution, so you can think of the coffee as a volume of revolution.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/media%2Ff10%2Ff10af759-2600-468a-af6c-20a3854ee028%2FphpbqXd4u.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose the cups have height $h$, cup A is formed by rotating the curve $x=f(y)$ about the $y$-axis, and cup B is formed by rotating the same curve about the $x=k$. Find the value of $k$ such that two cups hold the same amount of coffee.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
k=\frac{2\int_0^{h}f(y)dy}{h}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What does your result from Problem 1 say about the areas $A_1$ and $A_2$ shown in the figure?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;when Cup A&amp;rsquo;s volume equals Cup B&amp;rsquo;s, the area of $A_1$ is the same as $A_2$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use Pappus&amp;rsquo;s Theorem to explain your result in Problem 1 and 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pappus&amp;rsquo;s Theorem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let $R$ be a plane region that lies entirely on one side of a line $l$ in the plane. If $R$ is rotated about $l$, then the volume of the resulting solid is the product of the area $A$ of $R$ and the distance $d$ travled by the centroid of $R$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.1 - Building a better roller coaster</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p1/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.1, Calculus by Stewart
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p1_ch&#34;&gt;建造較佳的雲霄飛車&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Suppose you are asked to design the first ascent and drop for a new roller coaster. By studying the photographs of your favorite coasters, you decide to make the slope of the ascent $0.8$ and the slope of the drops $-1.6$. You decide to connect these two straight stretches $y=L_1(x)$ and $y=L_2(x)$ with part of a parabola $y=f(x) = ax^2+bx+c$, where $x$ and $f(x)$ are measured in meters. For the track to be smooth there can&amp;rsquo;t be abrupt changes in direction, so you want the linear segments $L_1$ and $L_2$ to be tangent to the parabola at the points $P$ and $Q$. To simplify the equations, you decide to place the origin at $P$.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/media%2Fa1a%2Fa1a173e3-a2b4-46ea-835c-dc7ca2977f57%2FphpNfXwqZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a) Suppose the horizontal distance between $P$ and $Q$ is 30 m. Write equations in $a$, $b$, and $c$ that will ensure that the track is smooth at the transition points.&lt;/p&gt;
&lt;p&gt;(b) Solve the equations in part(a) for $a$, $b$, and $c$ to find a formula for $f(x)$.&lt;/p&gt;
&lt;p&gt;(c) Plot $L_1$, $f$, and $L_2$ to verify graphically that the transitions are smooth.&lt;/p&gt;
&lt;p&gt;(d) Find the difference in elevation between $P$ and $Q$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Below is the graph of these formula:















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_1.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_1.jpg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

As you can see, the transition among $L_1$, $f$, and $L_2$ is smooth.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The solution in Problem 1 might look smooth, but it might not feel smooth because the piecewise defined function (consisting of $L_1(x)$ for $x&amp;lt;0$, $f(x)$ for $0\le x\le 30$, and $L_2(x)$ for $x&amp;gt;30$) doesn&amp;rsquo;t have a continuous second derivative. So you decide to improve the design by using a quadratic function $q(x)=ax^2 + bx + c$ only on the interval $3\le x\le 27$ and connecting it to the linear functions by means of two cubic functions:
$$
g(x) = kx^3+lx^2+mx+n, \quad 0\le x&amp;lt;3,
$$
$$
h(x) = px^3 + qx^2 + rx+s, \quad 27&amp;lt;x\leq 30.
$$&lt;/p&gt;
&lt;p&gt;(a) Write a system of equations in $11$ unknowns that ensure that the functions and their first two derivatives agree at the transition points.&lt;/p&gt;
&lt;p&gt;(b) Solve the equations in part (a) with a computer algebra system to find formulas for $q(x)$, $g(x)$, and $h(x)$.&lt;/p&gt;
&lt;p&gt;(c) Plot $L_1$, $g$, $q$, $h$, and $L_2$, and compare with the plot in Problem1(c).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Below is the graph of the smoother roller coaster:















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_2.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s4p1_2.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

The red one is the graph of $g(x)$, the blue one is the graph of $q(x)$, and the green one is the graph of $h(x)$.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.4.7 - 罐頭的形狀</title>
      <link>https://teshenglin.github.io/post/2020_cal_s4p7_ch/</link>
      <pubDate>Tue, 10 Mar 2020 12:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s4p7_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project 1 in Sec.4.7, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_cal_s4p7&#34;&gt;The shape of a can&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;給定一個體積為 $v$ 的圓柱體罐頭，我們想找到一個高 $h$ 和半徑 $r$ ，將製成罐頭的金屬量減到最小。&lt;/p&gt;
&lt;p&gt;如果我們將製程中金屬的浪費忽略，那麼這個問題就是在找圓柱的最小表面積。計算之後發現這個問題的解是 $h=2r$ ，也就是說，高必須相等於直徑。&lt;/p&gt;
&lt;p&gt;然而，去超市晃晃會發現一般而言市面上的罐頭的高都大於直徑， $h/r$ 的比例可以從 $2$ 到大約 $3.8$。讓我們來看看是否可以解釋這個現象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/study/e3e/e3e1a59a-d0be-46e7-8557-07e775d84b81/715030-4.7-1IAP11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;問題 1:&lt;/strong&gt; 罐頭的原料是從金屬板上切割下來的，它(圓柱)的邊是由彎曲的矩形組成，而這些矩形也是從板上切成且過程中幾乎沒有浪費。&lt;/p&gt;
&lt;p&gt;然而，如果圓柱上下的圓面是由邊為 $2r$ 的正方形切割的，那麼一定會有大量的金屬浪費，儘管它可以回收再利用，但對罐頭製造商來說是幾乎沒有任何價值的。&lt;/p&gt;
&lt;p&gt;因此，如果是這樣的話，我們就需要找到一組 $h/r$ 比例來最小化金屬的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{8}{\pi}\approx 2.55
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2:&lt;/strong&gt; 若將金屬板劃分為六邊形並從六邊形切下圓形的蓋子和底座，可以更有效地填充圓盤。如果採用這個方法，要找到能讓使用的金屬量最小化的 $h/r$ 的比例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{4\sqrt{3}}{\pi}\approx 2.21
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3:&lt;/strong&gt; 除了罐子本身的金屬材料，我們現在將製程中所需成本包含進去&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假設大部分的成本發生在黏接邊與邊的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;製作一圓柱罐，首先我們彎曲一矩形並將邊與邊黏接在一起以製成圓柱殼（高度為 $ h $）；接著，將兩個圓盤與圓柱殼黏接（圓盤長度為$2πr$）。 由上可知，黏接成本為 $ k(h+4πr) $， $k$ 為單位面積金屬成本可黏接長度的倒數。&lt;/p&gt;
&lt;p&gt;同問題二，圓盤由一正六邊形切割而成，所以總成本包括金屬成本和黏接的成本，與$4\sqrt{3}r^2 + 2\pi r h + k(4\pi r + h) $成正比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;發生最小值時圓柱體的高度與半徑比為:
$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4:&lt;/strong&gt; 當圓柱罐非常大且黏接的成本低時結果會是怎樣呢？反之圓柱罐非常小且黏接的成本高？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;對固定體積的圓柱體而言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當黏接成本低  $0 &amp;lt; k ≪ 1$時，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k} \to \frac{4\sqrt{3}}{\pi}\approx 2.21
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當黏接成本較高 $ k ≫ 1$ 時，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k} \to 2\pi\approx 6.28
$$&lt;/p&gt;
&lt;p&gt;如果$ k $為定值，我們先找出體積 $ v $與比值 $h/r$ 的關係。為了書寫方便，我們定義  $R = h/r$ 。接著重新將$ r$表示為 $v$與 $R$ 的函數，
$$
r = \sqrt[3]{\frac{v}{\pi R}}
$$
經過運算
$$
\frac{\sqrt[3]{v}}{k} = \frac{\sqrt[3]{\pi R}(2\pi - R)}{\pi R - 4\sqrt{3}}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當圓柱罐非常大 $v ≫ 1$ 時，右式的分母趨近於 0，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\pi R - 4\sqrt{3} \to 0 \Longrightarrow \frac{h}{r} = R \to \frac{4\sqrt{3}}{\pi}\approx 2.21
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當圓柱罐非常較小  $0 &amp;lt; v ≪ 1$ 時，右式分子趨近於 0，
$$
2\pi - R \to 0 \Longrightarrow \frac{h}{r} = R \to 2\pi\approx 6.28
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.10 - 泰勒級數</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p10_ch/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p10_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Laboratory Project in Sec.3.10, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p10&#34;&gt;Taylor polynomials&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在近似函數 $f(x)$ 在 $x=a$ 的值時，切線逼近函數(tangent line approximation) $L(x)$ 是線性逼近(linear approximation)中最好的近似方式，這是因為 $f(x)$ 及 $L(x)$ 在 $x=a$ 這點有相同的改變速率。&lt;/p&gt;
&lt;p&gt;為了找尋比線性逼近更好的近似方式，我們嘗試利用二次逼近函數(quadratic approximation) $Q(x)$ 來做近似，換句話說，我們利用拋物線來逼近 $f(x)$ 的值而非直線。為了確定這樣的近似方式是合理的，我們規定以下條件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$P(a)=f(a)$&lt;/li&gt;
&lt;li&gt;$P&#39;(a)=f&#39;(a)$&lt;/li&gt;
&lt;li&gt;$P&#39;&#39;(a)=f&#39;&#39;(a)$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 1：&lt;/strong&gt; 對於函數 $f(x)=\cos(x)$，找尋它在 $a=0$ 時的二次逼近函數 $P(x)=A+Bx+Cx^2$，並且此函數須滿足上述介紹中的三個條件。接著對函數 $P,f$ 及線性逼近函數 $L(x)=1$ 作圖，比較 $P$ 和 $f$ 哪一個逼近函數比較精確。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$P(x)=1-\frac{1}{2}x^{2}$&lt;/p&gt;
&lt;p&gt;函數 $P,f$ 及線性逼近函數 $L(x)=1$ 作圖如下：&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_01.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_01.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;由上圖可知，在 $x\rightarrow a$ 時，$|P(x)-f(x)|&amp;laquo;|L(x)-f(x)|$，因此二次逼近函數 $P(x)$ 近似函數 $f(x)$ 的程度較優於線性逼近函數 $L(x)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 2：&lt;/strong&gt; 延續題1，試求符合條件的 $x$ 滿足 $P(x)$ 及 $f(x)$ 的差值在 $0.1$ 內。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;對 $g(x),P(x),h(x)$ 作圖如下：&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_02.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_02.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;由圖可知，在 $-1.26\leq x\leq 1.26$ 時，滿足 $|P(x)-f(x)|\leq 0.1$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 3：&lt;/strong&gt; 利用二次逼近函數 $P$ 來近似在 $x=a$ 附近的函數 $f$ 時，可以先將函數 $P$ 寫成以下形式：
$$
P(x)=A+B(x-a)+C(x-a)^{2}。
$$
證明一個滿足專題介紹中3個條件的二次逼近函數$P(x)$可以表示為
$$
P(x)=f(a)+f&#39;(a)(x-a)+\frac{1}{2} f&#39;&#39;(a)(x-a)^{2}。
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
P(x)=f(a)+f&#39;(a)(x-a)+\frac{1}{2} f&#39;&#39;(a)(x-a)^{2}。
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 4：&lt;/strong&gt; 找尋函數 $f(x)=\sqrt{x+3}$ 在 $a=1$ 時的二次逼近函數，接著對 $f$、二次逼近函數及線性逼近函數做圖。你能做怎樣的結論？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;對函數 $f(x),P(x)$ 及線性逼近函數作圖如下：&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_03.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_03.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;由圖可知，在 $x\rightarrow 1$ 的地方，二次逼近函數 $P(x)$ 的近似程度較線性逼近函數 $L(x)$ 還要精確。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 5：&lt;/strong&gt; 對於函數 $f(x)$，在 $x\to a$ 的近似方式除了用二次逼近函數或線性逼近函數外，我們試著找尋更精確的多次逼近函數。考慮一個 $n$ 次多項式：
$$
T_{n}(x)=c_{0}+c_{1}(x-a)+c_{2}(x-a)^{2}+c_{3}(x-a)^{3}+&amp;hellip;+c_{n}(x-a)^{n}，
$$
它滿足在 $x=a$ 時，
$$
T_{n}^{(k)}(a)=f^{(k)}(a), \quad k=1, \cdots, n。
$$
證明：滿足上述條件的 $T_{n}(x)$ 其係數 $c_{k}=\frac{f^{(k)}(a)}{k!}$。(將係數 $c_{k}$ 代入函數 $T_{n}(x)$ 後，函數為
$$
T_{n}(x)=f(a)+f&#39;(a)(x-a)+\frac{f&#39;&#39;(a)}{2!} (x-a)^{2}+&amp;hellip;+\frac{f^{(n)}(a)}{n!}(x-a)^{n}。
$$
此即為函數 $f$ 在點 $a$ 的 $n$ 階泰勒級數。)&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題 6：&lt;/strong&gt; 試求函數 $f(x)=\cos(x)$ 在點 $a=0$ 的8階泰勒級數。除此之外，對函數 $f$ 及 $T_{2},T_{4},T_{6},T_{8}$ 做圖，考慮範圍為 $x=[-5,5],y=[-1.4,1.4]$ 之長方形，評論對於函數 $f$，4條逼近函數 $T$ 的近似程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;對函數 $f$ 及 $T_{2},T_{4},T_{6},T_{8}$ 做圖，黑色框線為題目要求 $x=[-5,5],y=[-1.4,1.4]$ 之長方形。&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_04.png&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2020_cal_s3p10_04.png&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;由圖可以看出逼近函數 $T$ 的次方越高，與函數 $f$ 在 $a=0$ 這點的相似程度就越高、範圍也越大。也就是說，在這4條函數中，對於函數 $f$ 在 $a=0$ 時的逼近函數以 $T_{8}(x)$ 最為精確。&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.3.4 - 飛行員應該何時開始下降高度?</title>
      <link>https://teshenglin.github.io/post/2020_cal_s3p4_ch/</link>
      <pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal_s3p4_ch/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.4, Calculus by Stewart&lt;br&gt;
英文版請見 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_cal_s3p4&#34;&gt;Where should a pilot start descent?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/ImsaT.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上圖是一台飛行器的降落軌跡近似圖，它必須滿足以下條件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;巡航高度為$h$，而飛行器在與著陸地點(同時也是圖中的原點)水平距離為$l$時開始下降&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在整個下降過程中，飛行員必須維持固定的水平速度$v$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;鉛直加速度的絕對值不能超過某個常數$k$(和地心引力造成的加速度相比，$k$非常的小)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題壹：&lt;/strong&gt; 請透過加適當條件在「開始下降」和「著陸」這兩個時間點的$P(x)$和$P’(x)$上，來找到一個滿足條件(1.)的三次多項式 $P(x) = ax^3 + bx^2 + cx + d$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
P(x) = −\frac{2h}{\ell^3}x^3 + \frac{3h}{\ell^2}x^2。
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題貳：&lt;/strong&gt; 用條件(2.)和(3.)來證明$\frac{6hv^2}{\ell^2}\le k$。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題參：&lt;/strong&gt; 假設某航空公司決定不讓飛機的鉛直加速度達到$k = 860(英里/小時^2)$。如果飛機的巡航高度是$35,000$(英尺)且速度是$300$(英里/小時)，飛行員該在距離機場多遠的地方開始下降？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;飛行員應該在距離機場$64.511$(英里)的地方開始下降。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;問題肆：&lt;/strong&gt; 請繪製近似圖(假設問題參當中的所有條件都被滿足)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Example code in julia&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;
h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6.628&lt;/span&gt;;
l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;65&lt;/span&gt;;
N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
dx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dx&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x;
P &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
plot(x, P, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;, ylabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;y&amp;#34;&lt;/span&gt;, title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;approach path&amp;#34;&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2019.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2019.jpg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Limit of a sequence - Example</title>
      <link>https://teshenglin.github.io/post/2020_cal2_s11p1_e79/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_cal2_s11p1_e79/</guid>
      <description>&lt;p&gt;Section 11.1, exercise 79: Find the limit of
$$
\{\sqrt{2}, \sqrt{2\sqrt{2}}, \sqrt{2\sqrt{2\sqrt{2}}}, \cdots\}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 這個數列也可以用以下表示方式
$$
a_1 = \sqrt{2}, \quad a_{n+1} = \sqrt{2 a_n}, \quad n\in \mathbb{N}, \quad n&amp;gt;1.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;method-1&#34;&gt;Method 1&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;我們首先證明它有極限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$a_n&amp;lt;2$ (我們使用數學歸納法)
&lt;ol&gt;
&lt;li&gt;已知 $a_1=\sqrt{2}&amp;lt;2$, 成立.&lt;/li&gt;
&lt;li&gt;假設 $a_k&amp;lt;2$, 則 $a_{k+1} = \sqrt{2a_k} &amp;lt; \sqrt{2\times 2} = 2$, 亦成立.&lt;/li&gt;
&lt;li&gt;根據數學歸納法我們得到 $a_n&amp;lt;2$, $\forall n$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;$a_n&amp;gt;0$
&lt;blockquote&gt;
&lt;p&gt;這個顯然&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;claim: $a_{n+1}&amp;gt;a_n$
&lt;blockquote&gt;
&lt;p&gt;由於 $0&amp;lt;a_n&amp;lt;2$, 我們可以得到 $a_n(a_n-2)&amp;lt;0$, 移項並兩邊同時開根號得到 $a_{n+1}=\sqrt{2a_n} &amp;gt; a_n$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;因為數列 $\{a_n\}$ 遞增且有界, 根據 Monotone sequence theorem 此數列收斂.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我們接著求此數列極限值&lt;/p&gt;
&lt;p&gt;假設 $\lim_{n\to\infty} a_n=L$, 則
$$
\lim_{n\to\infty} a_{n+1} = \lim_{n\to\infty} \sqrt{2 a_n}, \quad \Longrightarrow \quad L = \sqrt{2L}.
$$
所以 $L=0$ 或 $L=2$. 我們知道 $a_n$ 為遞增數列所以 $L = 2$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;method-2&#34;&gt;Method 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;這是看 
&lt;a href=&#34;https://www.slader.com/textbook/9781305272378-stewart-calculus-early-transcendentals-metric-version-8th-edition/705/exercises/79/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;slader&lt;/a&gt; 學會的解法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$a_1=\sqrt{2}=2^{1/2}$&lt;/li&gt;
&lt;li&gt;$a_2 = \sqrt{2a_1} = 2^{1/2 + 1/4}$&lt;/li&gt;
&lt;li&gt;$a_3 = \sqrt{2a_2} = 2^{1/2 + 1/4 + 1/8}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;觀察發現此數列收斂到
$$
2^{\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \frac{1}{16} + \cdots} = 2^1 = 2.
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Polar curve - Example</title>
      <link>https://teshenglin.github.io/post/2020_polar_graph_ex1/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_polar_graph_ex1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 $r^2=\cos(4\theta)$ 這個方程式的圖形怎麼畫.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先, 因為 $r^2 \ge 0$, 所以整個方程式只有在 $\cos 4\theta \ge 0$ 的地方有定義.&lt;/p&gt;
&lt;p&gt;我們先找離 $\theta=0$ 最近的一段定義域, 也就是
$$
-\frac{\pi}{8}\le \theta \le \frac{\pi}{8}.
$$
在這範圍內 $\cos(4\theta)\ge 0$ 所以沒問題.&lt;/p&gt;
&lt;p&gt;接著我們試著把方程式寫成函數的樣子, 改寫成 $r = \pm\sqrt{\cos(4\theta)}$. 當然這樣不是函數, 所以應該是寫成兩個函數
$$
r = \sqrt{\cos(4\theta)}, \quad -\frac{\pi}{8}\le \theta \le \frac{\pi}{8},
$$
以及
$$
r = -\sqrt{\cos(4\theta)}, \quad -\frac{\pi}{8}\le \theta \le \frac{\pi}{8}.
$$&lt;/p&gt;
&lt;p&gt;接著把這兩個函數分別畫出來就會得到兩片葉子.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接著我們找另一段有定義地方:
$$
\frac{3\pi}{8}\le \theta \le \frac{5\pi}{8}.
$$
照以上一模一樣的步驟可以得到兩個函數
$$
r = \sqrt{\cos(4\theta)}, \quad \frac{3\pi}{8}\le \theta \le \frac{5\pi}{8},
$$
以及
$$
r = -\sqrt{\cos(4\theta)}, \quad \frac{3\pi}{8}\le \theta \le \frac{5\pi}{8}.
$$&lt;/p&gt;
&lt;p&gt;把這兩個函數分別畫出來就會得到另外兩片葉子.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;想要驗證自己畫得對不對可以對照以下圖形&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/r2cos4theta.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;這個圖形我有點偷懶是用線上做圖畫的

&lt;a href=&#34;https://www.desmos.com/calculator/oacuvw7j1v&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;polar curve on-line&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;當然, $\cos(4\theta) \ge 0$ 的定義域還有更多區間. 不過再多找一兩個區間會發現, 做出來的圖與以上四片葉子重複了. 所以整個函數圖形就是這四片葉子.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>A direct Poisson solver in spherical geometry with an application to diffusiophoretic problems</title>
      <link>https://teshenglin.github.io/publication/20_jcp_lhm/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/20_jcp_lhm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Fast spectral solver for Poisson equation in an annular domain</title>
      <link>https://teshenglin.github.io/publication/20_amsa_lhh/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/20_amsa_lhh/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sec.4.7 - Planes and birds: Minimizing energy</title>
      <link>https://teshenglin.github.io/post/2019_cal_s4p7_2/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_cal_s4p7_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project 2 in Sec.4.7, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s4p7_2_ch&#34;&gt;飛機和鳥：能量最小化&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Small birds like finches alternate between flapping their wings and keeping them folded while gliding. In this project we analyze this phenomenon and try to determine how frequently a bird should flap its wings. Some of the principles are the same as for fixed-wing aircraft and so we begin by considering how required power and energy depend on the speed of airplanes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/study/ad0/ad0cd741-aa85-4256-a058-b49a8ef42198/715030-4.7-4IAP21.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt; The power needed to propel an airplane forward at velocity​ $v$ is&lt;/p&gt;
&lt;p&gt;$$
P = Av^3 + \frac{BL^2}{v}
$$&lt;/p&gt;
&lt;p&gt;where $A$ and $B$ are positive constants specific to the particular aircraft and $L$ is the lift, the upward force supporting the weight of the plane. Find the speed that minimizes the required power.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
v_P = \sqrt[4]{\frac{BL^2}{3A}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;	The speed found in Problem 1 minimizes power but a faster speed might use less fuel. The energy needed to propel the airplane a unit distance is​ $E = P/v$ . At what speed is energy minimized?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
v_E = \sqrt[4]{\frac{BL^2}{A}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt; Hows much faster is the speed for minimum energy than the speed for minimum power?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
\frac{v_E}{v_P} = \sqrt[4]{3}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;  In applying the equation of Problem 1 to bird flight we split the term $Av^3$ ​into two parts:​ $A_b v^3$ ​for the bird&amp;rsquo;s body and​ $A_w v^3$ ​for its wings. Let​ $x$ be the fraction of flying time spent in flapping mode. If $m$ is the bird&amp;rsquo;s mass and all the lift occurs during flapping, then the lift is $mg/x$ and so the power needed during flapping is&lt;/p&gt;
&lt;p&gt;$$
P_f = (A_b+A_w)v^3 + \frac{B(mg/x)^2}{v}
$$&lt;/p&gt;
&lt;p&gt;The power while wings are folded is $P_o = A_b v^3$. Find the average power over an entire flight cycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
P_a = x P_f + (1-x) P_o = A_b v^3 + A_w v^3 x + \frac{B m^2 g^2}{xv}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 5:&lt;/strong&gt;  For what value of​ $x$ is the average power a minimum? What can you conclude if the bird flies slowly? What can you conclude if the bird flies faster and faster?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
x = \frac{mg}{v^2}\sqrt{\frac{B}{A_w}}
$$&lt;/p&gt;
&lt;p&gt;It can be seen that $x$ is inverse proportional to $v^2$, so,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鳥飛的慢,拍翅時間佔總體飛行時間上升&lt;/li&gt;
&lt;li&gt;鳥飛的快,滑翔時間佔總體飛行時間上升&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 6:&lt;/strong&gt;  The average energy over a cycle is $E_a = P_a/v$. What value of $x$​ minimizes $E_a$?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
x = \frac{mg}{v^2}\sqrt{\frac{B}{A_w}}
$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 畫圖</title>
      <link>https://teshenglin.github.io/post/2020_julia_plots/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_plots/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;底下的幾個例子我們將學習怎麼使用繪圖指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;畫圖的時候我們會用到 &lt;code&gt;Plots&lt;/code&gt; 這個 package，因此在第一行我們需要加上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下我們舉幾個簡單的範例來看看如何操作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; &lt;code&gt;Plots&lt;/code&gt; 這個 package 完整的說明請見 
&lt;a href=&#34;http://docs.juliaplots.org/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plots&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-11-基本函數&#34;&gt;Example 1.1 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin(x)$ 的例子。在 plot 指令中我們指定三件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;告訴他我們要畫 $y = \sin(x)$ 這個函數。&lt;/li&gt;
&lt;li&gt;再來要指定函數的範圍 $-\pi &amp;lt; x &amp;lt; \pi$。&lt;/li&gt;
&lt;li&gt;最後用 label 標註函數圖形。注意要把標註的文字放在 &amp;quot; &amp;quot; 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，也可以畫 $e^x$、$arcsin(x)$ 這些基本函數。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(sin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi, pi, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_01.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;example-12-基本函數&#34;&gt;Example 1.2 基本函數&lt;/h2&gt;
&lt;p&gt;這是一個畫出 $\sin^{-1}(x)$ 的例子，有幾件事需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\sin(x)$ 的反函數 $arcsin(x)$ 的指令為 asin。&lt;/li&gt;
&lt;li&gt;函數的範圍為 $-1 &amp;lt; x &amp;lt; 1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(asin, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arcsine function&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_7_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-2&#34;&gt;Example 2&lt;/h2&gt;
&lt;p&gt;接著我們看三維圖形的例子。這個例子中我們要畫出三維中的一條曲線&lt;/p&gt;
&lt;p&gt;$$\left(x(t), y(t), z(t)\right) = (t\cos t, t\sin t, t), \quad t\in[0, 8\pi].$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先將 $8\pi$ 切成 N 等分, 間距為 $\Delta t = 8\pi/N$.
&lt;ol&gt;
&lt;li&gt;在 julia 中可使用 unicode 變數名稱, 比如 $\Delta$ 打法是 &lt;code&gt;\Delta&lt;/code&gt; 接著按 tab 鍵, $\pi$ 則是 &lt;code&gt;\Pi&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定義 $n$ 是一個 $(N+1)\times 1$ 的向量，n = [0, 1, 2, &amp;hellip;,N]。&lt;/li&gt;
&lt;li&gt;定義 $t_i$ 是 $\Delta t\times n$&lt;/li&gt;
&lt;li&gt;$x = t_i .*\cos .(ti)$，注意向量相乘以及函數在向量的取值都需要加個&lt;code&gt;.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y 與 z 的值與 x 的值定義方法類似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由 (x,y,z) 的定義方式我們知道它是一個螺旋線，螺旋的半徑從 0 一直增加到 $8 \pi$。角度也是從 0 到 $8 \pi$，所以總共繞了4圈。
在 plot 指令中我們用 marker 選擇圖形的樣式為圓圈(circle)，legend=false 代表不標記圖形。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;;
Δt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;π&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N;
ti &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Δt&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;cos&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti&lt;span style=&#34;color:#f92672&#34;&gt;.*&lt;/span&gt;sin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(ti);
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ti;
plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_9_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外, 可以用 &lt;code&gt;camera&lt;/code&gt; 這個指令來調整 3D 視角, 裡面數字是角度 (方位角azimuth, 高度角altitude).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot(x, y, z, marker&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:circle&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false, camera &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_11_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們也可以使用指令 &lt;code&gt;plotd3d&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們設定 linewidth (lw) 等於 2 以及 legend (leg) 等於 false 表示不標記圖形.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;plot3d(x, y, z, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://teshenglin.github.io/post/figs/output_13_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3&#34;&gt;Example 3&lt;/h2&gt;
&lt;p&gt;這個例子中，我們將學到怎麼在一個畫好的圖形上再加上另一個圖形。
我們嘗試一個簡單的例子，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一個圖形，x 座標是取整數 1 到 10。y 軸取 0 到 1 之間的亂數，共十個小數。再來，用 plot 指令將第一個圖形畫出。&lt;/li&gt;
&lt;li&gt;第二個圖形，使用相同的 x 座標，函數值 z 取亂數。將第二個函數圖形與第一個圖形重疊，我們需要指令 plot!&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
plot(x,y)
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
plot!(x,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_15_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-4&#34;&gt;Example 4&lt;/h2&gt;
&lt;p&gt;在一個圖形中同時畫出兩個函數，除了上述的方法之外我們還可以這麼做： 直接把兩個函數值定義成一個矩陣&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定義 x 是整數 1 到 10。&lt;/li&gt;
&lt;li&gt;定義函數值 y 是一個 10*2 的矩陣，矩陣的第一行代表第一個函數的值，而矩陣的第二行代表第二個函數的值。y值的取法為 0 到 1 之間的亂數，為小數。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 plot 將兩個函數值同時畫出，用 title 設定圖形標題，lw=3 設定線段寬度。&lt;/p&gt;
&lt;p&gt;用 label=[&amp;ldquo;Line 1&amp;rdquo; &amp;ldquo;Line 2&amp;rdquo;] 標記函數名稱，須注意順序：
Line 1 會標記 y 的第一個函數值，Line 2 會標記 y 的第二個函數值。&lt;/p&gt;
&lt;p&gt;x 軸的名稱有兩種設定方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 plot 指令中加入：xlabel = &amp;ldquo;My x label&amp;rdquo;。 (xlabel 後面不用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;li&gt;或是在 plot 指令的下一行用 xlabel!(&amp;ldquo;My x label&amp;rdquo;) 加入。(xlabel! 後面要用&amp;quot;!&amp;quot;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_17_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
plot(x,y,title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Two Lines&amp;#34;&lt;/span&gt;,label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line 2&amp;#34;&lt;/span&gt;],lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My x label&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_18_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-5&#34;&gt;Example 5&lt;/h2&gt;
&lt;p&gt;如果函數取點的方法不同，能不能畫在同一張圖形中呢？
我們看下面的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;y 這個矩陣裡包含兩筆資料，x 的取點都是整數 1 到 10。所以可以用 &amp;ldquo;一個&amp;rdquo; 指令把兩筆資料畫出來。令這張圖叫做 p&lt;/li&gt;
&lt;li&gt;z 這筆資料為 0 到 1 中的 19 個亂數，xx 的取點也是19個在 [1, 10] 的均勻取點。所以我們用 plot! 指令，先畫出 p, 再把 z 這筆資料畫上去。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot(x,y)

xx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)
plot!(p,xx,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_20_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 利用 &lt;code&gt;plot(x,y,xx,z)&lt;/code&gt; 這樣的指令是行不通的!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 另外，畫圖也可以用 &lt;code&gt;PyPlot&lt;/code&gt; 這個 package，有很多有趣的效果可以用。&lt;/p&gt;
&lt;p&gt;更多範例請見 
&lt;a href=&#34;http://blog.maxkit.com.tw/2019/06/julia-data-visulization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Data Visualization&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-6---曲面&#34;&gt;Example 6 - 曲面&lt;/h2&gt;
&lt;p&gt;這個例子我們示範如何畫曲面 $(x, y, h(x,y))$, where $h(x,y) = exp(-(x^2+y^2))$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我們設定 x 與 y 的範圍 $[-1, 1]$.&lt;/li&gt;
&lt;li&gt;接著我們設定函數 &amp;ldquo;h&amp;rdquo;&lt;/li&gt;
&lt;li&gt;最後, 我們利用指令 &lt;code&gt;surface&lt;/code&gt; 來畫曲面.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
y&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
h(x,y)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;exp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
surface(x,y,h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_23_0.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;example-7-動畫&#34;&gt;Example 7: 動畫&lt;/h2&gt;
&lt;p&gt;如果要將很多圖片合在一起做成動畫也是可以, 以下這個簡單例子將動畫存成一個 gif 檔.&lt;/p&gt;
&lt;p&gt;更多細節請見 
&lt;a href=&#34;https://docs.juliaplots.org/latest/animations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia_plots_animations&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plot([sin, cos], zeros(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), leg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
anim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Animation()
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;π, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
    push!(p, x, &lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;[sin(x), cos(x)])
    frame(anim)
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
gif(anim, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sine_cosine.gif&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/sine_cosine.gif&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記 - 計時</title>
      <link>https://teshenglin.github.io/post/2020_julia_timing/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2020_julia_timing/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 計算程式執行時間的指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，julia 計算程式運行效能有幾個指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@time&lt;/code&gt; 顯示出程式運行的秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timed&lt;/code&gt; 顯示程式執行回傳值，秒數以及記憶體的使用狀況&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@timev&lt;/code&gt; 顯示&lt;code&gt;@time&lt;/code&gt;一樣的資訊，最後顯示程式執行回傳值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@elapsed&lt;/code&gt; 顯示出某程式運行的秒數&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 真正要計算程式效能, 還是推薦用 &lt;code&gt;BenchmarkTools.jl&lt;/code&gt; 這個 package.&lt;/p&gt;
&lt;p&gt;以下範例中我們需要使用兩個 package: &lt;code&gt;LinearAlgebra&lt;/code&gt; 以及 &lt;code&gt;BenchmarkTools&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; LinearAlgebra
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; BenchmarkTools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;example-1-matrix-matrix-multiplication&#34;&gt;Example 1: Matrix-matrix multiplication&lt;/h2&gt;
&lt;p&gt;我們以矩陣乘法 $C=A\times B$ 為例：$A:n\times p$, $B:p\times m$, $C:n\times m$&lt;/p&gt;
&lt;p&gt;f1 這個函數會產生兩個隨機矩陣 $A$, $B$ 並且將他們相乘:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f1(n, p, m)
   A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
   B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
   C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;m
         &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;p
            C[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; C[i,j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;A[i,k]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;B[k,j]
         &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們先試試看以 julia 既有的計算時間指令來看結果如何&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@time&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.076423 seconds (161.79 k allocations: 8.380 MiB)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;(nothing, 0.000448109, 184496, 0.0, Base.GC_Diff(184496, 1, 0, 5, 2, 0, 0, 0, 0))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@timev&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;  0.005932 seconds (8 allocations: 180.172 KiB, 92.28% gc time)
elapsed time (ns): 5931535
gc time (ns):      5473727
bytes allocated:   184496
pool allocs:       5
non-pool GC allocs:2
malloc() calls:    1
GC pauses:         1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@elapsed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;0.000561533
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這些指令的表現如同一開始我們所介紹的, 顯示出程式執行時間以及其他資訊.&lt;/p&gt;
&lt;p&gt;不過一般而言一個程式在第一次跑及之後幾次跑的運行效能會不同, 這是由於初始化的關係. 所以我們通常要跑好幾次來算平均, 已得知一個程式的真正效能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;benchmark&lt;/code&gt; 就提供了這樣的功用, 他會跑好幾次程式, 並且計算最大最小時間.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     437.243 μs (0.00% GC)
  median time:      485.922 μs (0.00% GC)
  mean time:        513.114 μs (3.90% GC)
  maximum time:     44.383 ms (98.89% GC)
  --------------
  samples:          9711
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著我們看一下如果用 &lt;code&gt;LinearAlgebra&lt;/code&gt; 裡的矩陣乘法指令效能如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; f2(n, p, m)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,p)
    B&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(p,m)
    C&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Float64&lt;/span&gt;,n,m)
    mul!(C,A,B);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;f2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; f2(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  180.02 KiB
  allocs estimate:  4
  --------------
  minimum time:     41.088 μs (0.00% GC)
  median time:      91.270 μs (0.00% GC)
  mean time:        106.954 μs (19.04% GC)
  maximum time:     45.286 ms (99.75% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起來似乎比我們自己寫的 for-loop 效能好一些.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;type-stability&#34;&gt;type-stability&lt;/h2&gt;
&lt;p&gt;julia 語言號稱效能非常好, 不過常常我們自己寫一個 julia 程式發現跑得沒有很快, 這通常是由於所謂的 “型別穩定性 type-stability”. 這樣的問題可以藉由以下幾個 julia 內建的巨集程式來診斷.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_warntype&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_typed&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@code_native&lt;/span&gt; f1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這方面更深入的說明可見 
&lt;a href=&#34;https://docs.julialang.org/en/v1/manual/performance-tips/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia: performance tips&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-2-vector-2-norm&#34;&gt;Example 2: Vector 2-norm&lt;/h2&gt;
&lt;p&gt;接著我們看一下算向量 2-norm 的效能, 一樣我們比較一下自己寫的以及 call 函數的方式.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t1(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    vec&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.42 KiB
  allocs estimate:  3
  --------------
  minimum time:     423.973 μs (0.00% GC)
  median time:      504.538 μs (0.00% GC)
  mean time:        606.699 μs (9.87% GC)
  maximum time:     47.376 ms (98.43% GC)
  --------------
  samples:          8213
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; t2(n)
    vec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n);
    sum(abs2, vec);
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;t2 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; t2(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  781.33 KiB
  allocs estimate:  2
  --------------
  minimum time:     141.160 μs (0.00% GC)
  median time:      195.940 μs (0.00% GC)
  mean time:        335.496 μs (19.51% GC)
  maximum time:     64.500 ms (99.17% GC)
  --------------
  samples:          10000
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;example-3-solving-linear-system&#34;&gt;Example 3: Solving linear system&lt;/h2&gt;
&lt;p&gt;這裡我們看一下解線性系統, 也就是 matlab 常見的&amp;quot;左除&amp;quot;, 的效率如何.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; s1(n)
    A&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n,n);
    b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rand(n);
    A&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;s1 (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt; s1(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;BenchmarkTools.Trial:
  memory estimate:  15.28 MiB
  allocs estimate:  8
  --------------
  minimum time:     13.463 ms (0.00% GC)
  median time:      16.817 ms (10.20% GC)
  mean time:        18.148 ms (9.36% GC)
  maximum time:     64.226 ms (77.63% GC)
  --------------
  samples:          276
  evals/sample:     1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Sec.4.7 - The shape of a can</title>
      <link>https://teshenglin.github.io/post/2019_cal_s4p7/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_cal_s4p7/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project 1 in Sec.4.7, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s4p7_ch&#34;&gt;罐頭的形狀&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a cylindrical can with fixed volume $v$, we want to find the height $h$ and radius $r$ that minimize the cost of metal to make the can.&lt;/p&gt;
&lt;p&gt;If we disregard any waste metal in the manufacturing process, then the problem is to minimize the surface area of the cylinder. It can be found that the solution of this problem is $h=2r$; this is, the height should be the same as the diameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But,&lt;/strong&gt; for most of the cans in the supermarket, the height is usually greater than the diameter and the ratio $h/r$ varies from $2$ up to about $3.8$. Let&amp;rsquo;s see if we can explain this phenomenon.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://media.cheggcdn.com/study/e3e/e3e1a59a-d0be-46e7-8557-07e775d84b81/715030-4.7-1IAP11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt; The material for the cans is cut from sheets of metal. The cylindrical sides are formed by bending rectangles; these rectangles are cut from the sheet with little or no waste.&lt;/p&gt;
&lt;p&gt;But if the top and bottom discs are cut from squares of side $2r$, this leaves considerable waste metal, which may be recycled but has little or no value to the can makers. If this is the case, find the ratio $h/r$ for which the amount of metal used is minimized.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{8}{\pi}\approx 2.55
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt;	A more efficient packing of the discs is obtained by dividing the metal sheet into hexagons and cutting the circular lids and bases from the hexagons. If this strategy is adopted, find the ratio $h/r$ for which the amount of metal used is minimized.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{4\sqrt{3}}{\pi}\approx 2.21
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt; In addition to the cost of the metal, we need to incorporate the manufacturing of the can into the cost.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Assuming that most of the expense is incurred in joining the sides.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a cylindrical can, we need to bend a rectangle and joinging the sides together (with length $h$) to make the cylindrical shell. Also we need to join the two discs to the shell (each disc with length $2\pi r$). So the cost in joining is $k(h + 4\pi r)$ where $k$ is the reciprocal of the length that can be joined for the cost of one unit area of metal.&lt;/p&gt;
&lt;p&gt;If we cut the discs from hexagons as in Question 2, then the total cost consists of the cost of the metal and the cost in joinging the sides, that is proportional to $4\sqrt{3}r^2 + 2\pi r h + k(4\pi r + h)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;with the minimum metal used,&lt;/p&gt;
&lt;p&gt;$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k}.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt; What happened when a can is large or joining is cheap, and what happened when the can is small or joining is costly?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For a cylinder with fixed volume $v$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When joining is cheap, $0&amp;lt;k\ll 1$, we have
$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k} \to \frac{4\sqrt{3}}{\pi}\approx 2.21.
$$&lt;/li&gt;
&lt;li&gt;When joining is costly, $k\gg 1$, we have
$$
\frac{h}{r} = \frac{4\sqrt{3}r + 2k\pi}{\pi r + k} \to 2\pi\approx 6.28.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If $k$ is fixed, we need to firstly find the relation between the volume $v$ and the ratio $h/r$.&lt;/p&gt;
&lt;p&gt;For convenience of notation we define $R=h/r$. Then we rewrite $r$ as a function of $v$ and $R$ as
$$
r = \sqrt[3]{\frac{v}{\pi R}}.
$$
With careful calculation we obtain
$$
\frac{\sqrt[3]{v}}{k} = \frac{\sqrt[3]{\pi R}(2\pi - R)}{\pi R - 4\sqrt{3}}.
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When a can is large, $v\gg 1$, we have that the denominator of the term of the right hand side should approaches $0$, that is,
$$
\pi R - 4\sqrt{3} \to 0 \Longrightarrow \frac{h}{r} = R \to \frac{4\sqrt{3}}{\pi}\approx 2.21.
$$&lt;/li&gt;
&lt;li&gt;When a can is small, $0&amp;lt;v\ll 1$, we have that the numerator of the term of the right hand side should approaches $0$, that is,
$$
2\pi - R \to 0 \Longrightarrow \frac{h}{r} = R \to 2\pi\approx 6.28.
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>數值積分初探</title>
      <link>https://teshenglin.github.io/post/2019_numerical_integration/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_numerical_integration/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在微積分課程裡我們有學到積分的&amp;rsquo;中點法&#39;, &amp;lsquo;梯形法&amp;rsquo;以及&amp;rsquo;辛普森法&amp;rsquo;. 這裡我們簡介一些基本概念並且引進高斯積分法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;goal-任意給定一可積分函數-fx-xin-1-1-我們想要算-int1_-1-fx-dx&#34;&gt;Goal: 任意給定一可積分函數 $f(x)$, $x\in[-1, 1]$, 我們想要算 $\int^1_{-1} f(x) dx$.&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 對任一個積分式 $\int^b_{a} g(x),dx$ 我們皆可用變數變換來將此積分轉到 $[-1, 1]$ 這個區間. 所以我們只需考慮 $[-1, 1]$ 即可.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先我們討論一下哪種方法比較準. 一個最簡單的判斷方法是看積分法能不能將多項式算準.&lt;/p&gt;
&lt;p&gt;我們考慮三種積分法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Midpoint rule: $\int^1_{-1}f(x),dx\approx 2f(0)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trapezoidal rule: $\int^1_{-1}f(x),dx\approx f(-1)+f(1)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simpson&amp;rsquo;s rule: $\int^1_{-1}f(x),dx\approx \frac{1}{3}(f(-1)+4f(0)+f(1))$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我們先檢驗常數函數: $\int^1_{-1} 1,dx=2$. 很快我們就可以發現以上三種方法都可以得出完全正確的答案.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接著我們檢驗一次函數: $\int^1_{-1} x,dx=0$. 一樣, 三種方法都得出正確答案.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二次函數: $\int^1_{-1} x^2,dx=\frac{2}{3}$. 對於二次函數我們發現, 中點法以及梯形法都無法算出正確答案, 只有辛普森法能成功.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三次函數: $\int^1_{-1} x^3,dx=0$. 對於三次函數我們只檢驗辛普森法, 發現三次函數辛普森法也能算準.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四次函數: $\int^1_{-1} x^4,dx=\frac{2}{5}$. 對於四次函數, 辛普森法就算錯了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;小結論&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中點跟梯形法準確率相同, 能準確的算出任意一次多項式的積分值.&lt;/li&gt;
&lt;li&gt;辛普森法比中點及梯形法更準確, 並且它能準確的算出任意三次多項式的積分值.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;接著我們稍微推廣一下, 並且介紹所謂的&amp;rsquo;高斯積分&#39;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在想要用函數在 $x=0$ 這個點的值來估算積分, 那係數要取多少會最好?&lt;/p&gt;
&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x),dx\approx A_0f(0),$$
其中 $A_0$ 是個常數. 那 $A_0$ 要選哪個數字, 這個積分公式才會算的最準?&lt;/p&gt;
&lt;p&gt;依照我們之前的想法, 要讓積分式準就是要讓他把多項式算準. 所以我們希望他至少能把常數函數算準. 這樣的話很容易就看出 $A_0=2$, 也就是&amp;rsquo;中點法&#39;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在想要用函數在 $x=-1$ 以及 $x=1$ 這兩個點的值來估算積分, 那係數要取多少會最好?&lt;/p&gt;
&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x),dx\approx \alpha f(-1)+\beta f(1),$$
其中 $\alpha, \beta$ 是常數.&lt;/p&gt;
&lt;p&gt;我們有兩個未知數, 所以我們希望他至少能把常數及一次函數算準. 這樣的話我們可以列出方程式:
$$
\alpha + \beta = 2, \quad -\alpha + \beta = 0.
$$
解方程式我們得到 $\alpha=\beta=1$, 也就是梯形法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 假設我們現在只想用兩個點的值來估算積分, 那怎樣做會最好?&lt;/p&gt;
&lt;p&gt;也就是說我們假設
$$\int^1_{-1}f(x),dx\approx A_0 f(x_0)+A_1 f(x_1),$$
其中 $A_0, A_1, x_0, x_1$ 都待決定.&lt;/p&gt;
&lt;p&gt;我們有四個未知數, 所以理想狀況下應該能從常數到三次多項式都能算準, 依此可以列出四個方程式:
$$
\begin{aligned}
A_0 + A_1 &amp;amp;= 2 \\\&lt;br&gt;
A_0x_0 + A_1x_1 &amp;amp;= 0 \\\&lt;br&gt;
A_0x^2_0 + A_1x^2_1 &amp;amp;= \frac{2}{3} \\\&lt;br&gt;
A_0x^3_0 + A_1x^3_1 &amp;amp;= 0.
\end{aligned}
$$
解方程式我們得到 $A_0=A_1=1$, $x_0=-\frac{1}{\sqrt{3}}$, $x_1=\frac{1}{\sqrt{3}}$. 也就是說&lt;/p&gt;
&lt;p&gt;$$
\int^1_{-1} f(x),dx \approx f\left(-\frac{1}{\sqrt{3}}\right)+ f\left(\frac{1}{\sqrt{3}}\right).
$$
這就是所謂的兩點高斯積分公式 (two-point Gaussian quadrature formula).&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最後我們看一下以數值積分來估算的例子.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們想計算 $\int^1_{-1} e^x,dx$, 當然我們知道答案是 $e^1-e^{-1}$, 不過我們想要知道若以上列幾種方法估算會有多準確.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 一般來說我們會先將所要積分的範圍分成 $n$ 等分, 接著在每一等分上使用上列積分法. 這就是微積分課本中所介紹的合成積分法 (composite integral rules). 實作上的細節我們就不在這裡討論.&lt;/p&gt;
&lt;p&gt;我們將 $[-1, 1]$ 區間均勻分成 $n$ 等分, 再用三種不同積分法來估算積分值. 下表列出不同積分法在不同區間數所得之值與實際值之間的絕對誤差.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n\Method&lt;/th&gt;
&lt;th&gt;Midpoint&lt;/th&gt;
&lt;th&gt;Trapezoidal&lt;/th&gt;
&lt;th&gt;Simpson&amp;rsquo;s&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;3.91e-3&lt;/td&gt;
&lt;td&gt;7.83e-3&lt;/td&gt;
&lt;td&gt;2.08e-5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;3.92e-5&lt;/td&gt;
&lt;td&gt;7.83e-5&lt;/td&gt;
&lt;td&gt;2.09e-9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;3.92e-7&lt;/td&gt;
&lt;td&gt;7.83e-7&lt;/td&gt;
&lt;td&gt;2.10e-13&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我們可以看到, 中點以及梯形法誤差皆是以 $O(n^{-2})$ 來下降, 也就是點數變十倍時誤差會降一百倍, 而辛普森法則是 $O(n^{-4})$.&lt;/p&gt;
&lt;p&gt;接著我們試試看用高斯積分來做, 這裡我們就不分小區間, 直接做整個 $[-1, 1]$ 區間. 多個點的高斯積分的公式可在 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Gaussian_quadrature&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt; 找到. 我們將 $m$-point 高斯積分所得之值與實際值之間的絕對誤差列於下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;m\Method&lt;/th&gt;
&lt;th&gt;Gaussian quadrature rule&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;7.71e-3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6.55e-5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.95e-7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;8.25e-10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1.56e-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2.66e-15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4.44e-16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到我們用 8 個點就可以將這個積分準確估計到誤差接近機器的捨入誤差 (rounding error).&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;延伸閱讀: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_2&#34;&gt;以內差多項式來做數值積分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;延伸閱讀: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_numerical_integration_3&#34;&gt;高斯積分&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>不定積分的悖論？</title>
      <link>https://teshenglin.github.io/post/2019_indef_integ/</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_indef_integ/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這幾天有個朋友問我一個關於不定積分的問題, 看起來很詭異. 我們一起來看看.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們以分部積分(integration by part)來求 $\tan$ 的不定積分 $\int \tan(x)\ dx$.&lt;/p&gt;
&lt;p&gt;首先我們知道 $\tan(x) = \frac{\sin(x)}{\cos(x)}$, 接著我們來做分部積分, 假設
$$
u = \frac{1}{\cos(x)}, \quad dv = \sin(x)dx.
$$
因此我們知道
$$
du = \frac{\sin(x)}{\cos^2(x)}dx, \quad v = -\cos(x).
$$
根據分部積分公式我們得到
$$
\int \tan(x)\ dx  = \frac{1}{\cos(x)}\left(-\cos(x)\right) - \int (-\cos(x))\frac{\sin(x)}{\cos^2(x)}dx
= -1 + \int\tan(x)\ dx.
$$
等號最左邊跟最右邊都有 $\int\tan(x)\ dx$, 同時減掉我們就得到 $0 = -1$. 太神奇了!!&lt;/p&gt;
&lt;p&gt;所以問題是, 這中間究竟哪裏有問題？&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;不定積分 (indefinite integral) 以及反導函數 (antiderivative function) 是在講同一個東西. 可見 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Antiderivative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我們最熟悉的數學符號, &amp;lsquo;等號&amp;rsquo;, &amp;lsquo;$=$&amp;rsquo;, 其實在不同的情況下有不同的定義. 雖然都是要表達相等的意思, 不過究竟是怎樣的相等還是有一些小細節需要注意的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;在不定積分中的等號究竟是什麼意思? 我們都知道 $\cos$ 的反導函數是 $\sin$, 寫成不定積分就是&lt;/p&gt;
&lt;p&gt;$$
\int\cos(x)\ dx = \sin(x)+c,
$$
其中 $c$ 是任意常數. 那上列這個式子的等號是什麼意思?&lt;/p&gt;
&lt;p&gt;我們都知道 $\sin(x)$ 加上任意常數, 其微分都會是 $\cos(x)$, 所以我們才有這個式子. 也就是說, 上面這個等號就是這個意思!!&lt;/p&gt;
&lt;p&gt;再說清楚一點, 當我們寫 $\int f(x)\ dx = F(x)$ 時意思就是 $F&#39;(x) = f(x)$.&lt;/p&gt;
&lt;p&gt;所以回到原文最後一個式子, 我把它在這裡重列一次
$$
\int \tan(x)\ dx  = -1 + \int\tan(x)\ dx.
$$
如果我們把 $\tan$ 的反導函數稱為 $F$, 也就是 $\int\tan(x)\ dx = F(x)$. 那這個式子可以改寫成
$$
\int \tan(x)\ dx  = -1 + F(x).
$$
我們知道這個式子也是對的因為 $(F(x)-1)&#39; = \tan(x)$. 所以從這個角度來說, 這整個式子就都沒有問題了.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;所以最後一個問題是, 我們可以把東西減掉嗎? 舉例來說,
$$
\begin{aligned}
\int\cos(x)\ dx &amp;amp;= \sin(x)+1, \\\&lt;br&gt;
\int\cos(x)\ dx &amp;amp;= \sin(x).
\end{aligned}
$$
兩式一減我們就得到 $0=1$ 了!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BUT,&lt;/strong&gt; 事實上這樣寫是錯的. 再小心一點做的話你會發現兩式相減我們應該是得到
$$
\int 0\ dx = 1.
$$
從這裡來看的話, $1$ 的微分是 $0$, 那就完全沒有問題了.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Chaotic swimming of phoretic self-propelled particles</title>
      <link>https://teshenglin.github.io/publication/19_prl_hlrm/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/19_prl_hlrm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sec.3.4 - Where should a pilot start descent?</title>
      <link>https://teshenglin.github.io/post/2019_cal_s3p4/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_cal_s3p4/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Applied Project in Sec.3.4, Calculus by Stewart&lt;br&gt;
Chinese version: 
&lt;a href=&#34;https://teshenglin.github.io/post/2020_cal_s3p4_ch&#34;&gt;飛行員應該何時開始下降高度?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/ImsaT.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;An approach path for an aircraft landing is shown in the figure and satisfies the following conditions:&lt;/p&gt;
&lt;p&gt;(i) The cruising altitude is $h$ when descent starts at a horizontal distance $\ell$ from touchdown at the origin.&lt;/p&gt;
&lt;p&gt;(ii) The pilot must maintain a constant horizontal speed $v$ throughout descent.&lt;/p&gt;
&lt;p&gt;(iii) The absolute value of the vertical acceleration should not exceed a
constant $k$ (which is much less than the acceleration due to gravity)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 1:&lt;/strong&gt; Find a cubic polynomial $P(x) = ax^3 + bx^2 + cx + d$ that satisfies condition (i) by imposing suitable conditions on $P(x)$ and $P’(x)$ at the start of descent and at touchdown.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;$$
P(x) = −\frac{2h}{\ell^3}x^3 + \frac{3h}{\ell^2}x^2.
$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 2:&lt;/strong&gt; Use conditions (ii) and (iii) to show that $\frac{6hv^2}{\ell^2}\le k$.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 3:&lt;/strong&gt; Suppose that an airline decides not to allow vertical acceleration of a plane to exceed $k = 860$(mi/h$^2$). If the cruising altitude of a plane is $35,000$(ft) and the speed is $300$(mi/h), how far away from the airport should the pilot start descent?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The pilot should start to decend when the plane is $64.511$(mi) away from the airport.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt; Graph the approach path if the conditions stated in Problem 3 are satisfied.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Example code in julia&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;
h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6.628&lt;/span&gt;;
l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;65&lt;/span&gt;;
N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
dx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;N;
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;N; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dx&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x;
P &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
plot(x, P, lw&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, xlabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;, ylabel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;y&amp;#34;&lt;/span&gt;, title&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;approach path&amp;#34;&lt;/span&gt;, legend&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2019.jpg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2019.jpg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Fixed point iteration</title>
      <link>https://teshenglin.github.io/post/2019_fixed_point/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_fixed_point/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們介紹固定點迭代法 (Fixed point iteration)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們介紹什麼是固定點 (Fixed point)&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;definition-fixed-point&#34;&gt;Definition: Fixed point&lt;/h2&gt;
&lt;p&gt;A fixed point of a function $f(x)$ is a number $c$ in its domain such that $f(c)=c$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以簡單來說, 把固定點這個數字丟進函數後會得到同樣的一個數字. 所以稱之為固定點.&lt;/p&gt;
&lt;p&gt;那固定點重要性其一是在數值計算上有一種迭代方式叫做固定點迭代(Fixed point iteration). 假設我們想要求某個函數的固定點, 也就是滿足 $c=f(c )$ 的這些 $c$, 那我們可以定義一個迭代式
$$
x_{n+1} = f(x_n).
$$&lt;/p&gt;
&lt;p&gt;如果夠幸運的, $\{x_{n}\}$ 這串數字收斂了, 那把它收斂到的數字稱為 $\bar{c}$ 我們就有 $\bar{c}=f(\bar{c})$, 也就是固定點.&lt;/p&gt;
&lt;p&gt;舉個例子來說, 假設我們想要解 $x=\cos(x)$ 這個方程式, 那我們可以定義一個固定點迭代為
$$
x_{n+1} = \cos(x_n).
$$&lt;/p&gt;
&lt;p&gt;這樣的話如果數列收斂, $\{x_{n}\}\to \bar{x}$, 那我們就有 $\bar{x}=\cos(\bar{x})$, 那就解出來了!!&lt;/p&gt;
&lt;p&gt;不過這裡有兩個問題.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;為什麼這個數列會收斂?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原方程式的固定點迭代其實有無窮多種改寫方式, 例如也可寫為 $x_{n+1} = \cos^{-1}(x_n)$. 如果收斂的話一樣會是原方程式的解. 那, 哪種改寫方式最好呢?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我們有以下這個定理&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem&#34;&gt;Theorem&lt;/h2&gt;
&lt;p&gt;If $f:[a, b]\to [a,b]$ is a differentiable function such that
$$ |f&#39;(x)|\leq \alpha&amp;lt;1, \quad \forall x\in[a, b],$$
then $f$ has exactly one fixed point $c$ and the fixed point iteration converges to $c$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個證明很簡單.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;proof&#34;&gt;Proof&lt;/h3&gt;
&lt;h3 id=&#34;sketch-not-complete-please-full-in-the-details-by-yourself&#34;&gt;(Sketch, not complete, please full-in the details by yourself)&lt;/h3&gt;
&lt;h4 id=&#34;existence&#34;&gt;existence&lt;/h4&gt;
&lt;p&gt;Since the domain and the range of $f$ are both $[a, b]$, by Intermediate Value Theorem, there exists $c$ such that $c=f(c ).$&lt;/p&gt;
&lt;h4 id=&#34;uniqueness&#34;&gt;uniqueness&lt;/h4&gt;
&lt;p&gt;If there exits another fixed point $\bar{c}$, $\bar{c}\ne c$, such that $\bar{c}=f(\bar{c} )$, then according to Mean Value Theorem(MVT), there exits $z$ between $c$ and $\bar{c}$ such that $$f&#39;(z) = \frac{f(c ) - f(\bar{c})}{c-\bar{c}}=\frac{c - \bar{c}}{c-\bar{c}} = 1,$$ which violate the assumption that $|f&#39;|\leq \alpha&amp;lt;1$. So the fixed point is unique.&lt;/p&gt;
&lt;h4 id=&#34;convergence-of-fixed-point-iteration&#34;&gt;convergence of fixed point iteration&lt;/h4&gt;
&lt;p&gt;Based on MVT we have
$$|x_{n+1} - c| = |f(x_n) - f(c )| = |f&#39;(c_i)(x_n-c)|\leq\alpha |x_n-c|\leq\alpha^n|x_1-c|\to 0.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以如果在函數固定點 $c$ 的微分小於 $1$, 那就存在一個包含 $c$ 的小區間使得函數的微分都在這區間內小於 $1$, 那根據這定理固定點迭代就會收斂.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;固定點迭代是求根問題(root finding problems)中很重要的一種迭代方式. 舉個例子來說, 假設我們想要找 $g(x)$ 這個函數的根, 那我們可以定義
$$
f(x) = x + g(x).
$$
這樣的話 $f$ 的固定點就會是 $g$ 的根了. 不過這種最簡單的改寫方式完全不保證會收斂.&lt;/p&gt;
&lt;p&gt;那要如何改寫才會比較好呢? 其中一個最有名的就是牛頓法 (Newton&amp;rsquo;s method):&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;newtons-iteration&#34;&gt;Newton&amp;rsquo;s iteration&lt;/h2&gt;
&lt;p&gt;$$x_{n+1} = x_n - \frac{g(x_n)}{g&#39;(x_n)}.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們可以定義 $f(x) = x - \frac{g(x)}{g&#39;(x)}$, 這樣上面這個式子就是個固定點迭代. 接著我們可以發現, 如果 $c$ 是 $g$ 函數的根, 也就是 $g(c )=0$, 那 $f&#39;(c ) = 0$. 所以根據上面的定理就存在某個包含 $c$ 的小區間使得迭代會收斂.&lt;/p&gt;
&lt;p&gt;更進一步我們可以利用泰勒展開式(Taylor&amp;rsquo;s series expansion) 來證明牛頓法事實上有二次收斂,
$$
|x_{n+1} - c| \approx \beta |x_n-c|^2.
$$
這個證明我們這邊就先略過不寫. 不過接著我們來看一下牛頓法究竟有多快.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;依之前的例子我們想要解 $x=\cos(x)$, $x\in[0, \pi]$. 最簡單的固定點迭代為
$$
x_{n+1} = \cos(x_n),
$$
也就是求 $g(x) = \cos(x)-x$ 的根. 我們以 $x_0=1$ 當初始值, 發現需要 $80$ 個迭代才能使誤差在 $10^{-14}$ 之下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    x_new= 0.5403023058681398		error= 0.31725090997825367
    x_new= 0.8575532158463934		error= 0.2032634253486143
    x_new= 0.6542897904977791		error= 0.13919056824478648
    x_new= 0.7934803587425656		error= 0.0921115851198091
    x_new= 0.7013687736227565		error= 0.06259090927789768
    ⋮
    x_new= 0.7390851332151851		error= 4.0967229608668276e-14
    x_new= 0.7390851332151441		error= 2.7644553313166398e-14
    x_new= 0.7390851332151718		error= 1.865174681370263e-14
    x_new= 0.7390851332151531		error= 1.2545520178264269e-14
    x_new= 0.7390851332151657		error= 8.43769498715119e-15
    Total number of iterations=80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若是使用牛頓法迭代則迭代式為
$$
x_{n+1} = x_n + \frac{cos(x_n)- x_n}{\sin(x_n)+1}.
$$
一樣以 $x_0=1$ 當初始值, 發現只需要 $4$ 個迭代就能使誤差在 $10^{-14}$ 之下. 比上個例子快上許多.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    x_new= 0.7503638678402439		error= 0.018923073822117442
    x_new= 0.7391128909113617		error= 4.6455898990771516e-5
    x_new= 0.739085133385284		error= 2.847205804457076e-10
    x_new= 0.7390851332151607		error= 0.0
    Total number of iterations=4
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;最後總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定點迭代要收斂, 至少在固定點的微分值必須比 $1$ 小.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要取迭代函數, 如果知道如何對函數微分, 以牛頓法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Newton%27s_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Newton&amp;rsquo;s method&lt;/a&gt; 來取通常會有不錯的效果.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若無法得知微分函數, 可以用數值微分來逼近真實微分, 這樣會得到割線法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Secant_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;secant method&lt;/a&gt;, 收斂速度比牛頓法慢一點點.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定點定理保證在區間裡任意取點當初使迭代都會收斂, 不過要滿足定理的條件很強, 實務上不容易做到.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如牛頓法, 我們能證明一定存在某個區間滿足固定點定理, 不過實際上這個區間有多大並不知道. 因此一般在討論牛頓法時都會要求初始值要離實際要求的固定點&amp;quot;夠近&amp;quot;. 至於&amp;quot;夠近&amp;quot;什麼意思就只能用嘗試的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由於牛頓法不保證收斂, 因此實務上要求根時會與一些保證收斂的方法, 如二分逼進法 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Bisection_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;(bisection method)&lt;/a&gt; 來合作. 如 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Brent%27s_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brent-Dekker method&lt;/a&gt;. 這樣既能保證收斂, 又兼有收斂快速的優點.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>git 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_git/</link>
      <pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_git/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 git 這個分散式版本控制軟體. 有人可能會聽過 &amp;lsquo;github&amp;rsquo;. 不過這邊要提醒一下 git 跟 github 是不一樣的兩件事. 簡單的說 git 是一個軟體, 而 github 則是提供線上 git 服務的公司.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-教學網頁&#34;&gt;git 教學網頁&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我非常推薦 
&lt;a href=&#34;https://gitbook.tw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;為你自己學 Git&lt;/a&gt;, 尤其務必熟讀以下三章, 才算是對 git 有最基本的認識.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;二、Git Windows/Mac/Linux 環境安裝&lt;/li&gt;
&lt;li&gt;四、設定 Git&lt;/li&gt;
&lt;li&gt;五、開始使用 Git&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.slideshare.net/appleboy/introduction-to-git-11436559&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;快速上手 git 版本控制, slideshare&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git-基本指令-terminal-終端機&#34;&gt;git 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;做完某個段落後, 將檔案 XXX 移進暫存區&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git add XXX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是將剛剛所有編輯過的檔案一起移
進暫存區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著將暫存區的檔案移至儲存褲 (repo), 並且記註做了什麼事&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;我做了XXX&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;支援-git-的網站&#34;&gt;支援 git 的網站&lt;/h2&gt;
&lt;h3 id=&#34;github&#34;&gt;github&lt;/h3&gt;
&lt;p&gt;如同我最初說的, github 是一個支援 git 的網站, 可以讓你擺放你程式的原始碼, 基本服務是免費的, 有一些更進階的功能則需要付費.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://progressbar.tw/posts/3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;開始使用 GitHub， 註冊與建立repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bitcuket&#34;&gt;bitcuket&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;也可以使用 
&lt;a href=&#34;https://bitbucket.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bitcuket&lt;/a&gt;, 一樣是個讓你把原始碼放上雲端的免費服務.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;git---github-基本指令-terminal-終端機&#34;&gt;git &amp;lt;-&amp;gt; github 基本指令 (terminal 終端機):&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;丟上雲端 (github 或 bitbucket)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;從雲端下載最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;簡單工作示意圖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD;
  A[工作資料夾]--&amp;gt;|add| B;
  B(本機 local 暫存區)--&amp;gt;|commit| C;
  D--&amp;gt;|pull| C;
  C(本機 local repo)--&amp;gt;|push| D{雲端 repo};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;git-觀念釐清&#34;&gt;git 觀念釐清&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://goo.gl/gAvBBp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git fetch 與 git pull 的區別&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Julia 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_julia/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_julia/</guid>
      <description>&lt;p&gt;延伸閱讀: Julia 學習筆記 -

&lt;a href=&#34;https://teshenglin.github.io/post/2019_julia&#34;&gt;簡介&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_plots&#34;&gt;畫圖&lt;/a&gt;,

&lt;a href=&#34;https://teshenglin.github.io/post/2020_julia_timing&#34;&gt;計時&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 julia 這個程式語言. 這是一個非常新的語言, 在 2009 年才問世, 遠比 1990 年出生的 python 來的年輕許多. 不過由於它又&lt;em&gt;&lt;strong&gt;快&lt;/strong&gt;&lt;/em&gt;又&lt;em&gt;&lt;strong&gt;簡單&lt;/strong&gt;&lt;/em&gt;, 又&lt;em&gt;&lt;strong&gt;不用錢&lt;/strong&gt;&lt;/em&gt;, 使得目前有越來越多人開始使用這個新語言. 相信未來會更加普及.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-安裝&#34;&gt;Julia 安裝&lt;/h2&gt;
&lt;p&gt;在 
&lt;a href=&#34;https://julialang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 官方網站&lt;/a&gt; 上可以下載各系統平台的安裝包裹. 下載安裝後即可運行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Julia 安裝教學影片可參考 
&lt;a href=&#34;https://youtu.be/v7XeveI19CM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia課程環境簡介 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只想試用一下的話可以試試 
&lt;a href=&#34;https://repl.it/languages/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repl.it&lt;/a&gt; 這個線上編輯器. 它可以讓你在線上編輯並執行一些簡單的 julia 程式.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 julia 主程式外, 我也建議加裝 &lt;code&gt;Jupyter notebook&lt;/code&gt;(或 &lt;code&gt;Jupyter lab&lt;/code&gt;) 以及 &lt;code&gt;Atom&lt;/code&gt;. 讓你 coding 更方便.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;julia-基本簡介&#34;&gt;Julia 基本簡介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查詢版本資訊&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; versioninfo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;套件(package)管理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會進入套件管理系統
```julia
pkg&amp;gt;
```

查詢已安裝套件
```julia
pkg&amp;gt; status
```

更新套件
```julia
pkg&amp;gt; update
```

跳出系統請按鍵盤上的 `刪除鍵`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢指令(如matlab中的help)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;然後就會變成查詢的視窗
```julia
help?&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jupyter-notebook-安裝&#34;&gt;Jupyter notebook 安裝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Jupyter notebook 是個互動式筆記本, 很容易可以逐行執行並且做到資料視覺化, 並且支援多種主流的直譯語言像是 &lt;code&gt;Julia&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;. 有一說是 jupyter 這個字事實上就是由 julia, python 以及 R 這三個字組合而成.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 有兩種方式. 第一種是直接由 julia 安裝. 步驟如下&lt;/p&gt;
&lt;p&gt;在 julia 輸入 &lt;code&gt;]&lt;/code&gt; 進入套件管理命令提示. 然後會長得像這樣&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著輸入 &lt;code&gt;status&lt;/code&gt; 可以看到現在已經安裝的套件.&lt;/p&gt;
&lt;p&gt;我們要安裝 IJulia, 所以輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;pkg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; add IJulia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安裝完後要退出套件管理則是 BackSpace 鍵或是 Ctrl+C 都可以.&lt;/p&gt;
&lt;p&gt;要打開 notebook 需要退出套件管理, 並在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; notebook()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter notebook 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/@jamescchuang/%e5%af%a6%e6%88%b0%e5%ae%89%e8%a3%9d%e5%8f%8a%e5%bb%ba%e7%bd%ae-julia-%e9%96%8b%e7%99%bc%e7%92%b0%e5%a2%83-6dc8c0d14c2a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安裝及建置 Julia 開發環境實戰教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前已經有 jupyter notebook 的升級版, 稱為 jupyter lab. 在 julia 命令提示字元下輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; IJulia
julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; jupyterlab()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣 Jupyter lab 就會在你的瀏覽器中打開.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Jupyter notebook 的第二種方式則是透過 anaconda. 先裝完 julia 後下載 anaconda 安裝, 即可快樂使用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若還是有不清楚的地方請見 
&lt;a href=&#34;https://medium.com/datainpoint/jupyter-kernels-3151a6408bab&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打造 Jupyter Notebook 資料科學環境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;在-atom-中操作-julia&#34;&gt;在 Atom 中操作 Julia&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果平常會寫各式程式語言, 可以考慮加安裝 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要在 Atom 裡操作 Julia 簡單說就是要裝以下幾個 package:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;julia-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;language-julia&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uber juno&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就可以用了!!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1550260279.html?fbclid=IwAR3bBrHTvjF3Y5TJrZsElriJfO2fbyoM751XMfjLYOE0TLl31JA3LSpe8KQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Atom 中操作 Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-基本簡介與語法教學&#34;&gt;Julia 基本簡介與語法教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/Introducing_Julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia: wikibook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://learnxinyminutes.com/docs/julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Learn X in Y minutes, where X=Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Julia Taiwan發起人杜岳華的 slideshare: 
&lt;a href=&#34;https://www.slideshare.net/ssuserd6984b/coscup-introduction-to-julia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to Julia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://hackmd.io/@7WeiUEuJSBKp7WCRouAWVg/r106dSpkb/%2FIwZgbAHApgnARgMwLQAYAmKxICxQMZpICGGATEjHtgOwwwrRwCsEQA%3D%3D?type=book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia 中文官方文件草稿&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;youtube-上的-julia-超新手教學&#34;&gt;Youtube 上的 Julia 超新手教學&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/JuliaLangTW/julia_tutorials_for_dummy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之一 on github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/zzrctueO6JY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之二 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://youtu.be/W7R5dxGrxlk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Taiwan 超新手教學之三 on Youtube&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Markdown 學習筆記</title>
      <link>https://teshenglin.github.io/post/2019_markdown/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_markdown/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 markdown 這個語言. 它非常簡單易學, 有時我們只是想打個小文件, 就幾頁而已不想要開 latex 或是 word 之類的文字編輯軟體, 這時候就非常適合以 markdown 來編寫. 另外其實越來越多的程式語言也支援 markdown 編寫. 比如這個網頁裡的 post 就都是以 markdown 做的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-安裝&#34;&gt;Markdown 安裝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我自己是使用 mac, 我用的是 
&lt;a href=&#34;https://macdown.uranusjr.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MacDown&lt;/a&gt; 這個軟體.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安裝完 &lt;em&gt;Macdown&lt;/em&gt; 之後需要到 &lt;code&gt;Preference/Rendering&lt;/code&gt; 中標選 &lt;em&gt;tex-like math&lt;/em&gt; 以及他下一行的 &lt;em&gt;use dollar sign as xxxx&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近我用的是 
&lt;a href=&#34;https://typora.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora&lt;/a&gt; 這個軟體, 它支援各作業系統, 不管 mac 或 windows 都可以用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typora 主要特色是他&lt;strong&gt;所見即所得&lt;/strong&gt;, 所以邊寫邊看自己打出來的版面怎樣. 比較乾淨, 不需要將畫面切分成左右兩半一半程式一半預覽. 學起來也很簡單.&lt;/li&gt;
&lt;li&gt;安裝完 &lt;em&gt;Typora&lt;/em&gt; 之後到 &lt;code&gt;Preference/Markdown&lt;/code&gt; 中標選 &lt;em&gt;inline math&lt;/em&gt;, 才可使用 tex 語法.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://free.com.tw/typora/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Typora 免費極簡 Markdown 編輯器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.itread01.com/content/1546144745.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown神器 -Typora使用教程筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果平常會寫各式程式語言, 也可以考慮使用 
&lt;a href=&#34;https://atom.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atom&lt;/a&gt; 編輯器. 它是 github 開發的免費編輯器, 不管 Mac, windows 或是 Linux 都有支援. 我自己也有使用 atom 來寫 &lt;code&gt;julia&lt;/code&gt;, &lt;code&gt;fortran&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果連安裝都不想的話我推薦 
&lt;a href=&#34;http://hackmd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hackmd&lt;/a&gt; 這個線上編輯器. 這個還能多人共筆編輯, 適合寫作業交作業.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://notes.dosilovic.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown notes&lt;/a&gt; . 它支援線上即時編寫, 可以線上存檔, 也可以下載成 markdown 以及 PDF.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一個線上編輯器: 
&lt;a href=&#34;https://upmath.me&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;upmath&lt;/a&gt;, 一樣支援線上即時編寫, 可以存成 html 直接幫你產生網頁.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過我要稍微說明一下, 不管使用哪種編輯器, markdown 主要語法都差不多, 只是在輸出上會有一些細微的差異. 這點就要自己使用後才會感受得到差別.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法教學&#34;&gt;Markdown 語法教學&lt;/h2&gt;
&lt;p&gt;以下列舉一些 markdown 教學的線上資源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://commonmark.org/help/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1分鐘學會 Markdown&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://wastemobile.gitbooks.io/gitbook-chinese/content/format/markdown.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Markdown gitbook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://tiida54.github.io/2018/01/03/3%e5%88%86%e9%90%98%e5%ad%b8%e6%9c%83Markdown%e5%b8%b8%e7%94%a8%e8%aa%9e%e6%b3%95/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3分鐘學會 Markdown 常用語法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何使用 Markdown 來撰寫 Docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;markdown 有一個很酷的語法是可以做 diagram, 在 typora 這個編輯器有支援: 
&lt;a href=&#34;https://support.typora.io/Draw-Diagrams-With-Markdown/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Draw Diagrams With Markdown&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不過要稍微注意一下, 不要直接複製貼上介紹網頁裡的 diagram 程式到 typora 裡, 會跑不出來. 正確做法是, 比如說要做以下這個 sequence diagram, 那在 typora 裡打 ```sequence, 然後就會跑出一個框框讓你把程式貼進去. 程式貼入後圖就跑出來了.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我自己所使用的 macdown 也號稱有支援, 不過其實只有某些特別的版本能用而已, 有點可惜.&lt;/p&gt;
&lt;p&gt;如果是用 atom 的話則是要安裝 
&lt;a href=&#34;https://shd101wyy.github.io/markdown-preview-enhanced/#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markdown-preview-enhanced&lt;/a&gt; 這個 package. 我自己試過, 支援各種 diagram, 非常棒.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;markdown-語法補充&#34;&gt;Markdown 語法補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 markdown 文字間插入空白無法單純使用空白鍵, 在 mac 裡是 option+space, 其他可見 
&lt;a href=&#34;https://stackoverflow.com/a/54174466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Use non-breaking spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 markdown 裡將文字置中只能用 html 語法 
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Centered Text&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;latex-語法教學&#34;&gt;Latex 語法教學&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 一個很重要功能(至少對我而言)就是它支援 $\LaTeX$ 語法. Latex 數學排版系統是科學界中非常重要的一種系統. 它使得研究員在撰寫學術文章時能輕易地做好排版. 尤其是科學文章中常有大量數學符號, 這些符號的編排以及顯示是 Latex 系統一大強項.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果只是要以 Markdown 來寫一些簡單包含數學符號的文章, 還不需要學整個 Latex 系統. 我們只要會一些語法就好. 以下整理一些線上資源供參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://walkccc.github.io/blog/2018/02/17/Techniques/latex-syntax/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LaTeX 語法整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;List of LaTeX mathematical symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.overleaf.com/learn/latex/Integrals,_sums_and_limits&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Integrals, sums and limits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikibooks.org/wiki/LaTeX/Mathematics#Matrices_and_arrays&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;matrices and arrays&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有介於兩個 &lt;code&gt;$&lt;/code&gt; 字元之間的內容將會被視為 TeX 數學公式處理。開頭的 &lt;code&gt;$&lt;/code&gt; 右側必須立刻接上任意文字，而結尾 &lt;code&gt;$&lt;/code&gt; 的左側同樣也必須緊挨著文字。如果使用兩個&lt;code&gt;$$&lt;/code&gt;則會將數學公式換行居中. 例如以下 markdown 程式碼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$$\frac{\sin(x)}{x}$$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;顯示為
$$\frac{\sin(x)}{x}$$&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Maximum and minimum of a function</title>
      <link>https://teshenglin.github.io/post/2019_maxmin/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_maxmin/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要討論一個函數的最大值以及最小值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我們有極值定理&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;theorem-extreme-value-theorem&#34;&gt;Theorem: Extreme value theorem&lt;/h2&gt;
&lt;p&gt;If $f$ is a real-valued continuous function on the closed interval $[a,b]$, then $f$ must attain a maximum and a minimum.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以對於定義在封閉區間的連續函數, 必定會有極值. 接下來我們看一下實際上我們怎麼把極值找出來.&lt;/p&gt;
&lt;p&gt;在微積分課本裡有所謂的封閉區間法, 如下:&lt;/p&gt;
&lt;h2 id=&#34;the-closed-interval-method&#34;&gt;The closed interval method&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD;
  B[f is `continuous` on a `closed interval`]--&amp;gt;A;
  B--&amp;gt;C;
  A[Determine the critical points]--&amp;gt;|f&#39;=0| D(The largest value at these points is the abs. max. and the smallest value is the abs. min.);
  A--&amp;gt;|f&#39; not exists| D;
  C[Determine the end points]--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個方法的原理跟做法都很簡單, 我這邊就不多做說明.&lt;/p&gt;
&lt;p&gt;不過我要做一些補充. 事實上這個方法要能用還有一個很重要的假設是&lt;code&gt;假設這個函數只在有限個地方微分不存在&lt;/code&gt;. 如果一個函數在無窮多地方微分不存在, 雖然最大值還會是 &amp;ldquo;微分等於 0&amp;rdquo;, &amp;ldquo;微分不存在&amp;rdquo;, &amp;ldquo;端點&amp;rdquo; 這些地方的函數值中找最大的. 不過實作上會找不完. 所以等於是沒有用.&lt;/p&gt;
&lt;p&gt;當然這樣的假設看起來很正常, 難道有函數是連續的, 但是在無窮多地方微分不存在嗎? 很不幸的也很幸運的, 真的有! 其中有一個很特別的函數叫做 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Weierstrass_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Weierstrass function&lt;/a&gt;. 它是定義在實數軸上的函數, 在每個點都連續, 但是同時在任何一個點微分都不存在. 所以如果套用 the closed interval method 在這函數上會發現所有的點都是 critical point, 所以套用之後還是必須要找出所有點中函數值最大的. 完全沒有簡化到.&lt;/p&gt;
&lt;h3 id=&#34;question-1-是否存在連續-但是在每個點微分都等於-0-的函數&#34;&gt;Question 1: 是否存在連續, 但是在每個點微分都等於 0 的函數?&lt;/h3&gt;
&lt;p&gt;當然有! 常數函數就是. 不過這個很好 check 最大最小值所以沒什麼問題.&lt;/p&gt;
&lt;h3 id=&#34;question-2-是否存在連續-但是在每個點微分都等於-0-的非常數函數non-constant-function&#34;&gt;Question 2: 是否存在連續, 但是在每個點微分都等於 0 的非常數函數(non-constant function)?&lt;/h3&gt;
&lt;p&gt;I will leave it as an exercise.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最後再補充一點, 函數在某個點連續但是微分不存在有幾種情形:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尖點. 例如 $f(x) = |x|$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直切線. 例如 $f(x) = \sqrt[3]{x}$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分定義中的極限不存在. 例如 $f(x) = x\sin(x)$ 在 $x=0$ 時.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Slant asymptotes</title>
      <link>https://teshenglin.github.io/post/2019_slant_asymp/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_slant_asymp/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹 slant asymptotes, 也就是所謂的斜漸近線.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;section-1-slant-asymptotes&#34;&gt;Section 1: slant asymptotes&lt;/h1&gt;
&lt;p&gt;斜漸近線定義如下:&lt;br&gt;
The line $y=mx+b$, $m\ne 0$, is called a slant asymptote of $f(x)$ if
$$
\lim_{x\to\infty} [f(x) - (mx+b)] = 0.
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 亦可將上列式子中改為 $x\to-\infty$. 滿足此條件的也是斜漸近線. 所以斜漸近線最多有兩條.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;section-11-長除法&#34;&gt;Section 1.1: 長除法&lt;/h2&gt;
&lt;p&gt;要求得斜漸近線的方法其中之一是長除法. 例如以下這個函數
$$
f(x) = \frac{4x^3-10x^2-11x+1}{x^2-3x}.
$$
將這個函數的分子與分母做長除法發現
$$
4x^3-10x^2-11x+1 = (4x+2)(x^2-3x) + (-5x+1),
$$
也就是說
$$
f(x) = (4x+2) + \frac{-5x+1}{x^2-3x}.
$$
這樣我們很明顯可以看出來
$$
\lim_{x\to\pm\infty} [f(x) - (4x+2)] = \lim_{x\to\pm\infty} \frac{-5x+1}{x^2-3x} = 0.
$$
所以 $y=4x+2$ 就是這個函數的斜漸近線.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;section-12-直接法&#34;&gt;Section 1.2: 直接法&lt;/h2&gt;
&lt;p&gt;不過如果遇到無法做長除法的函數, 以上的招數就失效了. 例如
$$
g(x) = \sqrt{x^2-1}+3,
$$
就無法以長除法來找斜漸近線.&lt;/p&gt;
&lt;p&gt;我們先觀察一下原本斜漸近線的定義, 然後很快就可以發現, 如果 $y=mx+b$ 是一條斜漸近線則我們有
$$
\lim_{x\to\infty} \frac{f(x)}{x} = m.
$$
所以透過以上這個式子我們可以找到斜漸近線中的第一個參數 $m$. 知道這個參數之後我們一樣再把原本定義改寫一下則有
$$
\lim_{x\to\infty} [f(x) - mx] = b.
$$
利用這個式子就可以找到斜漸近線中的第二個參數 $b$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我們以上面的 $g(x)$ 函數為例來找一下它的斜漸近線.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先第一步我們先看一下 $g(x)$ 在正負無窮遠的行為:
$$
\lim_{x\to\infty} g(x) = \infty, \quad \lim_{x\to-\infty} g(x) = \infty.
$$
發現它會趨近無窮大, 所以有機會有斜漸近線.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果趨近一個常數那就會得到橫漸近線 (horizontal asymptotes), 那就沒有斜漸近線.&lt;/li&gt;
&lt;li&gt;如果極限不是正負無窮大其中之一, 那也不可能會有斜漸近線.&lt;/li&gt;
&lt;li&gt;以上都是在講單邊 ($x\to\infty$, 或是 $x\to -\infty$), 有可能兩邊行為完全不一樣.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接著我們試著求出 $m$:
$$
\lim_{x\to\infty} \frac{g(x)}{x} = \lim_{x\to\infty} \frac{\sqrt{x^2-1}+3}{x} = 1.
$$
所以 $m=1$. 接著我們求解 $b$:
$$
\lim_{x\to\infty} [g(x) - mx] = \lim_{x\to\infty} \left[\sqrt{x^2-1}+3 - x\right] = 3.
$$
所以 $b=3$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同樣做法可以得到 $x\to -\infty$ 時我們有 $m=-1$, $b=3$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此我們得到 $g(x)$ 在正無窮遠處的斜漸近線為 $y=x+3$, 在負無窮遠處的斜漸近線為 $y=-x+3$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;section-13-summary&#34;&gt;Section 1.3: Summary&lt;/h2&gt;
&lt;p&gt;總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;斜漸近線可以用長除法或直接法求得.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過不管長除法或直接法都是求出斜漸近線的計算過程. 實際上不管用哪種方法做, 長除法, 直接法, 或是當你很有經驗時可以一眼看出來, 要&lt;strong&gt;證明&lt;/strong&gt;你所得到的直線是斜漸近線就是要驗證最初的定義是否正確. 也就是要驗證以下這個式子是對的:
$$
\lim_{x\to\infty} [f(x) - (mx+b)] = 0.
$$
如果是對的, 你就得到它了.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;section-14-final-remark&#34;&gt;Section 1.4: Final remark&lt;/h2&gt;
&lt;p&gt;在直接法理需要注意一下的是以下這個極限
$$
\lim_{x\to\infty} [f(x) - mx].
$$
這個極限一定要存在. 不然就沒有斜漸近線.&lt;/p&gt;
&lt;p&gt;有一個有名的錯誤敘述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(&lt;em&gt;這是錯的&lt;/em&gt;) 若
$$
\lim_{x\to\infty} \frac{f(x)}{x} = m,
$$
則 $f(x)$ 在 $x\to\infty$ 有一條斜漸近線.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一個簡單的反例是 $f(x)=x+\ln(x)$. 則
$$
\lim_{x\to\infty} \frac{f(x)}{x} = \lim_{x\to\infty} \frac{x + \ln(x)}{x} = 1.
$$
繼續找常數 $b$ 可以發現
$$
\lim_{x\to\infty} f(x)-x = \infty.
$$
所以沒有斜漸近線.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算微分</title>
      <link>https://teshenglin.github.io/post/2019_derivate_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_derivate_evaluate/</guid>
      <description>&lt;p&gt;前情提要: 
&lt;a href=&#34;https://teshenglin.github.io/post/2019_limit_evaluate&#34;&gt;用電腦算極限&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡我們要講的是用數值計算來算函數的微分值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;已知一個函數 $f(x)$ 在某個點 $a$ 的微分值定義是
$$
f&#39;(a) = \lim_{h\to 0} \frac{f(a+h)-f(a)}{h}.
$$&lt;/p&gt;
&lt;p&gt;我們用一個簡單的例子試試看. 假設我們想求 $f(x)=x^2$ 在 $x=\pi$ 的微分. 根據定義我們有&lt;/p&gt;
&lt;p&gt;$$
f&#39;(\pi) = \lim_{h\to 0} \frac{(\pi+h)^2-\pi^2}{h}.
$$&lt;/p&gt;
&lt;p&gt;接著我們將 $h$ 取靠近 $0$ 的 $11$ 的點並帶入上列這個式子試著來算其極限值. &lt;code&gt;Julia&lt;/code&gt; 程式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.01&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;); h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; h[&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((pi&lt;span style=&#34;color:#f92672&#34;&gt;.+&lt;/span&gt;h)&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt; pi&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;h;
hcat(h, fp, fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;結果如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$h$&lt;/th&gt;
&lt;th&gt;$f&#39;$&lt;/th&gt;
&lt;th&gt;$f&#39;-2\pi$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;6.29319&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.009&lt;/td&gt;
&lt;td&gt;6.29219&lt;/td&gt;
&lt;td&gt;0.009&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.008&lt;/td&gt;
&lt;td&gt;6.29119&lt;/td&gt;
&lt;td&gt;0.008&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.007&lt;/td&gt;
&lt;td&gt;6.29019&lt;/td&gt;
&lt;td&gt;0.007&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.006&lt;/td&gt;
&lt;td&gt;6.28919&lt;/td&gt;
&lt;td&gt;0.006&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.005&lt;/td&gt;
&lt;td&gt;6.28819&lt;/td&gt;
&lt;td&gt;0.005&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.004&lt;/td&gt;
&lt;td&gt;6.28719&lt;/td&gt;
&lt;td&gt;0.004&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;6.28619&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;td&gt;6.28519&lt;/td&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;6.28419&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上列數字最左邊是 $h$ 值, 中間為估計的微分值. 我們發現的確這個數字會越來越接近真實的解, 也就是 $2\pi$, 約等於 $6.283185307179586$. 最右邊為這個估算值與真實值 $2\pi$ 之間的差. 的確, 當 $h$ 越接近零, 這個估計出來的微分值離 $2\pi$ 的距離越來越小.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; 用數值計算微分能有多精確? 這個誤差能不能一直遞減下去?&lt;/p&gt;
&lt;p&gt;接著我們取更多靠近 $0$ 的點來計算微分的極限值, 我們列出其與真實值 $2\pi$ 之間的差, 並且把它畫出來.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;, length&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;); h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;h[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]);
fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((pi&lt;span style=&#34;color:#f92672&#34;&gt;.+&lt;/span&gt;h)&lt;span style=&#34;color:#f92672&#34;&gt;.^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt; pi&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;h;
hcat(h, fp, abs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;結果如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$h$&lt;/th&gt;
&lt;th&gt;$f&#39;$&lt;/th&gt;
&lt;th&gt;$abs(f&#39;-2\pi)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;6.38319&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;6.29319&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;6.28419&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0001&lt;/td&gt;
&lt;td&gt;6.28329&lt;/td&gt;
&lt;td&gt;0.0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-5&lt;/td&gt;
&lt;td&gt;6.2832&lt;/td&gt;
&lt;td&gt;9.99998e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-6&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;1.00006e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-7&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;9.5898e-8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-8&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;4.26073e-8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-9&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;2.20243e-7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-10&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;td&gt;1.9966e-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-11&lt;/td&gt;
&lt;td&gt;6.28315&lt;/td&gt;
&lt;td&gt;3.35305e-5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-12&lt;/td&gt;
&lt;td&gt;6.28297&lt;/td&gt;
&lt;td&gt;0.000211166&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-13&lt;/td&gt;
&lt;td&gt;6.27054&lt;/td&gt;
&lt;td&gt;0.0126457&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-14&lt;/td&gt;
&lt;td&gt;6.39488&lt;/td&gt;
&lt;td&gt;0.111699&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-15&lt;/td&gt;
&lt;td&gt;5.32907&lt;/td&gt;
&lt;td&gt;0.954115&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0e-16&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;6.28319&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;觀察最後一下發現, 當 $h$ 很小時微分竟然與真實質差更多, 更不準了!! 比如說當 $h=10^{-14}$ 時, 誤差竟然大到約是 $10^{-1}$.&lt;/p&gt;
&lt;p&gt;我們把它畫出來看看, &lt;code&gt;Julia&lt;/code&gt; code 如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Plots
plot(log10&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(h), log10&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(abs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(fp&lt;span style=&#34;color:#f92672&#34;&gt;.-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pi)),label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error&amp;#34;&lt;/span&gt;)
xlabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log10(h)&amp;#34;&lt;/span&gt;)
ylabel!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log10(Error)&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;發現雖然誤差在 $h$ 大的時候遞減, 不過當 $h$ 接近零的時候卻又遞增上去了.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/2019_derivative_evaulate_01.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/2019_derivative_evaulate_01.svg&#34; alt=&#34;&#34; width=&#34;600px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;那誤差最小值出現在什麼時候呢?&lt;/p&gt;
&lt;p&gt;我們發現當 當 $h=1.0*10^{-8}$ 時, 其估計出來的微分值離真實值誤差最小, 其誤差為 $4.26 *10^{-8}$.&lt;/p&gt;
&lt;p&gt;不過, WHY?? 為什麼誤差不會一直往下遞減? 其實這也是因為 &lt;strong&gt;捨入誤差(rounding-error)&lt;/strong&gt; 的關係.&lt;/p&gt;
&lt;p&gt;觀察一下我們的式子
$$
\frac{f(a+h)-f(a)}{h}
$$
當我們在用數值計算這個式子的時候其實並不完全是這樣子, 在分子應該會有捨入誤差在, 也就是說, 其實我們看到的數字應該是以下這個式子算出來的
$$
\frac{f(a+h)-f(a) + \epsilon}{h}
$$
其中的 $\epsilon$ 就是捨入誤差. 所以, 我們計算的時候會多出了 $\frac{\epsilon}{h}$ 這麼多.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;泰勒展開式&#34;&gt;泰勒展開式&lt;/h4&gt;
&lt;p&gt;再深一點來說, 我們可以利用泰勒展開式知道
$$
\frac{f(a+h)-f(a)}{h} = f&#39;(a) + \frac{h}{2}f&#39;&#39;(\xi), \quad a\leq \xi \leq a+h.
$$
這個式子告訴我們, 用這方式算微分誤差應該是 $\frac{h}{2}f&#39;&#39;(\xi) = O(h)$, 誤差會隨著 $h$ 減少而線性變小.&lt;/p&gt;
&lt;p&gt;數學上我們有以上這個等式, 而數值計算上則是有以下這個等式
$$
\frac{f(a+h)-f(a) + \epsilon}{h} = f&#39;(a) + \frac{h}{2}f&#39;&#39;(\xi) + \frac{\epsilon}{h}, \quad a\leq \xi \leq a+h.
$$
也就是說, 真正的誤差公式應該是
$$
\frac{h}{2}f&#39;&#39;(\xi) + \frac{\epsilon}{h},
$$
當 $h$ 非常小的時候 $\frac{\epsilon}{h}$ 這項就會變很大.&lt;/p&gt;
&lt;p&gt;比如說, 依我們之前所算的 $\epsilon\approx 10^{-16}$, 那當 $h=10^{-8}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-8}} = 10^{-8}$.&lt;/p&gt;
&lt;p&gt;而當 $h=10^{-14}$ 時, 算出來的數字會多了大約 $\frac{10^{-16}}{10^{-14}} = 10^{-2}$. 跟我們之前所發現的完全吻合!! 而這也就是為什麼當 $h$ 很靠近零的時候誤差會上升的原因.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;optimal-h&#34;&gt;Optimal $h$&lt;/h4&gt;
&lt;p&gt;那給定一個微分公式, 要怎麼知道 $h$ 能小到什麼程度呢? 一個簡單的感覺是這樣的, 由於誤差的第一項  $\frac{h}{2}f&#39;&#39;(\xi)$ 會隨著 $h$ 變小而變小, 第二項 $\frac{\epsilon}{h}$ 則會變大, 因此整體最小值約會發生在兩項交叉時, 也就是當
$$
h \sim \frac{\epsilon}{h},
$$
(由於我們不知道 $f&#39;&#39;(\xi)/2$ 是多少, 簡單起見設成 1). 上式稍微計算一下發現誤差最小值約發生在 $h=10^{-8}$, 誤差最小值則約為 $10^{-8}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;最後總結一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我們可以用數值計算來估計一個函數在某點的微分值
$$
f&#39;(a) \approx \frac{f(a+h)-f(a)}{h}.
$$
這樣的做法稱為&lt;strong&gt;有限差分法 (finite difference method)&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不過計算時 $h$ 值不能無限取小, 需考慮到捨入誤差的影響.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>用電腦算極限</title>
      <link>https://teshenglin.github.io/post/2019_limit_evaluate/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/post/2019_limit_evaluate/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;這裡我們要介紹如何用電腦算極限, 以及我們來看一下當我們真的這樣做的時候有可能會發生什麼問題. 我們以 $sinc$ 函數為例來做說明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;sinc-function&#34;&gt;sinc function&lt;/h3&gt;
&lt;p&gt;首先我們要介紹一個特別的函數, $sinc(x)$, 定義如下:
$$
sinc(x) = \frac{\sin(x)}{x}, \quad x\ne 0.
$$
很明顯可以看出來當 $x=0$ 的時候分母會等於零, 是一件壞事, 所以把 $x=0$ 這個點先拿掉.&lt;/p&gt;
&lt;p&gt;比較有趣的是我們可以把這個函數畫出來. 首先我們在 $[-20, 20]$ 這個區間取 $1000$ 個點, 然後帶入上面 $sinc$ 函數的定義, 再把所有點連起來看看.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; 有件事需要先說明一下, 由於我們是在 $[-20, 20]$ 這個區間均勻的取偶數個點, 所以會有 $500$ 個正數以及 $500$ 個負數, 重點是保證不會取到 $x=0$ 這個點, 所以沒有問題. 相反的, 如果取奇數個點就一定會取到 $x=0$, 那就會有函數無定義的問題了.&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_3_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_3_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;我們很輕易可以看出來, 連起來的線還蠻&amp;quot;光滑&amp;quot;的. 函數值在 $x=0$ 附近似乎不會趨近正無窮大或負無窮大, 也沒有跳躍的現象. 接著我們試著在 $x=0$ 附近放大一點看看, 我們在 $[-0.1, 0.1]$ 這個區間取 $1000$ 個點, 然後帶入 $sinc$ 函數的定義再把它畫出來:&lt;/p&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://teshenglin.github.io/post/figs/output_5_0.svg&#34; &gt;


  &lt;img src=&#34;https://teshenglin.github.io/post/figs/output_5_0.svg&#34; alt=&#34;&#34; width=&#34;400px&#34; &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;看起來真的很光滑!! 而且似乎當 $x$ 很靠近 $0$ 時, $sinc(x)$ 的值很靠近 $1$.&lt;/p&gt;
&lt;p&gt;接著我們取一個會越來越靠近 $0$ 的數列, 然後看一下當把 $sinc$ 函數在這個數列的點上取值時, 其值會不會越來越靠近 $1$.  我們取以下數列:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1.670170079024566e-5
 6.14421235332821e-6
 2.2603294069810542e-6
 8.315287191035679e-7
 3.059023205018258e-7
 1.1253517471925912e-7
 4.139937718785167e-8
 1.522997974471263e-8
 5.602796437537268e-9
 2.061153622438558e-9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算一下 $sinc$ 函數在這些點上面的值, 並觀察他的趨勢:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0.9999999999535089
 0.9999999999937081
 0.9999999999991485
 0.9999999999998848
 0.9999999999999845
 0.9999999999999979
 0.9999999999999997
 1.0
 1.0
 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赫然發現算到後來就等於 $1$ 了!! 所以我們發現&lt;/p&gt;
&lt;p&gt;$$
\lim_{x\to 0} sinc(x) = \lim_{x\to 0} \frac{\sin(x)}{x} = 1.
$$&lt;/p&gt;
&lt;p&gt;不過有一點點詭異的是, 在剛剛的計算裡我們最多也只是取到離 $0$ 很近的點而已, 但是算出來的結果卻是 $1$. 難道不只是 $sinc(0)=1$, 我們也有 $sinc(2.061153622438558 *10^{-9})=1$ 嗎?&lt;/p&gt;
&lt;p&gt;事實上並不是這樣. 電腦有所謂的捨入誤差(rounding error). 這是因為電腦需要用有限位數來表達無窮小數, 所以一定要捨棄後面的位數. 我們把算出來的數字減去 $1$ 看看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -4.649114426769074e-11
 -6.291855925155687e-12
 -8.515410598874951e-13
 -1.1524114995609125e-13
 -1.554312234475219e-14
 -2.1094237467877974e-15
 -3.3306690738754696e-16
  0.0
  0.0
  0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們可以發現這個數字最小可以到大約 $10^{-16}$, 之後就變成 $0$ 了. 也就是說我們目前用個這個程式語言其捨入誤差大約就是 $10^{-16}$.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;machine-epsilon&#34;&gt;machine epsilon&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一般我們會用 machine epsilon 這個數字來量化在電腦裡浮點運算的捨入誤差.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;machine epsilon 的定義是, 考慮正數$\epsilon$, 使得 $ 1+ \epsilon \ge 1$ 中最小的那個稱之為 machine epsilon. 當然以數學來看這個 machine epsilon 必須等於零. 不過在電腦裡並不是這樣.&lt;/p&gt;
&lt;p&gt;為了方便我們稍微改一下定義, 我們考慮 $\epsilon = 2^{-k}$ 這種形式, 然後 machine epsilon 一樣是使得 $ 1+ \epsilon \ge 1$ 中最小的那個. &lt;code&gt;julia&lt;/code&gt; 程式如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;
        s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s
        println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;k=&amp;#34;&lt;/span&gt;, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,  eps=&amp;#34;&lt;/span&gt;, s)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我的電腦上我發現 $\epsilon = 2^{-52} = 2.220446049250313e-16$.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k=52,  eps=2.220446049250313e-16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以的確捨入誤差大約是 $10^{-16}$ 這個等級.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary:&lt;/h3&gt;
&lt;p&gt;稍微總結一下目前我們看到的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我們用程式跑數值發現 $sinc(x\to 0)=1$, 所以我們可以定義 sinc 函數為
$$
sinc(x) =
\begin{cases}
\frac{\sin(x)}{x}, \quad x\ne 0, \\\&lt;br&gt;
1, \quad x=0.
\end{cases}
$$
在這樣的定義之下 $sinc$ 函數是個&lt;code&gt;連續函數&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多關於 $sinc$ 函數的性質可以參考 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Sinc_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt; 上的介紹.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在數值計算上有所謂的捨入誤差, 這是用有限位元來表達無限位數一定會有的差異.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用 machines epsilon 來量化捨入誤差.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Two-dimensional pulse dynamics and the formation of bound states on electrified falling films</title>
      <link>https://teshenglin.github.io/publication/18_jfm_btlk/</link>
      <pubDate>Fri, 27 Jul 2018 17:59:48 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/18_jfm_btlk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Continuation methods for time-periodic travelling-wave solutions to evolution equations</title>
      <link>https://teshenglin.github.io/publication/18_aml_ltbk/</link>
      <pubDate>Wed, 27 Jun 2018 17:59:41 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/18_aml_ltbk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Bifurcation analysis of the behavior of partially wetting liquids on a rotating cylinder</title>
      <link>https://teshenglin.github.io/publication/16_pof_lrtt/</link>
      <pubDate>Sat, 27 Aug 2016 17:59:32 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/16_pof_lrtt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Instabilities of layers of deposited molecules on chemically stripe patterned substrates: Ridges vs. drops</title>
      <link>https://teshenglin.github.io/publication/15_lang_hlhtg/</link>
      <pubDate>Sun, 27 Sep 2015 17:59:16 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/15_lang_hlhtg/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Three-dimensional coating flow of nematic liquid crystal on an inclined substrate</title>
      <link>https://teshenglin.github.io/publication/15_ejam_lclk/</link>
      <pubDate>Mon, 27 Apr 2015 17:59:06 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/15_ejam_lclk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Coherent structures in non-local dispersive active-dissipative systems</title>
      <link>https://teshenglin.github.io/publication/15_sjam_lpkpt/</link>
      <pubDate>Fri, 27 Mar 2015 17:59:24 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/15_sjam_lpkpt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Modeling flow of nematic liquid crystal down an incline</title>
      <link>https://teshenglin.github.io/publication/14_jem_lclk/</link>
      <pubDate>Thu, 27 Mar 2014 17:58:56 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/14_jem_lclk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Numerical study of a non-local weakly nonlinear model for a liquid film sheared by a turbulent gas</title>
      <link>https://teshenglin.github.io/publication/14_iutam_ltk/</link>
      <pubDate>Mon, 27 Jan 2014 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/14_iutam_ltk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Note on the hydrodynamic description of thin nematic films: strong anchoring model</title>
      <link>https://teshenglin.github.io/publication/13_pof_lcakt/</link>
      <pubDate>Tue, 27 Aug 2013 18:17:07 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/13_pof_lcakt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Modelling spreading dynamics of nematic liquid crystals in three spatial dimensions</title>
      <link>https://teshenglin.github.io/publication/13_jfm_lktc/</link>
      <pubDate>Thu, 27 Jun 2013 17:58:35 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/13_jfm_lktc/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Thin films flowing down inverted substrates: Three-dimensional flow</title>
      <link>https://teshenglin.github.io/publication/12_pof_lkf/</link>
      <pubDate>Mon, 27 Feb 2012 17:49:39 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/12_pof_lkf/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Defect modeling in spreading nematic droplets</title>
      <link>https://teshenglin.github.io/publication/12_pre_lkc/</link>
      <pubDate>Fri, 27 Jan 2012 17:49:39 +0800</pubDate>
      <guid>https://teshenglin.github.io/publication/12_pre_lkc/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Modeling and simulations of the spreading and destabilization of nematic droplets</title>
      <link>https://teshenglin.github.io/publication/11_pof_clk/</link>
      <pubDate>Fri, 01 Apr 2011 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/11_pof_clk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Thin films flowing down inverted substrates: two dimensional flow</title>
      <link>https://teshenglin.github.io/publication/10_pof_lk/</link>
      <pubDate>Mon, 24 May 2010 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/10_pof_lk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A simple Dufort-Frankel type scheme for the Gross-Pitaevskii equation of Bose-Einstein condensates on different geometries</title>
      <link>https://teshenglin.github.io/publication/04_nmpde_lhl/</link>
      <pubDate>Thu, 26 Feb 2004 00:00:00 +0000</pubDate>
      <guid>https://teshenglin.github.io/publication/04_nmpde_lhl/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
